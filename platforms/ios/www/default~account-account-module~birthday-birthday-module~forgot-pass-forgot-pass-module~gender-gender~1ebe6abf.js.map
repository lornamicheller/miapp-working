{"version":3,"sources":["webpack:///./node_modules/@babel/runtime/helpers/arrayWithHoles.js","webpack:///./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js","webpack:///./node_modules/@babel/runtime/helpers/assertThisInitialized.js","webpack:///./node_modules/@babel/runtime/helpers/asyncToGenerator.js","webpack:///./node_modules/@babel/runtime/helpers/classCallCheck.js","webpack:///./node_modules/@babel/runtime/helpers/construct.js","webpack:///./node_modules/@babel/runtime/helpers/createClass.js","webpack:///./node_modules/@babel/runtime/helpers/defineProperty.js","webpack:///./node_modules/@babel/runtime/helpers/get.js","webpack:///./node_modules/@babel/runtime/helpers/getPrototypeOf.js","webpack:///./node_modules/@babel/runtime/helpers/inherits.js","webpack:///./node_modules/@babel/runtime/helpers/interopRequireDefault.js","webpack:///./node_modules/@babel/runtime/helpers/interopRequireWildcard.js","webpack:///./node_modules/@babel/runtime/helpers/isNativeFunction.js","webpack:///./node_modules/@babel/runtime/helpers/iterableToArray.js","webpack:///./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js","webpack:///./node_modules/@babel/runtime/helpers/nonIterableRest.js","webpack:///./node_modules/@babel/runtime/helpers/nonIterableSpread.js","webpack:///./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","webpack:///./node_modules/@babel/runtime/helpers/setPrototypeOf.js","webpack:///./node_modules/@babel/runtime/helpers/slicedToArray.js","webpack:///./node_modules/@babel/runtime/helpers/superPropBase.js","webpack:///./node_modules/@babel/runtime/helpers/toConsumableArray.js","webpack:///./node_modules/@babel/runtime/helpers/typeof.js","webpack:///./node_modules/@babel/runtime/helpers/wrapNativeSuper.js","webpack:///./node_modules/@babel/runtime/node_modules/regenerator-runtime/runtime.js","webpack:///./node_modules/@babel/runtime/regenerator/index.js","webpack:///./node_modules/events/events.js","webpack:///./node_modules/parse/index.js","webpack:///./node_modules/parse/lib/browser/Analytics.js","webpack:///./node_modules/parse/lib/browser/AnonymousUtils.js","webpack:///./node_modules/parse/lib/browser/Cloud.js","webpack:///./node_modules/parse/lib/browser/CoreManager.js","webpack:///./node_modules/parse/lib/browser/EventEmitter.js","webpack:///./node_modules/parse/lib/browser/FacebookUtils.js","webpack:///./node_modules/parse/lib/browser/InstallationController.js","webpack:///./node_modules/parse/lib/browser/LiveQueryClient.js","webpack:///./node_modules/parse/lib/browser/LiveQuerySubscription.js","webpack:///./node_modules/parse/lib/browser/LocalDatastore.js","webpack:///./node_modules/parse/lib/browser/LocalDatastoreController.browser.js","webpack:///./node_modules/parse/lib/browser/LocalDatastoreUtils.js","webpack:///./node_modules/parse/lib/browser/ObjectStateMutations.js","webpack:///./node_modules/parse/lib/browser/OfflineQuery.js","webpack:///./node_modules/parse/lib/browser/Parse.js","webpack:///./node_modules/parse/lib/browser/ParseACL.js","webpack:///./node_modules/parse/lib/browser/ParseConfig.js","webpack:///./node_modules/parse/lib/browser/ParseError.js","webpack:///./node_modules/parse/lib/browser/ParseFile.js","webpack:///./node_modules/parse/lib/browser/ParseGeoPoint.js","webpack:///./node_modules/parse/lib/browser/ParseInstallation.js","webpack:///./node_modules/parse/lib/browser/ParseLiveQuery.js","webpack:///./node_modules/parse/lib/browser/ParseObject.js","webpack:///./node_modules/parse/lib/browser/ParseOp.js","webpack:///./node_modules/parse/lib/browser/ParsePolygon.js","webpack:///./node_modules/parse/lib/browser/ParseQuery.js","webpack:///./node_modules/parse/lib/browser/ParseRelation.js","webpack:///./node_modules/parse/lib/browser/ParseRole.js","webpack:///./node_modules/parse/lib/browser/ParseSchema.js","webpack:///./node_modules/parse/lib/browser/ParseSession.js","webpack:///./node_modules/parse/lib/browser/ParseUser.js","webpack:///./node_modules/parse/lib/browser/Push.js","webpack:///./node_modules/parse/lib/browser/RESTController.js","webpack:///./node_modules/parse/lib/browser/SingleInstanceStateController.js","webpack:///./node_modules/parse/lib/browser/Storage.js","webpack:///./node_modules/parse/lib/browser/StorageController.browser.js","webpack:///./node_modules/parse/lib/browser/TaskQueue.js","webpack:///./node_modules/parse/lib/browser/UniqueInstanceStateController.js","webpack:///./node_modules/parse/lib/browser/arrayContainsObject.js","webpack:///./node_modules/parse/lib/browser/canBeSerialized.js","webpack:///./node_modules/parse/lib/browser/decode.js","webpack:///./node_modules/parse/lib/browser/encode.js","webpack:///./node_modules/parse/lib/browser/equals.js","webpack:///./node_modules/parse/lib/browser/escape.js","webpack:///./node_modules/parse/lib/browser/isRevocableSession.js","webpack:///./node_modules/parse/lib/browser/parseDate.js","webpack:///./node_modules/parse/lib/browser/promiseUtils.js","webpack:///./node_modules/parse/lib/browser/unique.js","webpack:///./node_modules/parse/lib/browser/unsavedChildren.js","webpack:///./node_modules/uuid/lib/bytesToUuid.js","webpack:///./node_modules/uuid/lib/rng-browser.js","webpack:///./node_modules/uuid/v4.js"],"names":[],"mappings":";;;;;;;;;AAAA;AACA;AACA;;AAEA,iC;;;;;;;;;;;ACJA;AACA;AACA,iDAAiD,gBAAgB;AACjE;AACA;;AAEA;AACA;AACA;;AAEA,oC;;;;;;;;;;;ACVA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wC;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA,mC;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;;AAEA,iC;;;;;;;;;;;ACNA,qBAAqB,mBAAO,CAAC,iFAAkB;;AAE/C;AACA;AACA;AACA;;AAEA;AACA,2EAA2E;AAC3E;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,4B;;;;;;;;;;;AChCA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,8B;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;;AAEA;AACA;;AAEA,iC;;;;;;;;;;;ACfA,qBAAqB,mBAAO,CAAC,iFAAkB;;AAE/C,oBAAoB,mBAAO,CAAC,+EAAiB;;AAE7C;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,sB;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;;AAEA,iC;;;;;;;;;;;ACPA,qBAAqB,mBAAO,CAAC,iFAAkB;;AAE/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA,2B;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;;AAEA,wC;;;;;;;;;;;ACNA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,yC;;;;;;;;;;;ACzBA;AACA;AACA;;AAEA,mC;;;;;;;;;;;ACJA;AACA;AACA;;AAEA,kC;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C,+BAA+B;AAC5E;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA,uC;;;;;;;;;;;AC1BA;AACA;AACA;;AAEA,kC;;;;;;;;;;;ACJA;AACA;AACA;;AAEA,oC;;;;;;;;;;;ACJA,cAAc,mBAAO,CAAC,0EAAmB;;AAEzC,4BAA4B,mBAAO,CAAC,+FAAyB;;AAE7D;AACA;AACA;AACA;;AAEA;AACA;;AAEA,4C;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iC;;;;;;;;;;;ACTA,qBAAqB,mBAAO,CAAC,iFAAkB;;AAE/C,2BAA2B,mBAAO,CAAC,6FAAwB;;AAE3D,sBAAsB,mBAAO,CAAC,mFAAmB;;AAEjD;AACA;AACA;;AAEA,gC;;;;;;;;;;;ACVA,qBAAqB,mBAAO,CAAC,iFAAkB;;AAE/C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,gC;;;;;;;;;;;ACXA,wBAAwB,mBAAO,CAAC,uFAAqB;;AAErD,sBAAsB,mBAAO,CAAC,mFAAmB;;AAEjD,wBAAwB,mBAAO,CAAC,uFAAqB;;AAErD;AACA;AACA;;AAEA,oC;;;;;;;;;;;ACVA,wBAAwB,2EAA2E,oCAAoC,mBAAmB,GAAG,EAAE,OAAO,oCAAoC,8HAA8H,GAAG,EAAE,sBAAsB;;AAEnW;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA,yB;;;;;;;;;;;AChBA,qBAAqB,mBAAO,CAAC,iFAAkB;;AAE/C,qBAAqB,mBAAO,CAAC,iFAAkB;;AAE/C,uBAAuB,mBAAO,CAAC,qFAAoB;;AAEnD,gBAAgB,mBAAO,CAAC,uEAAa;;AAErC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA,kC;;;;;;;;;;;AC1CA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,KAAK;AACL,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;;AAEA;AACA;AACA,wCAAwC,WAAW;AACnD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC,cAAc;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC,kBAAkB;AACnD;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB;;AAEjB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;;AAEA;AACA,YAAY;AACZ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,8CAA8C,QAAQ;AACtD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA,WAAW;AACX;AACA;AACA;;AAEA,WAAW;AACX;AACA;AACA;;AAEA,WAAW;AACX;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,KAAK;;AAEL;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,CAAC;AACD;AACA;AACA;AACA;AACA,EAAE,KAA0B,oBAAoB,SAAE;AAClD;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrtBA,iBAAiB,mBAAO,CAAC,sGAAqB;;;;;;;;;;;;;ACA9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,sBAAsB;AACvC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,QAAQ,yBAAyB;AACjC;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;;;;;;;;;;;;AC/bA,iBAAiB,mBAAO,CAAC,yEAAwB;;;;;;;;;;;;;ACApC;;AAEb,6BAA6B,mBAAO,CAAC,oHAA8C;;AAEnF;AACA;AACA,CAAC;AACD;;AAEA,0CAA0C,mBAAO,CAAC,sEAAe;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,aAAa;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA,YAAY,OAAO;AACnB;AACA,aAAa,QAAQ;AACrB;AACA;;;AAGA;AACA;AACA;AACA,KAAK,wBAAwB;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA,+D;;;;;;;;;;;;ACjGa;;AAEb,6BAA6B,mBAAO,CAAC,oHAA8C;;AAEnF;AACA;AACA,CAAC;AACD;;AAEA,wCAAwC,mBAAO,CAAC,kEAAa;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,aAAa,mBAAO,CAAC,0CAAS;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,WAAW;AACxB;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,aAAa,WAAW;AACxB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,2B;;;;;;;;;;;;AClIa;;AAEb,6BAA6B,mBAAO,CAAC,oHAA8C;;AAEnF;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA,sCAAsC,mBAAO,CAAC,sFAA+B;;AAE7E,0CAA0C,mBAAO,CAAC,sEAAe;;AAEjE,qCAAqC,mBAAO,CAAC,4DAAU;;AAEvD,qCAAqC,mBAAO,CAAC,4DAAU;;AAEvD,yCAAyC,mBAAO,CAAC,oEAAc;;AAE/D,yCAAyC,mBAAO,CAAC,oEAAc;;AAE/D,0CAA0C,mBAAO,CAAC,sEAAe;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,aAAa,QAAQ;AACrB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,aAAa,QAAQ;AACrB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,aAAa,aAAa;AAC1B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,2D;;;;;;;;;;;;AC5LA,kBAAkB,2CAA2C,+BAA+B;;AAE5F,8CAA8C;;AAE9C,kBAAkB,aAAa,oBAAoB;;AAEnD,kBAAkB,KAAK,kBAAkB;;AAEzC,kDAAkD;;AAElD,kBAAkB,YAAY,qBAAqB;;AAEnD,8CAA8C;;AAE9C,kBAAkB,WAAW,oBAAoB;;AAEjD,kBAAkB,WAAW,eAAe;;AAE5C,kBAAkB,8BAA8B,yBAAyB;;AAEzE;AACA,qCAAqC,wBAAwB;AAC7D,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA,iBAAiB,qBAAqB;AACtC,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACW;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,uBAAuB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,E;;;;;;;;;;;;AC7ba;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,+CAAQ;AACjC,iB;;;;;;;;;;;;ACba;;AAEb,6BAA6B,mBAAO,CAAC,oHAA8C;;AAEnF;AACA;AACA,CAAC;AACD;;AAEA,wCAAwC,mBAAO,CAAC,kEAAa;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;;AAGP,gCAAgC;AAChC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,+DAA+D;;;AAG/D;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,aAAa,WAAW;AACxB;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA,MAAM;AACN;AACA,qDAAqD;AACrD;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE;AACzE;AACA;AACA,MAAM;AACN;AACA,2EAA2E;AAC3E;AACA;AACA;AACA,aAAa,WAAW;AACxB;AACA,aAAa,gBAAgB;AAC7B;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,aAAa,WAAW;AACxB;AACA,aAAa,OAAO;AACpB;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,2B;;;;;;;;;;;;ACnQa;;AAEb,6BAA6B,mBAAO,CAAC,oHAA8C;;AAEnF,sCAAsC,mBAAO,CAAC,8DAAW;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,wC;;;;;;;;;;;;AC3Da;;AAEb,6BAA6B,mBAAO,CAAC,oHAA8C;;AAEnF;AACA;AACA,CAAC;AACD;;AAEA,sCAAsC,mBAAO,CAAC,sFAA+B;;AAE7E,8CAA8C,mBAAO,CAAC,sGAAuC;;AAE7F,2CAA2C,mBAAO,CAAC,gGAAoC;;AAEvF,yDAAyD,mBAAO,CAAC,4HAAkD;;AAEnH,8CAA8C,mBAAO,CAAC,sGAAuC;;AAE7F,qDAAqD,mBAAO,CAAC,oHAA8C;;AAE3G,wCAAwC,mBAAO,CAAC,0FAAiC;;AAEjF,8CAA8C,mBAAO,CAAC,sGAAuC;;AAE7F,0CAA0C,mBAAO,CAAC,sEAAe;;AAEjE,4CAA4C,mBAAO,CAAC,wEAAgB;;AAEpE,0CAA0C,mBAAO,CAAC,sEAAe;;AAEjE,oDAAoD,mBAAO,CAAC,0FAAyB;;AAErF,oBAAoB,mBAAO,CAAC,wEAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,EAAE;AACN;AACA;AACA;AACA;AACA;AACA,IAAI,EAAE;AACN;AACA;AACA;AACA;AACA;AACA,IAAI,EAAE;AACN;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,gBAAgB,OAAO;AACvB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;;;AAGP,gEAAgE;;AAEhE;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B;;AAE1B;AACA;AACA;;AAEA;AACA,mFAAmF,gEAAgE;AACnJ;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,0CAA0C;;AAE1C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,mFAAmF;AACnF;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA,4CAA4C;;AAE5C;AACA;AACA;;AAEA;AACA,qFAAqF,mEAAmE;AACxJ;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qFAAqF,mEAAmE;AACxJ;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,wBAAwB;;;AAGxB;AACA;AACA;;AAEA;AACA,iDAAiD;AACjD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA,CAAC;;AAED;AACA,2B;;;;;;;;;;;;AC1mBa;;AAEb,6BAA6B,mBAAO,CAAC,oHAA8C;;AAEnF;AACA;AACA,CAAC;AACD;;AAEA,8CAA8C,mBAAO,CAAC,sGAAuC;;AAE7F,2CAA2C,mBAAO,CAAC,gGAAoC;;AAEvF,yDAAyD,mBAAO,CAAC,4HAAkD;;AAEnH,8CAA8C,mBAAO,CAAC,sGAAuC;;AAE7F,wCAAwC,mBAAO,CAAC,0FAAiC;;AAEjF,4CAA4C,mBAAO,CAAC,wEAAgB;;AAEpE,0CAA0C,mBAAO,CAAC,sEAAe;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,EAAE;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,EAAE;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,EAAE;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,EAAE;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,EAAE;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,EAAE;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,EAAE;AACN;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;;AAEA,oCAAoC;;AAEpC;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA,CAAC;;AAED;AACA,2B;;;;;;;;;;;;AChKa;;AAEb,6BAA6B,mBAAO,CAAC,oHAA8C;;AAEnF,0CAA0C,mBAAO,CAAC,sFAA4B;;AAE9E,iDAAiD,mBAAO,CAAC,4GAA0C;;AAEnG,6CAA6C,mBAAO,CAAC,oGAAsC;;AAE3F,gDAAgD,mBAAO,CAAC,0GAAyC;;AAEjG,0CAA0C,mBAAO,CAAC,sEAAe;;AAEjE,yCAAyC,mBAAO,CAAC,oEAAc;;AAE/D,2BAA2B,mBAAO,CAAC,sFAAuB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,4CAA4C;AAC5C;AACA;AACA;AACA,mCAAmC;AACnC,wBAAwB;AACxB,gCAAgC;AAChC;AACA,gDAAgD;AAChD;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0DAA0D,gEAAgE;AAC1H;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2DAA2D,mEAAmE;AAC9H;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe;;AAEf;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe;;AAEf;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B;;AAE/B,6JAA6J;;AAE7J;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA,eAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe;AACf;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iDAAiD,mBAAO,CAAC,gHAAoC;;AAE7F,uD;;;;;;;;;;;;AC57Ba;;AAEb,2BAA2B,mBAAO,CAAC,sFAAuB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA,mBAAmB,yBAAyB;AAC5C;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA,mBAAmB,yBAAyB;AAC5C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0C;;;;;;;;;;;;ACrGa;;AAEb;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC/Ba;;AAEb,6BAA6B,mBAAO,CAAC,oHAA8C;;AAEnF;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sCAAsC,mBAAO,CAAC,sFAA+B;;AAE7E,qCAAqC,mBAAO,CAAC,4DAAU;;AAEvD,wCAAwC,mBAAO,CAAC,kEAAa;;AAE7D,0CAA0C,mBAAO,CAAC,sEAAe;;AAEjE,4CAA4C,mBAAO,CAAC,0EAAiB;;AAErE,wCAAwC,mBAAO,CAAC,kEAAa;;AAE7D,eAAe,mBAAO,CAAC,8DAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,mBAAmB;AACnB,mBAAmB;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA,iCAAiC,KAAK,KAAK,WAAW,EAAE;AACxD;AACA;AACA,uCAAuC;;AAEvC,0BAA0B,wBAAwB;AAClD;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC5Na;;AAEb,6BAA6B,mBAAO,CAAC,oHAA8C;;AAEnF,sCAAsC,mBAAO,CAAC,sFAA+B;;AAE7E,mBAAmB,mBAAO,CAAC,4DAAU;;AAErC,aAAa,mBAAO,CAAC,4DAAU;;AAE/B,iBAAiB,mBAAO,CAAC,oEAAc;;AAEvC,mBAAmB,mBAAO,CAAC,wEAAgB;;AAE3C,oBAAoB,mBAAO,CAAC,0EAAiB;AAC7C;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sEAAsE;AACtE;;AAEA;;AAEA;AACA,eAAe,wBAAwB;AACvC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,eAAe,wBAAwB;AACvC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,eAAe,wBAAwB;AACvC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA,GAAG;;;AAGH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;;;AAGX;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kEAAkE;;AAElE;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;;AAEX,0BAA0B,6BAA6B;AACvD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;;AAEX,2BAA2B,+BAA+B;AAC1D;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;;AAEX,2BAA2B,gCAAgC;AAC3D;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;;AAEX,2BAA2B,gCAAgC;AAC3D;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,uEAAuE,gEAAgE;AACvI;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,8B;;;;;;;;;;;;ACvea;;AAEb,8BAA8B,mBAAO,CAAC,sHAA+C;;AAErF,6BAA6B,mBAAO,CAAC,oHAA8C;;AAEnF,qCAAqC,mBAAO,CAAC,4DAAU;;AAEvD,qCAAqC,mBAAO,CAAC,4DAAU;;AAEvD,0CAA0C,mBAAO,CAAC,sEAAe;;AAEjE,qDAAqD,mBAAO,CAAC,4FAA0B;;AAEvF,sCAAsC,mBAAO,CAAC,8DAAW;;AAEzD,6CAA6C,mBAAO,CAAC,4EAAkB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,KAAuB;AAC/B;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,gCAAgC;AAChC,aAAa,yBAAyB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,CAAC;AACD;;AAEA,YAAY,mBAAO,CAAC,gEAAY;AAChC,kBAAkB,mBAAO,CAAC,kEAAa;AACvC,uBAAuB,mBAAO,CAAC,4EAAkB;AACjD,cAAc,mBAAO,CAAC,0DAAS;AAC/B,oBAAoB,mBAAO,CAAC,sEAAe;AAC3C,eAAe,mBAAO,CAAC,sEAAe;AACtC,cAAc,mBAAO,CAAC,oEAAc;AACpC,sBAAsB,mBAAO,CAAC,0EAAiB;AAC/C,aAAa,mBAAO,CAAC,kEAAa;AAClC,iBAAiB,mBAAO,CAAC,0EAAiB;AAC1C,gBAAgB,mBAAO,CAAC,wEAAgB;AACxC,qBAAqB,mBAAO,CAAC,kFAAqB;AAClD,uBAAuB,mBAAO,CAAC,4EAAkB;AACjD,eAAe,mBAAO,CAAC,sEAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,mBAAO,CAAC,wDAAQ;AAC7B,cAAc,mBAAO,CAAC,oEAAc;AACpC,iBAAiB,mBAAO,CAAC,0EAAiB;AAC1C,aAAa,mBAAO,CAAC,kEAAa;AAClC,eAAe,mBAAO,CAAC,sEAAe;AACtC,gBAAgB,mBAAO,CAAC,wEAAgB;AACxC,gBAAgB,mBAAO,CAAC,8DAAW;AACnC,aAAa,mBAAO,CAAC,kEAAa;AAClC,kBAAkB,mBAAO,CAAC,4EAAkB;AAC5C,wBAAwB,mBAAO,CAAC,8EAAmB;;AAEnD;AACA,qEAAqE,aAAa;AAClF;AACA;;AAEA;AACA;;AAEA;AACA,wEAAwE,eAAe;AACvF;AACA;;AAEA;AACA,EAAE;;;AAGF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,qEAAqE;;AAErE,6BAA6B;AAC7B,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,uB;;;;;;;;;;;;ACtTa;;AAEb,6BAA6B,mBAAO,CAAC,oHAA8C;;AAEnF;AACA;AACA,CAAC;AACD;;AAEA,sCAAsC,mBAAO,CAAC,sFAA+B;;AAE7E,8CAA8C,mBAAO,CAAC,sGAAuC;;AAE7F,2CAA2C,mBAAO,CAAC,gGAAoC;;AAEvF,8CAA8C,mBAAO,CAAC,sGAAuC;;AAE7F,wCAAwC,mBAAO,CAAC,kEAAa;;AAE7D,wCAAwC,mBAAO,CAAC,kEAAa;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,oBAAoB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB,UAAU;AAC1B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB,UAAU;AAC1B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,UAAU;AAC1B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,UAAU;AAC1B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED;AACA,2B;;;;;;;;;;;;ACjda;;AAEb,6BAA6B,mBAAO,CAAC,oHAA8C;;AAEnF;AACA;AACA,CAAC;AACD;;AAEA,sCAAsC,mBAAO,CAAC,sFAA+B;;AAE7E,8CAA8C,mBAAO,CAAC,sGAAuC;;AAE7F,2CAA2C,mBAAO,CAAC,gGAAoC;;AAEvF,8CAA8C,mBAAO,CAAC,sGAAuC;;AAE7F,0CAA0C,mBAAO,CAAC,sEAAe;;AAEjE,qCAAqC,mBAAO,CAAC,4DAAU;;AAEvD,qCAAqC,mBAAO,CAAC,4DAAU;;AAEvD,sCAAsC,mBAAO,CAAC,4DAAU;;AAExD,yCAAyC,mBAAO,CAAC,oEAAc;;AAE/D,sCAAsC,mBAAO,CAAC,8DAAW;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;;AAEA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;;AAEA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;;AAEA,GAAG;AACH;AACA;AACA,SAAS,qBAAqB;AAC9B;AACA,kEAAkE;;;AAGlE;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;;AAGL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL,GAAG;AACH;AACA;;AAEA,qDAAqD,IAAI;AACzD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA,OAAO,qBAAqB;AAC5B;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA,2B;;;;;;;;;;;;ACtQa;;AAEb,6BAA6B,mBAAO,CAAC,oHAA8C;;AAEnF;AACA;AACA,CAAC;AACD;;AAEA,8CAA8C,mBAAO,CAAC,sGAAuC;;AAE7F,2CAA2C,mBAAO,CAAC,gGAAoC;;AAEvF,yDAAyD,mBAAO,CAAC,4HAAkD;;AAEnH,8CAA8C,mBAAO,CAAC,sGAAuC;;AAE7F,qDAAqD,mBAAO,CAAC,oHAA8C;;AAE3G,wCAAwC,mBAAO,CAAC,0FAAiC;;AAEjF,+CAA+C,mBAAO,CAAC,wGAAwC;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2B;;;;;;;;;;;;ACliBa;;AAEb,6BAA6B,mBAAO,CAAC,oHAA8C;;AAEnF;AACA;AACA,CAAC;AACD;;AAEA,0CAA0C,mBAAO,CAAC,sFAA4B;;AAE9E,gDAAgD,mBAAO,CAAC,0GAAyC;;AAEjG,8CAA8C,mBAAO,CAAC,sGAAuC;;AAE7F,2CAA2C,mBAAO,CAAC,gGAAoC;;AAEvF,8CAA8C,mBAAO,CAAC,sGAAuC;;AAE7F,0CAA0C,mBAAO,CAAC,sEAAe;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;;AAEA;AACA;AACA;AACA,oBAAoB,kBAAkB;;AAEtC,iBAAiB,eAAe;;AAEhC,yDAAyD;;AAEzD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,EAAE;;;AAGF,yDAAyD,2BAA2B;;AAEpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA,kBAAkB,MAAM;AACxB;AACA,4BAA4B,gBAAgB;AAC5C,4BAA4B,aAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR,MAAM;AACN,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,4EAA4E;;AAE5E;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;;AAEP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB;AAChB;;AAEA,GAAG;AACH;AACA;AACA,aAAa,wBAAwB;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,SAAS,8BAA8B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;;AAGP;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS,aAAa,qBAAqB;AAC3C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,2B;;;;;;;;;;;;AC1fa;;AAEb,6BAA6B,mBAAO,CAAC,oHAA8C;;AAEnF;AACA;AACA,CAAC;AACD;;AAEA,sCAAsC,mBAAO,CAAC,sFAA+B;;AAE7E,8CAA8C,mBAAO,CAAC,sGAAuC;;AAE7F,2CAA2C,mBAAO,CAAC,gGAAoC;;AAEvF,8CAA8C,mBAAO,CAAC,sGAAuC;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4BAA4B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA,aAAa,yBAAyB;AACtC,aAAa,OAAO;AACpB;AACA;AACA;AACA,OAAO,kBAAkB,oBAAoB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS,gBAAgB,kBAAkB,oBAAoB;AAC/D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,eAAe;AAC/B,gBAAgB;AAChB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;;AAEjE;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,eAAe;AAC/B,gBAAgB;AAChB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,eAAe;AAC/B,gBAAgB;AAChB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA,CAAC;;AAED;AACA,2B;;;;;;;;;;;;ACzQa;;AAEb,6BAA6B,mBAAO,CAAC,oHAA8C;;AAEnF;AACA;AACA,CAAC;AACD;;AAEA,sCAAsC,mBAAO,CAAC,sFAA+B;;AAE7E,8CAA8C,mBAAO,CAAC,sGAAuC;;AAE7F,yDAAyD,mBAAO,CAAC,4HAAkD;;AAEnH,8CAA8C,mBAAO,CAAC,sGAAuC;;AAE7F,wCAAwC,mBAAO,CAAC,0FAAiC;;AAEjF,2CAA2C,mBAAO,CAAC,sEAAe;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qCAAqC;AACrC;AACA;AACA;;AAEA;AACA;;AAEA;AACA,CAAC;;AAED;;AAEA,sE;;;;;;;;;;;;AC3Da;;AAEb,6BAA6B,mBAAO,CAAC,oHAA8C;;AAEnF;AACA;AACA,CAAC;AACD;;AAEA,0CAA0C,mBAAO,CAAC,sFAA4B;;AAE9E,gDAAgD,mBAAO,CAAC,0GAAyC;;AAEjG,2CAA2C,mBAAO,CAAC,wEAAgB;;AAEnE,8CAA8C,mBAAO,CAAC,8EAAmB;;AAEzE,0CAA0C,mBAAO,CAAC,sEAAe;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,EAAE;AACN;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,EAAE;AACN;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,EAAE;AACN;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC,GAAG;;AAEJ,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,eAAe;AACf;AACA;AACA,eAAe;AACf;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA,wE;;;;;;;;;;;;AC5Na;;AAEb,8BAA8B,mBAAO,CAAC,sHAA+C;;AAErF,6BAA6B,mBAAO,CAAC,oHAA8C;;AAEnF;AACA;AACA,CAAC;AACD;;AAEA,0CAA0C,mBAAO,CAAC,sFAA4B;;AAE9E,gDAAgD,mBAAO,CAAC,0GAAyC;;AAEjG,sCAAsC,mBAAO,CAAC,sFAA+B;;AAE7E,8CAA8C,mBAAO,CAAC,sGAAuC;;AAE7F,2CAA2C,mBAAO,CAAC,gGAAoC;;AAEvF,8CAA8C,mBAAO,CAAC,sGAAuC;;AAE7F,0CAA0C,mBAAO,CAAC,sEAAe;;AAEjE,8CAA8C,mBAAO,CAAC,8EAAmB;;AAEzE,qCAAqC,mBAAO,CAAC,4DAAU;;AAEvD,qCAAqC,mBAAO,CAAC,4DAAU;;AAEvD,sCAAsC,mBAAO,CAAC,4DAAU;;AAExD,uCAAuC,mBAAO,CAAC,gEAAY;;AAE3D,wCAAwC,mBAAO,CAAC,kEAAa;;AAE7D,yCAAyC,mBAAO,CAAC,oEAAc;;AAE/D,wCAAwC,mBAAO,CAAC,kEAAa;;AAE7D,oBAAoB,mBAAO,CAAC,wEAAgB;;AAE5C,2BAA2B,mBAAO,CAAC,sFAAuB;;AAE1D,eAAe,mBAAO,CAAC,8DAAW;;AAElC,yCAAyC,mBAAO,CAAC,oEAAc;;AAE/D,4CAA4C,mBAAO,CAAC,0EAAiB;;AAErE,4DAA4D,mBAAO,CAAC,0GAAiC;;AAErG,qCAAqC,mBAAO,CAAC,4DAAU;;AAEvD,4DAA4D,mBAAO,CAAC,0GAAiC;;AAErG,8CAA8C,mBAAO,CAAC,8EAAmB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,4BAA4B;AAC5B;;AAEA,kBAAkB;;AAElB,mBAAmB;;AAEnB,oBAAoB;AACpB;AACA;;AAEA;;AAEA;AACA;AACA,CAAC;AACD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA,iBAAiB,2CAA2C;AAC5D;AACA,WAAW,wBAAwB;AACnC;AACA,WAAW,4BAA4B;AACvC;AACA;AACA;AACA;AACA;AACA,6DAA6D;;AAE7D;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA,uBAAuB,8BAA8B;AACrD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,uBAAuB;AAClC;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA,GAAG;AACH;AACA,yBAAyB;;AAEzB;AACA;AACA,gBAAgB;AAChB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB;AAChB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB;AAChB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB;AAChB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,oCAAoC;AACpC;AACA,sCAAsC;AACtC;AACA,eAAe,OAAO;AACtB,gBAAgB;AAChB,eAAe,OAAO;AACtB;AACA,gBAAgB,QAAQ;AACxB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA,8CAA8C;;AAE9C;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;;AAGP;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;;;AAGP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;;;AAGP;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA,aAAa,uBAAuB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,sBAAsB,OAAO;AAC7B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,qBAAqB;AACrB,gBAAgB;AAChB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,qBAAqB,SAAS;AAC9B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,qBAAqB;AACrB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,qBAAqB,SAAS;AAC9B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,qBAAqB;AACrB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,qBAAqB,SAAS;AAC9B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,iBAAiB,SAAS;AAC1B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC,KAAK;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,mEAAmE;AACnE;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB,gBAAgB,QAAQ;AACxB;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA,0EAA0E,cAAc;AACxF;AACA;;AAEA;AACA;;AAEA,sCAAsC,mBAAmB;AACzD;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mCAAmC;AAClD,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,4BAA4B;AAC5B;AACA,oCAAoC;AACpC;AACA,qCAAqC;AACrC;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU,EAAE;AACZ;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;;AAEA,GAAG;AACH;AACA;AACA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP,uBAAuB,uBAAuB,sBAAsB,EAAE;;;AAGtE;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;;AAEP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,QAAQ;AACxB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,QAAQ;AACxB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;;AAEP;AACA;AACA;AACA,KAAK;AACL;;AAEA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA,eAAe,MAAM;AACrB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA,eAAe,MAAM;AACrB,eAAe,mCAAmC;AAClD,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA,eAAe,MAAM;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,6BAA6B,yBAAyB;AACtD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,UAAU;AACV;AACA;AACA,eAAe,MAAM;AACrB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA,eAAe,MAAM;AACrB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,aAAa;AAC7B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB;AACA;AACA,gBAAgB,aAAa;AAC7B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,MAAM;AACrB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,YAAY,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,YAAY,EAAE;AACd;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,MAAM;AACtB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,uCAAuC;;AAEvC;AACA;AACA;;AAEA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,gBAAgB,QAAQ;AACxB;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,MAAM;AACrB,gBAAgB,QAAQ;AACxB;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,gBAAgB,QAAQ;AACxB;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,MAAM;AACrB,gBAAgB,QAAQ;AACxB;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,QAAQ;AACxB;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC,sBAAsB;AACvD;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;;AAET;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;;AAET;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,eAAe;;AAEf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,mBAAmB;AACnB,mCAAmC,oBAAoB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,iBAAiB;AACjB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,eAAe;;AAEf;AACA;AACA;AACA;AACA;;AAEA,0IAA0I;AAC1I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,eAAe;;AAEf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA,WAAW;AACX;;;AAGA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA,+FAA+F;;AAE/F;AACA;;AAEA;AACA;AACA,eAAe;AACf,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe;AACf,aAAa;AACb,WAAW;AACX;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,2B;;;;;;;;;;;;ACjrGa;;AAEb,6BAA6B,mBAAO,CAAC,oHAA8C;;AAEnF;AACA;AACA,CAAC;AACD;AACA;;AAEA,yDAAyD,mBAAO,CAAC,4HAAkD;;AAEnH,8CAA8C,mBAAO,CAAC,sGAAuC;;AAE7F,qDAAqD,mBAAO,CAAC,oHAA8C;;AAE3G,wCAAwC,mBAAO,CAAC,0FAAiC;;AAEjF,8CAA8C,mBAAO,CAAC,sGAAuC;;AAE7F,8CAA8C,mBAAO,CAAC,sGAAuC;;AAE7F,2CAA2C,mBAAO,CAAC,gGAAoC;;AAEvF,kDAAkD,mBAAO,CAAC,sFAAuB;;AAEjF,qCAAqC,mBAAO,CAAC,4DAAU;;AAEvD,qCAAqC,mBAAO,CAAC,4DAAU;;AAEvD,0CAA0C,mBAAO,CAAC,sEAAe;;AAEjE,4CAA4C,mBAAO,CAAC,0EAAiB;;AAErE,qCAAqC,mBAAO,CAAC,4DAAU;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,KAAK,qBAAqB;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,qBAAqB;AAC5C;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,SAAS,eAAe;AACxB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,SAAS,cAAc,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,SAAS,cAAc,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,SAAS,cAAc,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,wBAAwB;AAC/C;;AAEA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,oBAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,SAAS,cAAc,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,aAAa,iCAAiC;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,SAAS,eAAe,iBAAiB,cAAc;AACvD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED,gC;;;;;;;;;;;;ACrxBa;;AAEb,6BAA6B,mBAAO,CAAC,oHAA8C;;AAEnF;AACA;AACA,CAAC;AACD;;AAEA,8CAA8C,mBAAO,CAAC,sGAAuC;;AAE7F,2CAA2C,mBAAO,CAAC,gGAAoC;;AAEvF,8CAA8C,mBAAO,CAAC,sGAAuC;;AAE7F,4CAA4C,mBAAO,CAAC,0EAAiB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;;;AAGA;AACA;AACA;AACA;AACA,aAAa,8BAA8B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,SAAS,gBAAgB,oCAAoC;AAC7D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC,iBAAiB;AACjB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,qBAAqB,8BAA8B;AACnD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,iBAAiB,QAAQ;AACzB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,8BAA8B;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,wDAAwD,+BAA+B;AACvF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,gBAAgB;AAChB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,qBAAqB,mBAAmB;AACxC;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED;AACA,2B;;;;;;;;;;;;AC1Na;;AAEb,6BAA6B,mBAAO,CAAC,oHAA8C;;AAEnF;AACA;AACA,CAAC;AACD;;AAEA,sCAAsC,mBAAO,CAAC,sFAA+B;;AAE7E,0CAA0C,mBAAO,CAAC,sFAA4B;;AAE9E,gDAAgD,mBAAO,CAAC,0GAAyC;;AAEjG,8CAA8C,mBAAO,CAAC,sGAAuC;;AAE7F,2CAA2C,mBAAO,CAAC,gGAAoC;;AAEvF,8CAA8C,mBAAO,CAAC,sGAAuC;;AAE7F,0CAA0C,mBAAO,CAAC,sEAAe;;AAEjE,qCAAqC,mBAAO,CAAC,4DAAU;;AAEvD,oBAAoB,mBAAO,CAAC,wEAAgB;;AAE5C,yCAAyC,mBAAO,CAAC,oEAAc;;AAE/D,4CAA4C,mBAAO,CAAC,0EAAiB;;AAErE,0CAA0C,mBAAO,CAAC,sEAAe;;AAEjE,2CAA2C,mBAAO,CAAC,wEAAgB;;AAEnE,2BAA2B,mBAAO,CAAC,sFAAuB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;;AAGT;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI,EAAE;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI,EAAE;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI,EAAE;AACN;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,sBAAsB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,cAAc,YAAY;AAC1B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,gBAAgB,YAAY;AAC5B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,gBAAgB,YAAY;AAC5B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,mBAAmB;AACnB;;AAEA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;;AAEA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;;AAEP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,gBAAgB,OAAO;AACvB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,gBAAgB,YAAY;AAC5B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,iBAAiB,UAAU;AAC3B,mBAAmB,YAAY;AAC/B;;AAEA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;;;AAGA;AACA;AACA;;AAEA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;;AAGA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iDAAiD;AACjD;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA,SAAS;AACT;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,YAAY;AAC5B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,YAAY;AAC5B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,YAAY;AAC5B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,YAAY;AAC5B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,YAAY;AAC5B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,YAAY;AAC5B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,MAAM;AACrB,gBAAgB,YAAY;AAC5B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,MAAM;AACrB,gBAAgB,YAAY;AAC5B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,MAAM;AACrB,gBAAgB,YAAY;AAC5B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,MAAM;AACrB,gBAAgB,YAAY;AAC5B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,cAAc;AAC7B,gBAAgB,YAAY;AAC5B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,YAAY;AAC5B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,YAAY;AAC5B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,gBAAgB,YAAY;AAC5B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,YAAY;AAC3B,gBAAgB,YAAY;AAC5B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,YAAY;AAC3B,gBAAgB,YAAY;AAC5B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,YAAY;AAC3B,gBAAgB,YAAY;AAC5B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,YAAY;AAC3B,gBAAgB,YAAY;AAC5B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,gBAAgB,YAAY;AAC5B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,2CAA2C;AACpF;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,eAAe,YAAY;AAC3B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,gBAAgB,YAAY;AAC5B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,gBAAgB,YAAY;AAC5B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,eAAe;AAC9B,gBAAgB,YAAY;AAC5B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,eAAe;AAC9B,eAAe,OAAO;AACtB;AACA,eAAe,QAAQ;AACvB;AACA;AACA,gBAAgB,YAAY;AAC5B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,eAAe;AAC9B,eAAe,OAAO;AACtB;AACA,eAAe,QAAQ;AACvB;AACA;AACA,gBAAgB,YAAY;AAC5B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,eAAe;AAC9B,eAAe,OAAO;AACtB;AACA,eAAe,QAAQ;AACvB;AACA;AACA,gBAAgB,YAAY;AAC5B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,eAAe;AAC9B;AACA,eAAe,eAAe;AAC9B;AACA,gBAAgB,YAAY;AAC5B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,MAAM;AACrB,gBAAgB,YAAY;AAC5B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,eAAe;AAC9B,gBAAgB,YAAY;AAC5B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,eAAe,4BAA4B;AAC3C;AACA,gBAAgB,YAAY;AAC5B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA,0EAA0E,cAAc;AACxF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4BAA4B;AAC3C;AACA,gBAAgB,YAAY;AAC5B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4EAA4E,eAAe;AAC3F;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,eAAe,4BAA4B;AAC3C;AACA,gBAAgB,YAAY;AAC5B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA,4EAA4E,eAAe;AAC3F;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4BAA4B;AAC3C;AACA,gBAAgB,YAAY;AAC5B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4EAA4E,eAAe;AAC3F;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,YAAY;AAC5B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,YAAY;AAC5B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA,eAAe,wBAAwB;AACvC,gBAAgB,YAAY;AAC5B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA,4EAA4E,eAAe;AAC3F;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,wBAAwB;AACvC,gBAAgB,YAAY;AAC5B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,6EAA6E,gBAAgB;AAC7F;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,+BAA+B;AAC/C;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;;AAEP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,uEAAuE;AACvE;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA,gBAAgB,YAAY;AAC5B;;AAEA,GAAG;AACH;;AAEA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,YAAY;AAC5B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,gFAAgF,gBAAgB;AAChG;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA,gBAAgB,YAAY;AAC5B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA,gFAAgF,gBAAgB;AAChG;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,0EAA0E;AAC1E;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA,gBAAgB,YAAY;AAC5B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA,gFAAgF,gBAAgB;AAChG;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,2B;;;;;;;;;;;;ACzsEa;;AAEb,6BAA6B,mBAAO,CAAC,oHAA8C;;AAEnF;AACA;AACA,CAAC;AACD;;AAEA,8CAA8C,mBAAO,CAAC,sGAAuC;;AAE7F,2CAA2C,mBAAO,CAAC,gGAAoC;;AAEvF,8CAA8C,mBAAO,CAAC,sGAAuC;;AAE7F,eAAe,mBAAO,CAAC,8DAAW;;AAElC,0CAA0C,mBAAO,CAAC,sEAAe;;AAEjE,yCAAyC,mBAAO,CAAC,oEAAc;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,aAAa,aAAa;AAC1B,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA,GAAG;AACH;AACA;AACA,SAAS,yCAAyC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;;AAEA;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED;AACA,2B;;;;;;;;;;;;AC5Ma;;AAEb,6BAA6B,mBAAO,CAAC,oHAA8C;;AAEnF;AACA;AACA,CAAC;AACD;;AAEA,8CAA8C,mBAAO,CAAC,sGAAuC;;AAE7F,2CAA2C,mBAAO,CAAC,gGAAoC;;AAEvF,yDAAyD,mBAAO,CAAC,4HAAkD;;AAEnH,8CAA8C,mBAAO,CAAC,sGAAuC;;AAE7F,mCAAmC,mBAAO,CAAC,gFAA4B;;AAEvE,wCAAwC,mBAAO,CAAC,0FAAiC;;AAEjF,uCAAuC,mBAAO,CAAC,gEAAY;;AAE3D,yCAAyC,mBAAO,CAAC,oEAAc;;AAE/D,2CAA2C,mBAAO,CAAC,sEAAe;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,UAAU;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,eAAe,OAAO;AACtB;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED;;AAEA;AACA,2B;;;;;;;;;;;;ACjNa;;AAEb,6BAA6B,mBAAO,CAAC,oHAA8C;;AAEnF;AACA;AACA,CAAC;AACD;;AAEA,8CAA8C,mBAAO,CAAC,sGAAuC;;AAE7F,2CAA2C,mBAAO,CAAC,gGAAoC;;AAEvF,8CAA8C,mBAAO,CAAC,sGAAuC;;AAE7F,0CAA0C,mBAAO,CAAC,sEAAe;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,WAAW;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;;AAEA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,gBAAgB,aAAa;AAC7B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,gBAAgB,aAAa;AAC7B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,aAAa;AAC7B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,aAAa;AAC7B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,aAAa;AAC7B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,aAAa;AAC7B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,aAAa;AAC7B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,aAAa;AAC7B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,aAAa;AAC7B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,aAAa;AAC7B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,aAAa;AAC7B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,gBAAgB,aAAa;AAC7B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,gBAAgB,aAAa;AAC7B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,gBAAgB,aAAa;AAC7B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,gBAAgB,aAAa;AAC7B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA,0EAA0E;AAC1E;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA,2B;;;;;;;;;;;;AC9mBa;;AAEb,6BAA6B,mBAAO,CAAC,oHAA8C;;AAEnF;AACA;AACA,CAAC;AACD;;AAEA,sCAAsC,mBAAO,CAAC,sFAA+B;;AAE7E,8CAA8C,mBAAO,CAAC,sGAAuC;;AAE7F,2CAA2C,mBAAO,CAAC,gGAAoC;;AAEvF,yDAAyD,mBAAO,CAAC,4HAAkD;;AAEnH,8CAA8C,mBAAO,CAAC,sGAAuC;;AAE7F,wCAAwC,mBAAO,CAAC,0FAAiC;;AAEjF,0CAA0C,mBAAO,CAAC,sEAAe;;AAEjE,iDAAiD,mBAAO,CAAC,oFAAsB;;AAE/E,2CAA2C,mBAAO,CAAC,sEAAe;;AAElE,wCAAwC,mBAAO,CAAC,kEAAa;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qCAAqC;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe;AACf;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0DAA0D;AAC1D;;AAEA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA,2B;;;;;;;;;;;;ACpLa;;AAEb,6BAA6B,mBAAO,CAAC,oHAA8C;;AAEnF;AACA;AACA,CAAC;AACD;;AAEA,sCAAsC,mBAAO,CAAC,sFAA+B;;AAE7E,8CAA8C,mBAAO,CAAC,sGAAuC;;AAE7F,2CAA2C,mBAAO,CAAC,gGAAoC;;AAEvF,yDAAyD,mBAAO,CAAC,4HAAkD;;AAEnH,8CAA8C,mBAAO,CAAC,sGAAuC;;AAE7F,mCAAmC,mBAAO,CAAC,gFAA4B;;AAEvE,wCAAwC,mBAAO,CAAC,0FAAiC;;AAEjF,6CAA6C,mBAAO,CAAC,4EAAkB;;AAEvE,0CAA0C,mBAAO,CAAC,sEAAe;;AAEjE,iDAAiD,mBAAO,CAAC,oFAAsB;;AAE/E,yCAAyC,mBAAO,CAAC,oEAAc;;AAE/D,2CAA2C,mBAAO,CAAC,sEAAe;;AAElE,2CAA2C,mBAAO,CAAC,wEAAgB;;AAEnE,sCAAsC,mBAAO,CAAC,8DAAW;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qCAAqC;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA,SAAS,sBAAsB;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe;AACf;AACA,eAAe;AACf,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,eAAe,OAAO;AACtB,gBAAgB;AAChB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,eAAe,OAAO;AACtB,gBAAgB;AAChB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB;AAChB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,eAAe,OAAO;AACtB,gBAAgB,QAAQ;AACxB;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,QAAQ;AACxB;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA,0EAA0E,cAAc;AACxF;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA,4EAA4E,eAAe;AAC3F;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA,4EAA4E,eAAe;AAC3F;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA,4EAA4E,eAAe;AAC3F;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,eAAe,OAAO;AACtB;AACA,gBAAgB,MAAM;AACtB;;AAEA,GAAG;AACH;AACA;AACA,SAAS,oBAAoB;AAC7B;AACA,SAAS,oBAAoB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,aAAa;AAC7B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,eAAe;AACvB;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,QAAQ;AACxB;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,QAAQ;AACxB;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,eAAe,OAAO;AACtB;AACA,gBAAgB,QAAQ;AACxB;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,QAAQ;AACxB;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA,eAAe,OAAO;AACtB;AACA,iBAAiB;AACjB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,uDAAuD;;AAEvD;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,uDAAuD;AACvD;;AAEA;;AAEA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,WAAW;AACX,8DAA8D;AAC9D;AACA,aAAa;AACb,WAAW;AACX;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,yEAAyE;AACzE;;AAEA;;AAEA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA,2B;;;;;;;;;;;;ACx3Ca;;AAEb,6BAA6B,mBAAO,CAAC,oHAA8C;;AAEnF;AACA;AACA,CAAC;AACD;;AAEA,sCAAsC,mBAAO,CAAC,sFAA+B;;AAE7E,0CAA0C,mBAAO,CAAC,sEAAe;;AAEjE,yCAAyC,mBAAO,CAAC,oEAAc;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;;;AAGA;AACA;AACA;AACA,SAAS,qDAAqD;AAC9D;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,0D;;;;;;;;;;;;ACtGa;;AAEb,6BAA6B,mBAAO,CAAC,oHAA8C;;AAEnF,sCAAsC,mBAAO,CAAC,sFAA+B;;AAE7E,0CAA0C,mBAAO,CAAC,sEAAe;;AAEjE,yCAAyC,mBAAO,CAAC,oEAAc;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA,+CAA+C;AAC/C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,WAAW;AACX;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,+DAA+D;AAC/D;AACA;AACA,OAAO;AACP,KAAK;AACL,SAAS,uBAAuB;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,gC;;;;;;;;;;;;AChVa;;AAEb,8BAA8B,mBAAO,CAAC,sHAA+C;;AAErF;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mDAAmD,mBAAO,CAAC,wFAAwB;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK,WAAW;AAChB;AACA,KAAK,WAAW;AAChB;AACA;AACA,C;;;;;;;;;;;;AC7Oa;;AAEb,6BAA6B,mBAAO,CAAC,oHAA8C;;AAEnF,0CAA0C,mBAAO,CAAC,sEAAe;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,0CAA0C,mBAAO,CAAC,kGAA6B,G;;;;;;;;;;;;ACxIlE;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,YAAY;AACjB;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,mC;;;;;;;;;;;;AC1CA;AACA;AACA;AACA,EAAE;AACW;;AAEb,6BAA6B,mBAAO,CAAC,oHAA8C;;AAEnF,8CAA8C,mBAAO,CAAC,sGAAuC;;AAE7F,2CAA2C,mBAAO,CAAC,gGAAoC;;AAEvF,8CAA8C,mBAAO,CAAC,sGAAuC;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA,SAAS;AACT;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED,2B;;;;;;;;;;;;AC9Fa;;AAEb,6BAA6B,mBAAO,CAAC,oHAA8C;;AAEnF,8BAA8B,mBAAO,CAAC,sHAA+C;;AAErF;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mDAAmD,mBAAO,CAAC,wFAAwB;;AAEnF,wCAAwC,mBAAO,CAAC,kEAAa;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB;AACpB,qBAAqB;AACrB,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,oCAAoC;AACzD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,C;;;;;;;;;;;;AC5Pa;;AAEb,6BAA6B,mBAAO,CAAC,oHAA8C;;AAEnF;AACA;AACA,CAAC;AACD;;AAEA,0CAA0C,mBAAO,CAAC,sEAAe;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;;AAEA;AACA,C;;;;;;;;;;;;ACxCa;;AAEb,6BAA6B,mBAAO,CAAC,oHAA8C;;AAEnF;AACA;AACA,CAAC;AACD;;AAEA,sCAAsC,mBAAO,CAAC,sFAA+B;;AAE7E,wCAAwC,mBAAO,CAAC,kEAAa;;AAE7D,0CAA0C,mBAAO,CAAC,sEAAe;;AAEjE,4CAA4C,mBAAO,CAAC,0EAAiB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,C;;;;;;;;;;;;AC5Fa;;AAEb,6BAA6B,mBAAO,CAAC,oHAA8C;;AAEnF;AACA;AACA,CAAC;AACD;;AAEA,sCAAsC,mBAAO,CAAC,sFAA+B;;AAE7E,uCAAuC,mBAAO,CAAC,gEAAY;;AAE3D,wCAAwC,mBAAO,CAAC,kEAAa;;AAE7D,4CAA4C,mBAAO,CAAC,0EAAiB;;AAErE,2CAA2C,mBAAO,CAAC,wEAAgB;;AAEnE,0CAA0C,mBAAO,CAAC,sEAAe;;AAEjE,eAAe,mBAAO,CAAC,8DAAW;;AAElC,4CAA4C,mBAAO,CAAC,0EAAiB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,C;;;;;;;;;;;;ACnGa;;AAEb,6BAA6B,mBAAO,CAAC,oHAA8C;;AAEnF;AACA;AACA,CAAC;AACD;;AAEA,sCAAsC,mBAAO,CAAC,sFAA+B;;AAE7E,uCAAuC,mBAAO,CAAC,gEAAY;;AAE3D,wCAAwC,mBAAO,CAAC,kEAAa;;AAE7D,4CAA4C,mBAAO,CAAC,0EAAiB;;AAErE,2CAA2C,mBAAO,CAAC,wEAAgB;;AAEnE,0CAA0C,mBAAO,CAAC,sEAAe;;AAEjE,eAAe,mBAAO,CAAC,8DAAW;;AAElC,4CAA4C,mBAAO,CAAC,0EAAiB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC5Ha;;AAEb,6BAA6B,mBAAO,CAAC,oHAA8C;;AAEnF;AACA;AACA,CAAC;AACD;;AAEA,sCAAsC,mBAAO,CAAC,sFAA+B;;AAE7E,uCAAuC,mBAAO,CAAC,gEAAY;;AAE3D,wCAAwC,mBAAO,CAAC,kEAAa;;AAE7D,4CAA4C,mBAAO,CAAC,0EAAiB;;AAErE,0CAA0C,mBAAO,CAAC,sEAAe;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,0BAA0B,KAAK;AAC/B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,C;;;;;;;;;;;;ACrFa;;AAEb;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb,YAAY;AACZ,YAAY;AACZ,cAAc;AACd,eAAe;AACf,cAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,C;;;;;;;;;;;;AClCa;;AAEb;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACvBa;;AAEb;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mCAAmC,IAAI,SAAS,IAAI,SAAS,IAAI,mBAAmB,IAAI,SAAS,IAAI,SAAS,IAAI;AAClH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACrCa;;AAEb;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;;AAEA,iBAAiB,oBAAoB;AACrC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,C;;;;;;;;;;;;ACxFa;;AAEb,6BAA6B,mBAAO,CAAC,oHAA8C;;AAEnF;AACA;AACA,CAAC;AACD;;AAEA,kDAAkD,mBAAO,CAAC,sFAAuB;;AAEjF,0CAA0C,mBAAO,CAAC,sEAAe;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,C;;;;;;;;;;;;AC5Ca;;AAEb,6BAA6B,mBAAO,CAAC,oHAA8C;;AAEnF;AACA;AACA,CAAC;AACD;;AAEA,sCAAsC,mBAAO,CAAC,sFAA+B;;AAE7E,wCAAwC,mBAAO,CAAC,kEAAa;;AAE7D,0CAA0C,mBAAO,CAAC,sEAAe;;AAEjE,4CAA4C,mBAAO,CAAC,0EAAiB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;AC1HA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACvBA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC;;AAEjC;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,QAAQ;AAC9B;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;ACjCA,UAAU,mBAAO,CAAC,yDAAW;AAC7B,kBAAkB,mBAAO,CAAC,iEAAmB;;AAE7C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;;AAEA;AACA;;AAEA","file":"default~account-account-module~birthday-birthday-module~forgot-pass-forgot-pass-module~gender-gender~1ebe6abf.js","sourcesContent":["function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nmodule.exports = _arrayWithHoles;","function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nmodule.exports = _arrayWithoutHoles;","function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nmodule.exports = _assertThisInitialized;","function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nmodule.exports = _asyncToGenerator;","function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nmodule.exports = _classCallCheck;","var setPrototypeOf = require(\"./setPrototypeOf\");\n\nfunction isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _construct(Parent, args, Class) {\n  if (isNativeReflectConstruct()) {\n    module.exports = _construct = Reflect.construct;\n  } else {\n    module.exports = _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nmodule.exports = _construct;","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nmodule.exports = _createClass;","function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty;","var getPrototypeOf = require(\"./getPrototypeOf\");\n\nvar superPropBase = require(\"./superPropBase\");\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    module.exports = _get = Reflect.get;\n  } else {\n    module.exports = _get = function _get(target, property, receiver) {\n      var base = superPropBase(target, property);\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nmodule.exports = _get;","function _getPrototypeOf(o) {\n  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nmodule.exports = _getPrototypeOf;","var setPrototypeOf = require(\"./setPrototypeOf\");\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}\n\nmodule.exports = _inherits;","function _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nmodule.exports = _interopRequireDefault;","function _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj[\"default\"] = obj;\n    return newObj;\n  }\n}\n\nmodule.exports = _interopRequireWildcard;","function _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\n\nmodule.exports = _isNativeFunction;","function _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nmodule.exports = _iterableToArray;","function _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nmodule.exports = _iterableToArrayLimit;","function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nmodule.exports = _nonIterableRest;","function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nmodule.exports = _nonIterableSpread;","var _typeof = require(\"../helpers/typeof\");\n\nvar assertThisInitialized = require(\"./assertThisInitialized\");\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return assertThisInitialized(self);\n}\n\nmodule.exports = _possibleConstructorReturn;","function _setPrototypeOf(o, p) {\n  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nmodule.exports = _setPrototypeOf;","var arrayWithHoles = require(\"./arrayWithHoles\");\n\nvar iterableToArrayLimit = require(\"./iterableToArrayLimit\");\n\nvar nonIterableRest = require(\"./nonIterableRest\");\n\nfunction _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();\n}\n\nmodule.exports = _slicedToArray;","var getPrototypeOf = require(\"./getPrototypeOf\");\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nmodule.exports = _superPropBase;","var arrayWithoutHoles = require(\"./arrayWithoutHoles\");\n\nvar iterableToArray = require(\"./iterableToArray\");\n\nvar nonIterableSpread = require(\"./nonIterableSpread\");\n\nfunction _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();\n}\n\nmodule.exports = _toConsumableArray;","function _typeof2(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof2(obj); }\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\") {\n    module.exports = _typeof = function _typeof(obj) {\n      return _typeof2(obj);\n    };\n  } else {\n    module.exports = _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n    };\n  }\n\n  return _typeof(obj);\n}\n\nmodule.exports = _typeof;","var getPrototypeOf = require(\"./getPrototypeOf\");\n\nvar setPrototypeOf = require(\"./setPrototypeOf\");\n\nvar isNativeFunction = require(\"./isNativeFunction\");\n\nvar construct = require(\"./construct\");\n\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  module.exports = _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return construct(Class, arguments, getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}\n\nmodule.exports = _wrapNativeSuper;","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n","module.exports = require(\"regenerator-runtime\");\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction $getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return $getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = $getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  var args = [];\n  for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    ReflectApply(this.listener, this.target, args);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      if (typeof listener !== 'function') {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n      }\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      if (typeof listener !== 'function') {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n      }\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n","module.exports = require('./lib/browser/Parse.js');\n","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.track = track;\n\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n/**\n * Parse.Analytics provides an interface to Parse's logging and analytics\n * backend.\n *\n * @class Parse.Analytics\n * @static\n * @hideconstructor\n */\n\n/**\n  * Tracks the occurrence of a custom event with additional dimensions.\n  * Parse will store a data point at the time of invocation with the given\n  * event name.\n  *\n  * Dimensions will allow segmentation of the occurrences of this custom\n  * event. Keys and values should be {@code String}s, and will throw\n  * otherwise.\n  *\n  * To track a user signup along with additional metadata, consider the\n  * following:\n  * <pre>\n  * var dimensions = {\n  *  gender: 'm',\n  *  source: 'web',\n  *  dayType: 'weekend'\n  * };\n  * Parse.Analytics.track('signup', dimensions);\n  * </pre>\n  *\n  * There is a default limit of 8 dimensions per event tracked.\n  *\n  * @method track\n  * @name Parse.Analytics.track\n  * @param {String} name The name of the custom event to report to Parse as\n  * having happened.\n  * @param {Object} dimensions The dictionary of information by which to\n  * segment this event.\n  * @return {Promise} A promise that is resolved when the round-trip\n  * to the server completes.\n  */\n\n\nfunction track(name\n/*: string*/\n, dimensions\n/*: { [key: string]: string }*/\n)\n/*: Promise*/\n{\n  name = name || '';\n  name = name.replace(/^\\s*/, '');\n  name = name.replace(/\\s*$/, '');\n\n  if (name.length === 0) {\n    throw new TypeError('A name for the custom event must be provided');\n  }\n\n  for (var _key in dimensions) {\n    if (typeof _key !== 'string' || typeof dimensions[_key] !== 'string') {\n      throw new TypeError('track() dimensions expects keys and values of type \"string\".');\n    }\n  }\n\n  return _CoreManager.default.getAnalyticsController().track(name, dimensions);\n}\n\nvar DefaultController = {\n  track: function (name, dimensions) {\n    var RESTController = _CoreManager.default.getRESTController();\n\n    return RESTController.request('POST', 'events/' + name, {\n      dimensions: dimensions\n    });\n  }\n};\n\n_CoreManager.default.setAnalyticsController(DefaultController);","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _ParseUser = _interopRequireDefault(require(\"./ParseUser\"));\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow-weak\n */\n\n\nvar uuidv4 = require('uuid/v4');\n\nvar registered = false;\n/**\n * Provides utility functions for working with Anonymously logged-in users. <br />\n * Anonymous users have some unique characteristics:\n * <ul>\n *  <li>Anonymous users don't need a user name or password.</li>\n *  <ul>\n *    <li>Once logged out, an anonymous user cannot be recovered.</li>\n *  </ul>\n *  <li>signUp converts an anonymous user to a standard user with the given username and password.</li>\n *  <ul>\n *    <li>Data associated with the anonymous user is retained.</li>\n *  </ul>\n *  <li>logIn switches users without converting the anonymous user.</li>\n *  <ul>\n *    <li>Data associated with the anonymous user will be lost.</li>\n *  </ul>\n *  <li>Service logIn (e.g. Facebook, Twitter) will attempt to convert\n *  the anonymous user into a standard user by linking it to the service.</li>\n *  <ul>\n *    <li>If a user already exists that is linked to the service, it will instead switch to the existing user.</li>\n *  </ul>\n *  <li>Service linking (e.g. Facebook, Twitter) will convert the anonymous user\n *  into a standard user by linking it to the service.</li>\n * </ul>\n * @class Parse.AnonymousUtils\n * @static\n */\n\nvar AnonymousUtils = {\n  /**\n   * Gets whether the user has their account linked to anonymous user.\n   *\n   * @method isLinked\n   * @name Parse.AnonymousUtils.isLinked\n   * @param {Parse.User} user User to check for.\n   *     The user must be logged in on this device.\n   * @return {Boolean} <code>true</code> if the user has their account\n   *     linked to an anonymous user.\n   * @static\n   */\n  isLinked: function (user\n  /*: ParseUser*/\n  ) {\n    var provider = this._getAuthProvider();\n\n    return user._isLinked(provider.getAuthType());\n  },\n\n  /**\n   * Logs in a user Anonymously.\n   *\n   * @method logIn\n   * @name Parse.AnonymousUtils.logIn\n   * @returns {Promise}\n   * @static\n   */\n  logIn: function () {\n    var provider = this._getAuthProvider();\n\n    return _ParseUser.default._logInWith(provider.getAuthType(), provider.getAuthData());\n  },\n\n  /**\n   * Links Anonymous User to an existing PFUser.\n   *\n   * @method link\n   * @name Parse.AnonymousUtils.link\n   * @param {Parse.User} user User to link. This must be the current user.\n   * @returns {Promise}\n   * @static\n   */\n  link: function (user\n  /*: ParseUser*/\n  ) {\n    var provider = this._getAuthProvider();\n\n    return user._linkWith(provider.getAuthType(), provider.getAuthData());\n  },\n  _getAuthProvider: function () {\n    var provider = {\n      restoreAuthentication: function () {\n        return true;\n      },\n      getAuthType: function () {\n        return 'anonymous';\n      },\n      getAuthData: function () {\n        return {\n          authData: {\n            id: uuidv4()\n          }\n        };\n      }\n    };\n\n    if (!registered) {\n      _ParseUser.default._registerAuthenticationProvider(provider);\n\n      registered = true;\n    }\n\n    return provider;\n  }\n};\nvar _default = AnonymousUtils;\nexports.default = _default;","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.run = run;\nexports.getJobsData = getJobsData;\nexports.startJob = startJob;\nexports.getJobStatus = getJobStatus;\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\n\nvar _decode = _interopRequireDefault(require(\"./decode\"));\n\nvar _encode = _interopRequireDefault(require(\"./encode\"));\n\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\n\nvar _ParseQuery = _interopRequireDefault(require(\"./ParseQuery\"));\n\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n/**\n * Contains functions for calling and declaring\n * <a href=\"/docs/cloud_code_guide#functions\">cloud functions</a>.\n * <p><strong><em>\n *   Some functions are only available from Cloud Code.\n * </em></strong></p>\n *\n * @class Parse.Cloud\n * @static\n * @hideconstructor\n */\n\n/**\n  * Makes a call to a cloud function.\n  * @method run\n  * @name Parse.Cloud.run\n  * @param {String} name The function name.\n  * @param {Object} data The parameters to send to the cloud function.\n  * @param {Object} options\n  * @return {Promise} A promise that will be resolved with the result\n  * of the function.\n  */\n\n\nfunction run(name\n/*: string*/\n, data\n/*: mixed*/\n, options\n/*: RequestOptions*/\n)\n/*: Promise<mixed>*/\n{\n  options = options || {};\n\n  if (typeof name !== 'string' || name.length === 0) {\n    throw new TypeError('Cloud function name must be a string.');\n  }\n\n  var requestOptions = {};\n\n  if (options.useMasterKey) {\n    requestOptions.useMasterKey = options.useMasterKey;\n  }\n\n  if (options.sessionToken) {\n    requestOptions.sessionToken = options.sessionToken;\n  }\n\n  return _CoreManager.default.getCloudController().run(name, data, requestOptions);\n}\n/**\n  * Gets data for the current set of cloud jobs.\n  * @method getJobsData\n  * @name Parse.Cloud.getJobsData\n  * @return {Promise} A promise that will be resolved with the result\n  * of the function.\n  */\n\n\nfunction getJobsData()\n/*: Promise<Object>*/\n{\n  return _CoreManager.default.getCloudController().getJobsData({\n    useMasterKey: true\n  });\n}\n/**\n  * Starts a given cloud job, which will process asynchronously.\n  * @method startJob\n  * @name Parse.Cloud.startJob\n  * @param {String} name The function name.\n  * @param {Object} data The parameters to send to the cloud function.\n  * @return {Promise} A promise that will be resolved with the jobStatusId\n  * of the job.\n  */\n\n\nfunction startJob(name\n/*: string*/\n, data\n/*: mixed*/\n)\n/*: Promise<string>*/\n{\n  if (typeof name !== 'string' || name.length === 0) {\n    throw new TypeError('Cloud job name must be a string.');\n  }\n\n  return _CoreManager.default.getCloudController().startJob(name, data, {\n    useMasterKey: true\n  });\n}\n/**\n  * Gets job status by Id\n  * @method getJobStatus\n  * @name Parse.Cloud.getJobStatus\n  * @param {String} jobStatusId The Id of Job Status.\n  * @return {Parse.Object} Status of Job.\n  */\n\n\nfunction getJobStatus(jobStatusId\n/*: string*/\n)\n/*: Promise<ParseObject>*/\n{\n  var query = new _ParseQuery.default('_JobStatus');\n  return query.get(jobStatusId, {\n    useMasterKey: true\n  });\n}\n\nvar DefaultController = {\n  run: function (name, data, options\n  /*: RequestOptions*/\n  ) {\n    var RESTController = _CoreManager.default.getRESTController();\n\n    var payload = (0, _encode.default)(data, true);\n    var request = RESTController.request('POST', 'functions/' + name, payload, options);\n    return request.then(function (res) {\n      if ((0, _typeof2.default)(res) === 'object' && Object.keys(res).length > 0 && !res.hasOwnProperty('result')) {\n        throw new _ParseError.default(_ParseError.default.INVALID_JSON, 'The server returned an invalid response.');\n      }\n\n      var decoded = (0, _decode.default)(res);\n\n      if (decoded && decoded.hasOwnProperty('result')) {\n        return Promise.resolve(decoded.result);\n      }\n\n      return Promise.resolve(undefined);\n    });\n  },\n  getJobsData: function (options\n  /*: RequestOptions*/\n  ) {\n    var RESTController = _CoreManager.default.getRESTController();\n\n    return RESTController.request('GET', 'cloud_code/jobs/data', null, options);\n  },\n  startJob: function (name, data, options\n  /*: RequestOptions*/\n  ) {\n    var RESTController = _CoreManager.default.getRESTController();\n\n    var payload = (0, _encode.default)(data, true);\n    return RESTController.request('POST', 'jobs/' + name, payload, options);\n  }\n};\n\n_CoreManager.default.setCloudController(DefaultController);","/*:: import type { AttributeMap, ObjectCache, OpsMap, State } from './ObjectStateMutations';*/\n\n/*:: import type ParseFile from './ParseFile';*/\n\n/*:: import type { FileSource } from './ParseFile';*/\n\n/*:: import type { Op } from './ParseOp';*/\n\n/*:: import type ParseObject from './ParseObject';*/\n\n/*:: import type { QueryJSON } from './ParseQuery';*/\n\n/*:: import type ParseUser from './ParseUser';*/\n\n/*:: import type { AuthData } from './ParseUser';*/\n\n/*:: import type { PushData } from './Push';*/\n\n/*:: import type { RequestOptions, FullOptions } from './RESTController';*/\n\n/*:: type AnalyticsController = {\n  track: (name: string, dimensions: { [key: string]: string }) => Promise;\n};*/\n\n/*:: type CloudController = {\n  run: (name: string, data: mixed, options: RequestOptions) => Promise;\n  getJobsData: (options: RequestOptions) => Promise;\n  startJob: (name: string, data: mixed, options: RequestOptions) => Promise;\n};*/\n\n/*:: type ConfigController = {\n  current: () => Promise;\n  get: () => Promise;\n  save: (attrs: { [key: string]: any }) => Promise;\n};*/\n\n/*:: type FileController = {\n  saveFile: (name: string, source: FileSource, options: FullOptions) => Promise;\n  saveBase64: (name: string, source: FileSource, options: FullOptions) => Promise;\n  download: (uri: string) => Promise;\n};*/\n\n/*:: type InstallationController = {\n  currentInstallationId: () => Promise;\n};*/\n\n/*:: type ObjectController = {\n  fetch: (object: ParseObject | Array<ParseObject>, forceFetch: boolean, options: RequestOptions) => Promise;\n  save: (object: ParseObject | Array<ParseObject | ParseFile>, options: RequestOptions) => Promise;\n  destroy: (object: ParseObject | Array<ParseObject>, options: RequestOptions) => Promise;\n};*/\n\n/*:: type ObjectStateController = {\n  getState: (obj: any) => ?State;\n  initializeState: (obj: any, initial?: State) => State;\n  removeState: (obj: any) => ?State;\n  getServerData: (obj: any) => AttributeMap;\n  setServerData: (obj: any, attributes: AttributeMap) => void;\n  getPendingOps: (obj: any) => Array<OpsMap>;\n  setPendingOp: (obj: any, attr: string, op: ?Op) => void;\n  pushPendingState: (obj: any) => void;\n  popPendingState: (obj: any) => OpsMap;\n  mergeFirstPendingState: (obj: any) => void;\n  getObjectCache: (obj: any) => ObjectCache;\n  estimateAttribute: (obj: any, attr: string) => mixed;\n  estimateAttributes: (obj: any) => AttributeMap;\n  commitServerChanges: (obj: any, changes: AttributeMap) => void;\n  enqueueTask: (obj: any, task: () => Promise) => Promise;\n  clearAllState: () => void;\n  duplicateState: (source: any, dest: any) => void;\n};*/\n\n/*:: type PushController = {\n  send: (data: PushData, options: RequestOptions) => Promise;\n};*/\n\n/*:: type QueryController = {\n  find: (className: string, params: QueryJSON, options: RequestOptions) => Promise;\n  aggregate: (className: string, params: any, options: RequestOptions) => Promise;\n};*/\n\n/*:: type RESTController = {\n  request: (method: string, path: string, data: mixed, options: RequestOptions) => Promise;\n  ajax: (method: string, url: string, data: any, headers?: any, options: FullOptions) => Promise;\n};*/\n\n/*:: type SchemaController = {\n  purge: (className: string) => Promise;\n  get: (className: string, options: RequestOptions) => Promise;\n  delete: (className: string, options: RequestOptions) => Promise;\n  create: (className: string, params: any, options: RequestOptions) => Promise;\n  update: (className: string, params: any, options: RequestOptions) => Promise;\n  send(className: string, method: string, params: any, options: RequestOptions): Promise;\n};*/\n\n/*:: type SessionController = {\n  getSession: (token: RequestOptions) => Promise;\n};*/\n\n/*:: type StorageController = {\n  async: 0;\n  getItem: (path: string) => ?string;\n  setItem: (path: string, value: string) => void;\n  removeItem: (path: string) => void;\n  getItemAsync?: (path: string) => Promise;\n  setItemAsync?: (path: string, value: string) => Promise;\n  removeItemAsync?: (path: string) => Promise;\n  clear: () => void;\n} | {\n  async: 1;\n  getItem?: (path: string) => ?string;\n  setItem?: (path: string, value: string) => void;\n  removeItem?: (path: string) => void;\n  getItemAsync: (path: string) => Promise;\n  setItemAsync: (path: string, value: string) => Promise;\n  removeItemAsync: (path: string) => Promise;\n  clear: () => void;\n};*/\n\n/*:: type LocalDatastoreController = {\n  fromPinWithName: (name: string) => ?any;\n  pinWithName: (name: string, objects: any) => void;\n  unPinWithName: (name: string) => void;\n  getAllContents: () => ?any;\n  clear: () => void;\n};*/\n\n/*:: type UserController = {\n  setCurrentUser: (user: ParseUser) => Promise;\n  currentUser: () => ?ParseUser;\n  currentUserAsync: () => Promise;\n  signUp: (user: ParseUser, attrs: AttributeMap, options: RequestOptions) => Promise;\n  logIn: (user: ParseUser, options: RequestOptions) => Promise;\n  become: (options: RequestOptions) => Promise;\n  hydrate: (userJSON: AttributeMap) => Promise;\n  logOut: () => Promise;\n  requestPasswordReset: (email: string, options: RequestOptions) => Promise;\n  updateUserOnDisk: (user: ParseUser) => Promise;\n  upgradeToRevocableSession: (user: ParseUser, options: RequestOptions) => Promise;\n  linkWith: (user: ParseUser, authData: AuthData) => Promise;\n  removeUserFromDisk: () => Promise;\n};*/\n\n/*:: type HooksController = {\n  get: (type: string, functionName?: string, triggerName?: string) => Promise;\n  create: (hook: mixed) => Promise;\n  delete: (hook: mixed) => Promise;\n  update: (hook: mixed) => Promise;\n  send: (method: string, path: string, body?: mixed) => Promise;\n};*/\n\n/*:: type Config = {\n  AnalyticsController?: AnalyticsController,\n  CloudController?: CloudController,\n  ConfigController?: ConfigController,\n  FileController?: FileController,\n  InstallationController?: InstallationController,\n  ObjectController?: ObjectController,\n  ObjectStateController?: ObjectStateController,\n  PushController?: PushController,\n  QueryController?: QueryController,\n  RESTController?: RESTController,\n  SchemaController?: SchemaController,\n  SessionController?: SessionController,\n  StorageController?: StorageController,\n  LocalDatastoreController?: LocalDatastoreController,\n  UserController?: UserController,\n  HooksController?: HooksController,\n};*/\n\"use strict\";\n/*\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\nvar config\n/*: Config & { [key: string]: mixed }*/\n= {\n  // Defaults\n  IS_NODE: typeof process !== 'undefined' && !!process.versions && !!process.versions.node && !process.versions.electron,\n  REQUEST_ATTEMPT_LIMIT: 5,\n  SERVER_URL: 'https://api.parse.com/1',\n  SERVER_AUTH_TYPE: null,\n  SERVER_AUTH_TOKEN: null,\n  LIVEQUERY_SERVER_URL: null,\n  VERSION: 'js' + \"2.4.0\",\n  APPLICATION_ID: null,\n  JAVASCRIPT_KEY: null,\n  MASTER_KEY: null,\n  USE_MASTER_KEY: false,\n  PERFORM_USER_REWRITE: true,\n  FORCE_REVOCABLE_SESSION: false\n};\n\nfunction requireMethods(name\n/*: string*/\n, methods\n/*: Array<string>*/\n, controller\n/*: any*/\n) {\n  methods.forEach(function (func) {\n    if (typeof controller[func] !== 'function') {\n      throw new Error(\"\".concat(name, \" must implement \").concat(func, \"()\"));\n    }\n  });\n}\n\nmodule.exports = {\n  get: function (key\n  /*: string*/\n  )\n  /*: any*/\n  {\n    if (config.hasOwnProperty(key)) {\n      return config[key];\n    }\n\n    throw new Error('Configuration key not found: ' + key);\n  },\n  set: function (key\n  /*: string*/\n  , value\n  /*: any*/\n  )\n  /*: void*/\n  {\n    config[key] = value;\n  },\n\n  /* Specialized Controller Setters/Getters */\n  setAnalyticsController: function (controller\n  /*: AnalyticsController*/\n  ) {\n    requireMethods('AnalyticsController', ['track'], controller);\n    config['AnalyticsController'] = controller;\n  },\n  getAnalyticsController: function ()\n  /*: AnalyticsController*/\n  {\n    return config['AnalyticsController'];\n  },\n  setCloudController: function (controller\n  /*: CloudController*/\n  ) {\n    requireMethods('CloudController', ['run', 'getJobsData', 'startJob'], controller);\n    config['CloudController'] = controller;\n  },\n  getCloudController: function ()\n  /*: CloudController*/\n  {\n    return config['CloudController'];\n  },\n  setConfigController: function (controller\n  /*: ConfigController*/\n  ) {\n    requireMethods('ConfigController', ['current', 'get', 'save'], controller);\n    config['ConfigController'] = controller;\n  },\n  getConfigController: function ()\n  /*: ConfigController*/\n  {\n    return config['ConfigController'];\n  },\n  setFileController: function (controller\n  /*: FileController*/\n  ) {\n    requireMethods('FileController', ['saveFile', 'saveBase64'], controller);\n    config['FileController'] = controller;\n  },\n  getFileController: function ()\n  /*: FileController*/\n  {\n    return config['FileController'];\n  },\n  setInstallationController: function (controller\n  /*: InstallationController*/\n  ) {\n    requireMethods('InstallationController', ['currentInstallationId'], controller);\n    config['InstallationController'] = controller;\n  },\n  getInstallationController: function ()\n  /*: InstallationController*/\n  {\n    return config['InstallationController'];\n  },\n  setObjectController: function (controller\n  /*: ObjectController*/\n  ) {\n    requireMethods('ObjectController', ['save', 'fetch', 'destroy'], controller);\n    config['ObjectController'] = controller;\n  },\n  getObjectController: function ()\n  /*: ObjectController*/\n  {\n    return config['ObjectController'];\n  },\n  setObjectStateController: function (controller\n  /*: ObjectStateController*/\n  ) {\n    requireMethods('ObjectStateController', ['getState', 'initializeState', 'removeState', 'getServerData', 'setServerData', 'getPendingOps', 'setPendingOp', 'pushPendingState', 'popPendingState', 'mergeFirstPendingState', 'getObjectCache', 'estimateAttribute', 'estimateAttributes', 'commitServerChanges', 'enqueueTask', 'clearAllState'], controller);\n    config['ObjectStateController'] = controller;\n  },\n  getObjectStateController: function ()\n  /*: ObjectStateController*/\n  {\n    return config['ObjectStateController'];\n  },\n  setPushController: function (controller\n  /*: PushController*/\n  ) {\n    requireMethods('PushController', ['send'], controller);\n    config['PushController'] = controller;\n  },\n  getPushController: function ()\n  /*: PushController*/\n  {\n    return config['PushController'];\n  },\n  setQueryController: function (controller\n  /*: QueryController*/\n  ) {\n    requireMethods('QueryController', ['find', 'aggregate'], controller);\n    config['QueryController'] = controller;\n  },\n  getQueryController: function ()\n  /*: QueryController*/\n  {\n    return config['QueryController'];\n  },\n  setRESTController: function (controller\n  /*: RESTController*/\n  ) {\n    requireMethods('RESTController', ['request', 'ajax'], controller);\n    config['RESTController'] = controller;\n  },\n  getRESTController: function ()\n  /*: RESTController*/\n  {\n    return config['RESTController'];\n  },\n  setSchemaController: function (controller\n  /*: SchemaController*/\n  ) {\n    requireMethods('SchemaController', ['get', 'create', 'update', 'delete', 'send', 'purge'], controller);\n    config['SchemaController'] = controller;\n  },\n  getSchemaController: function ()\n  /*: SchemaController*/\n  {\n    return config['SchemaController'];\n  },\n  setSessionController: function (controller\n  /*: SessionController*/\n  ) {\n    requireMethods('SessionController', ['getSession'], controller);\n    config['SessionController'] = controller;\n  },\n  getSessionController: function ()\n  /*: SessionController*/\n  {\n    return config['SessionController'];\n  },\n  setStorageController: function (controller\n  /*: StorageController*/\n  ) {\n    if (controller.async) {\n      requireMethods('An async StorageController', ['getItemAsync', 'setItemAsync', 'removeItemAsync'], controller);\n    } else {\n      requireMethods('A synchronous StorageController', ['getItem', 'setItem', 'removeItem'], controller);\n    }\n\n    config['StorageController'] = controller;\n  },\n  setLocalDatastoreController: function (controller\n  /*: LocalDatastoreController*/\n  ) {\n    requireMethods('LocalDatastoreController', ['pinWithName', 'fromPinWithName', 'unPinWithName', 'getAllContents', 'clear'], controller);\n    config['LocalDatastoreController'] = controller;\n  },\n  getLocalDatastoreController: function ()\n  /*: LocalDatastoreController*/\n  {\n    return config['LocalDatastoreController'];\n  },\n  setLocalDatastore: function (store\n  /*: any*/\n  ) {\n    config['LocalDatastore'] = store;\n  },\n  getLocalDatastore: function () {\n    return config['LocalDatastore'];\n  },\n  getStorageController: function ()\n  /*: StorageController*/\n  {\n    return config['StorageController'];\n  },\n  setAsyncStorage: function (storage\n  /*: any*/\n  ) {\n    config['AsyncStorage'] = storage;\n  },\n  getAsyncStorage: function () {\n    return config['AsyncStorage'];\n  },\n  setUserController: function (controller\n  /*: UserController*/\n  ) {\n    requireMethods('UserController', ['setCurrentUser', 'currentUser', 'currentUserAsync', 'signUp', 'logIn', 'become', 'logOut', 'requestPasswordReset', 'upgradeToRevocableSession', 'linkWith'], controller);\n    config['UserController'] = controller;\n  },\n  getUserController: function ()\n  /*: UserController*/\n  {\n    return config['UserController'];\n  },\n  setLiveQueryController: function (controller\n  /*: any*/\n  ) {\n    requireMethods('LiveQueryController', ['setDefaultLiveQueryClient', 'getDefaultLiveQueryClient', '_clearCachedDefaultClient'], controller);\n    config['LiveQueryController'] = controller;\n  },\n  getLiveQueryController: function ()\n  /*: any*/\n  {\n    return config['LiveQueryController'];\n  },\n  setHooksController: function (controller\n  /*: HooksController*/\n  ) {\n    requireMethods('HooksController', ['create', 'get', 'update', 'remove'], controller);\n    config['HooksController'] = controller;\n  },\n  getHooksController: function ()\n  /*: HooksController*/\n  {\n    return config['HooksController'];\n  }\n};","\"use strict\";\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * This is a simple wrapper to unify EventEmitter implementations across platforms.\n */\n\nmodule.exports = require('events').EventEmitter;\nvar EventEmitter;","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _ParseUser = _interopRequireDefault(require(\"./ParseUser\"));\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow-weak\n */\n\n/* global FB */\n\n\nvar initialized = false;\nvar requestedPermissions;\nvar initOptions;\nvar provider = {\n  authenticate: function (options) {\n    var _this = this;\n\n    if (typeof FB === 'undefined') {\n      options.error(this, 'Facebook SDK not found.');\n    }\n\n    FB.login(function (response) {\n      if (response.authResponse) {\n        if (options.success) {\n          options.success(_this, {\n            id: response.authResponse.userID,\n            access_token: response.authResponse.accessToken,\n            expiration_date: new Date(response.authResponse.expiresIn * 1000 + new Date().getTime()).toJSON()\n          });\n        }\n      } else {\n        if (options.error) {\n          options.error(_this, response);\n        }\n      }\n    }, {\n      scope: requestedPermissions\n    });\n  },\n  restoreAuthentication: function (authData) {\n    if (authData) {\n      var newOptions = {};\n\n      if (initOptions) {\n        for (var key in initOptions) {\n          newOptions[key] = initOptions[key];\n        }\n      } // Suppress checks for login status from the browser.\n\n\n      newOptions.status = false; // If the user doesn't match the one known by the FB SDK, log out.\n      // Most of the time, the users will match -- it's only in cases where\n      // the FB SDK knows of a different user than the one being restored\n      // from a Parse User that logged in with username/password.\n\n      var existingResponse = FB.getAuthResponse();\n\n      if (existingResponse && existingResponse.userID !== authData.id) {\n        FB.logout();\n      }\n\n      FB.init(newOptions);\n    }\n\n    return true;\n  },\n  getAuthType: function () {\n    return 'facebook';\n  },\n  deauthenticate: function () {\n    this.restoreAuthentication(null);\n  }\n};\n/**\n * Provides a set of utilities for using Parse with Facebook.\n * @class Parse.FacebookUtils\n * @static\n * @hideconstructor\n */\n\nvar FacebookUtils = {\n  /**\n   * Initializes Parse Facebook integration.  Call this function after you\n   * have loaded the Facebook Javascript SDK with the same parameters\n   * as you would pass to<code>\n   * <a href=\n   * \"https://developers.facebook.com/docs/reference/javascript/FB.init/\">\n   * FB.init()</a></code>.  Parse.FacebookUtils will invoke FB.init() for you\n   * with these arguments.\n   *\n   * @method init\n   * @name Parse.FacebookUtils.init\n   * @param {Object} options Facebook options argument as described here:\n   *   <a href=\n   *   \"https://developers.facebook.com/docs/reference/javascript/FB.init/\">\n   *   FB.init()</a>. The status flag will be coerced to 'false' because it\n   *   interferes with Parse Facebook integration. Call FB.getLoginStatus()\n   *   explicitly if this behavior is required by your application.\n   */\n  init: function (options) {\n    if (typeof FB === 'undefined') {\n      throw new Error('The Facebook JavaScript SDK must be loaded before calling init.');\n    }\n\n    initOptions = {};\n\n    if (options) {\n      for (var key in options) {\n        initOptions[key] = options[key];\n      }\n    }\n\n    if (initOptions.status && typeof console !== 'undefined') {\n      var warn = console.warn || console.log || function () {}; // eslint-disable-line no-console\n\n\n      warn.call(console, 'The \"status\" flag passed into' + ' FB.init, when set to true, can interfere with Parse Facebook' + ' integration, so it has been suppressed. Please call' + ' FB.getLoginStatus() explicitly if you require this behavior.');\n    }\n\n    initOptions.status = false;\n    FB.init(initOptions);\n\n    _ParseUser.default._registerAuthenticationProvider(provider);\n\n    initialized = true;\n  },\n\n  /**\n   * Gets whether the user has their account linked to Facebook.\n   *\n   * @method isLinked\n   * @name Parse.FacebookUtils.isLinked\n   * @param {Parse.User} user User to check for a facebook link.\n   *     The user must be logged in on this device.\n   * @return {Boolean} <code>true</code> if the user has their account\n   *     linked to Facebook.\n   */\n  isLinked: function (user) {\n    return user._isLinked('facebook');\n  },\n\n  /**\n   * Logs in a user using Facebook. This method delegates to the Facebook\n   * SDK to authenticate the user, and then automatically logs in (or\n   * creates, in the case where it is a new user) a Parse.User.\n   *\n   * Standard API:\n   *\n   * <code>logIn(permission: string, authData: Object);</code>\n   *\n   * Advanced API: Used for handling your own oAuth tokens\n   * {@link https://docs.parseplatform.org/rest/guide/#linking-users}\n   *\n   * <code>logIn(authData: Object, options?: Object);</code>\n   *\n   * @method logIn\n   * @name Parse.FacebookUtils.logIn\n   * @param {(String|Object)} permissions The permissions required for Facebook\n   *    log in.  This is a comma-separated string of permissions.\n   *    Alternatively, supply a Facebook authData object as described in our\n   *    REST API docs if you want to handle getting facebook auth tokens\n   *    yourself.\n   * @param {Object} options MasterKey / SessionToken. Alternatively can be used for authData if permissions is a string\n   * @returns {Promise}\n   */\n  logIn: function (permissions, options) {\n    if (!permissions || typeof permissions === 'string') {\n      if (!initialized) {\n        throw new Error('You must initialize FacebookUtils before calling logIn.');\n      }\n\n      requestedPermissions = permissions;\n      return _ParseUser.default._logInWith('facebook', options);\n    }\n\n    return _ParseUser.default._logInWith('facebook', {\n      authData: permissions\n    }, options);\n  },\n\n  /**\n   * Links Facebook to an existing PFUser. This method delegates to the\n   * Facebook SDK to authenticate the user, and then automatically links\n   * the account to the Parse.User.\n   *\n   * Standard API:\n   *\n   * <code>link(user: Parse.User, permission: string, authData?: Object);</code>\n   *\n   * Advanced API: Used for handling your own oAuth tokens\n   * {@link https://docs.parseplatform.org/rest/guide/#linking-users}\n   *\n   * <code>link(user: Parse.User, authData: Object, options?: FullOptions);</code>\n   *\n   * @method link\n   * @name Parse.FacebookUtils.link\n   * @param {Parse.User} user User to link to Facebook. This must be the\n   *     current user.\n   * @param {(String|Object)} permissions The permissions required for Facebook\n   *    log in.  This is a comma-separated string of permissions.\n   *    Alternatively, supply a Facebook authData object as described in our\n   *    REST API docs if you want to handle getting facebook auth tokens\n   *    yourself.\n   * @param {Object} options MasterKey / SessionToken. Alternatively can be used for authData if permissions is a string\n   * @returns {Promise}\n   */\n  link: function (user, permissions, options) {\n    if (!permissions || typeof permissions === 'string') {\n      if (!initialized) {\n        throw new Error('You must initialize FacebookUtils before calling link.');\n      }\n\n      requestedPermissions = permissions;\n      return user._linkWith('facebook', options);\n    }\n\n    return user._linkWith('facebook', {\n      authData: permissions\n    }, options);\n  },\n\n  /**\n   * Unlinks the Parse.User from a Facebook account.\n   *\n   * @method unlink\n   * @name Parse.FacebookUtils.unlink\n   * @param {Parse.User} user User to unlink from Facebook. This must be the\n   *     current user.\n   * @param {Object} options Standard options object with success and error\n   *    callbacks.\n   * @returns {Promise}\n   */\n  unlink: function (user, options) {\n    if (!initialized) {\n      throw new Error('You must initialize FacebookUtils before calling unlink.');\n    }\n\n    return user._unlinkFrom('facebook', options);\n  },\n  // Used for testing purposes\n  _getAuthProvider: function () {\n    return provider;\n  }\n};\nvar _default = FacebookUtils;\nexports.default = _default;","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _Storage = _interopRequireDefault(require(\"./Storage\"));\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n\nvar iidCache = null;\n\nfunction hexOctet() {\n  return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n}\n\nfunction generateId() {\n  return hexOctet() + hexOctet() + '-' + hexOctet() + '-' + hexOctet() + '-' + hexOctet() + '-' + hexOctet() + hexOctet() + hexOctet();\n}\n\nvar InstallationController = {\n  currentInstallationId: function ()\n  /*: Promise<string>*/\n  {\n    if (typeof iidCache === 'string') {\n      return Promise.resolve(iidCache);\n    }\n\n    var path = _Storage.default.generatePath('installationId');\n\n    return _Storage.default.getItemAsync(path).then(function (iid) {\n      if (!iid) {\n        iid = generateId();\n        return _Storage.default.setItemAsync(path, iid).then(function () {\n          iidCache = iid;\n          return iid;\n        });\n      }\n\n      iidCache = iid;\n      return iid;\n    });\n  },\n  _clearCache: function () {\n    iidCache = null;\n  },\n  _setInstallationIdCache: function (iid\n  /*: string*/\n  ) {\n    iidCache = iid;\n  }\n};\nmodule.exports = InstallationController;","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\n\nvar _EventEmitter2 = _interopRequireDefault(require(\"./EventEmitter\"));\n\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\n\nvar _LiveQuerySubscription = _interopRequireDefault(require(\"./LiveQuerySubscription\"));\n\nvar _promiseUtils = require(\"./promiseUtils\");\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\n/* global WebSocket */\n// The LiveQuery client inner state\n\n\nvar CLIENT_STATE = {\n  INITIALIZED: 'initialized',\n  CONNECTING: 'connecting',\n  CONNECTED: 'connected',\n  CLOSED: 'closed',\n  RECONNECTING: 'reconnecting',\n  DISCONNECTED: 'disconnected'\n}; // The event type the LiveQuery client should sent to server\n\nvar OP_TYPES = {\n  CONNECT: 'connect',\n  SUBSCRIBE: 'subscribe',\n  UNSUBSCRIBE: 'unsubscribe',\n  ERROR: 'error'\n}; // The event we get back from LiveQuery server\n\nvar OP_EVENTS = {\n  CONNECTED: 'connected',\n  SUBSCRIBED: 'subscribed',\n  UNSUBSCRIBED: 'unsubscribed',\n  ERROR: 'error',\n  CREATE: 'create',\n  UPDATE: 'update',\n  ENTER: 'enter',\n  LEAVE: 'leave',\n  DELETE: 'delete'\n}; // The event the LiveQuery client should emit\n\nvar CLIENT_EMMITER_TYPES = {\n  CLOSE: 'close',\n  ERROR: 'error',\n  OPEN: 'open'\n}; // The event the LiveQuery subscription should emit\n\nvar SUBSCRIPTION_EMMITER_TYPES = {\n  OPEN: 'open',\n  CLOSE: 'close',\n  ERROR: 'error',\n  CREATE: 'create',\n  UPDATE: 'update',\n  ENTER: 'enter',\n  LEAVE: 'leave',\n  DELETE: 'delete'\n};\n\nvar generateInterval = function (k) {\n  return Math.random() * Math.min(30, Math.pow(2, k) - 1) * 1000;\n};\n/**\n * Creates a new LiveQueryClient.\n * Extends events.EventEmitter\n * <a href=\"https://nodejs.org/api/events.html#events_class_eventemitter\">cloud functions</a>.\n *\n * A wrapper of a standard WebSocket client. We add several useful methods to\n * help you connect/disconnect to LiveQueryServer, subscribe/unsubscribe a ParseQuery easily.\n *\n * javascriptKey and masterKey are used for verifying the LiveQueryClient when it tries\n * to connect to the LiveQuery server\n *\n * We expose three events to help you monitor the status of the LiveQueryClient.\n *\n * <pre>\n * let Parse = require('parse/node');\n * let LiveQueryClient = Parse.LiveQueryClient;\n * let client = new LiveQueryClient({\n *   applicationId: '',\n *   serverURL: '',\n *   javascriptKey: '',\n *   masterKey: ''\n *  });\n * </pre>\n *\n * Open - When we establish the WebSocket connection to the LiveQuery server, you'll get this event.\n * <pre>\n * client.on('open', () => {\n *\n * });</pre>\n *\n * Close - When we lose the WebSocket connection to the LiveQuery server, you'll get this event.\n * <pre>\n * client.on('close', () => {\n *\n * });</pre>\n *\n * Error - When some network error or LiveQuery server error happens, you'll get this event.\n * <pre>\n * client.on('error', (error) => {\n *\n * });</pre>\n * @alias Parse.LiveQueryClient\n */\n\n\nvar LiveQueryClient =\n/*#__PURE__*/\nfunction (_EventEmitter) {\n  (0, _inherits2.default)(LiveQueryClient, _EventEmitter);\n  /**\n   * @param {Object} options\n   * @param {string} options.applicationId - applicationId of your Parse app\n   * @param {string} options.serverURL - <b>the URL of your LiveQuery server</b>\n   * @param {string} options.javascriptKey (optional)\n   * @param {string} options.masterKey (optional) Your Parse Master Key. (Node.js only!)\n   * @param {string} options.sessionToken (optional)\n   */\n\n  function LiveQueryClient(_ref) {\n    var _this;\n\n    var applicationId = _ref.applicationId,\n        serverURL = _ref.serverURL,\n        javascriptKey = _ref.javascriptKey,\n        masterKey = _ref.masterKey,\n        sessionToken = _ref.sessionToken;\n    (0, _classCallCheck2.default)(this, LiveQueryClient);\n    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(LiveQueryClient).call(this));\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), \"attempts\", void 0);\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), \"id\", void 0);\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), \"requestId\", void 0);\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), \"applicationId\", void 0);\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), \"serverURL\", void 0);\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), \"javascriptKey\", void 0);\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), \"masterKey\", void 0);\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), \"sessionToken\", void 0);\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), \"connectPromise\", void 0);\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), \"subscriptions\", void 0);\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), \"socket\", void 0);\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), \"state\", void 0);\n\n    if (!serverURL || serverURL.indexOf('ws') !== 0) {\n      throw new Error('You need to set a proper Parse LiveQuery server url before using LiveQueryClient');\n    }\n\n    _this.reconnectHandle = null;\n    _this.attempts = 1;\n    _this.id = 0;\n    _this.requestId = 1;\n    _this.serverURL = serverURL;\n    _this.applicationId = applicationId;\n    _this.javascriptKey = javascriptKey;\n    _this.masterKey = masterKey;\n    _this.sessionToken = sessionToken;\n    _this.connectPromise = (0, _promiseUtils.resolvingPromise)();\n    _this.subscriptions = new Map();\n    _this.state = CLIENT_STATE.INITIALIZED;\n    return _this;\n  }\n\n  (0, _createClass2.default)(LiveQueryClient, [{\n    key: \"shouldOpen\",\n    value: function ()\n    /*: any*/\n    {\n      return this.state === CLIENT_STATE.INITIALIZED || this.state === CLIENT_STATE.DISCONNECTED;\n    }\n    /**\n     * Subscribes to a ParseQuery\n     *\n     * If you provide the sessionToken, when the LiveQuery server gets ParseObject's\n     * updates from parse server, it'll try to check whether the sessionToken fulfills\n     * the ParseObject's ACL. The LiveQuery server will only send updates to clients whose\n     * sessionToken is fit for the ParseObject's ACL. You can check the LiveQuery protocol\n     * <a href=\"https://github.com/parse-community/parse-server/wiki/Parse-LiveQuery-Protocol-Specification\">here</a> for more details. The subscription you get is the same subscription you get\n     * from our Standard API.\n     *\n     * @param {Object} query - the ParseQuery you want to subscribe to\n     * @param {string} sessionToken (optional)\n     * @return {Object} subscription\n     */\n\n  }, {\n    key: \"subscribe\",\n    value: function (query\n    /*: Object*/\n    , sessionToken\n    /*: ?string*/\n    )\n    /*: Object*/\n    {\n      var _this2 = this;\n\n      if (!query) {\n        return;\n      }\n\n      var className = query.className;\n      var queryJSON = query.toJSON();\n      var where = queryJSON.where;\n      var fields = queryJSON.keys ? queryJSON.keys.split(',') : undefined;\n      var subscribeRequest = {\n        op: OP_TYPES.SUBSCRIBE,\n        requestId: this.requestId,\n        query: {\n          className: className,\n          where: where,\n          fields: fields\n        }\n      };\n\n      if (sessionToken) {\n        subscribeRequest.sessionToken = sessionToken;\n      }\n\n      var subscription = new _LiveQuerySubscription.default(this.requestId, query, sessionToken);\n      this.subscriptions.set(this.requestId, subscription);\n      this.requestId += 1;\n      this.connectPromise.then(function () {\n        _this2.socket.send(JSON.stringify(subscribeRequest));\n      });\n      return subscription;\n    }\n    /**\n     * After calling unsubscribe you'll stop receiving events from the subscription object.\n     *\n     * @param {Object} subscription - subscription you would like to unsubscribe from.\n     */\n\n  }, {\n    key: \"unsubscribe\",\n    value: function (subscription\n    /*: Object*/\n    ) {\n      var _this3 = this;\n\n      if (!subscription) {\n        return;\n      }\n\n      this.subscriptions.delete(subscription.id);\n      var unsubscribeRequest = {\n        op: OP_TYPES.UNSUBSCRIBE,\n        requestId: subscription.id\n      };\n      this.connectPromise.then(function () {\n        _this3.socket.send(JSON.stringify(unsubscribeRequest));\n      });\n    }\n    /**\n     * After open is called, the LiveQueryClient will try to send a connect request\n     * to the LiveQuery server.\n     *\n     */\n\n  }, {\n    key: \"open\",\n    value: function () {\n      var _this4 = this;\n\n      var WebSocketImplementation = this._getWebSocketImplementation();\n\n      if (!WebSocketImplementation) {\n        this.emit(CLIENT_EMMITER_TYPES.ERROR, 'Can not find WebSocket implementation');\n        return;\n      }\n\n      if (this.state !== CLIENT_STATE.RECONNECTING) {\n        this.state = CLIENT_STATE.CONNECTING;\n      } // Get WebSocket implementation\n\n\n      this.socket = new WebSocketImplementation(this.serverURL); // Bind WebSocket callbacks\n\n      this.socket.onopen = function () {\n        _this4._handleWebSocketOpen();\n      };\n\n      this.socket.onmessage = function (event) {\n        _this4._handleWebSocketMessage(event);\n      };\n\n      this.socket.onclose = function () {\n        _this4._handleWebSocketClose();\n      };\n\n      this.socket.onerror = function (error) {\n        _this4._handleWebSocketError(error);\n      };\n    }\n  }, {\n    key: \"resubscribe\",\n    value: function () {\n      var _this5 = this;\n\n      this.subscriptions.forEach(function (subscription, requestId) {\n        var query = subscription.query;\n        var queryJSON = query.toJSON();\n        var where = queryJSON.where;\n        var fields = queryJSON.keys ? queryJSON.keys.split(',') : undefined;\n        var className = query.className;\n        var sessionToken = subscription.sessionToken;\n        var subscribeRequest = {\n          op: OP_TYPES.SUBSCRIBE,\n          requestId: requestId,\n          query: {\n            className: className,\n            where: where,\n            fields: fields\n          }\n        };\n\n        if (sessionToken) {\n          subscribeRequest.sessionToken = sessionToken;\n        }\n\n        _this5.connectPromise.then(function () {\n          _this5.socket.send(JSON.stringify(subscribeRequest));\n        });\n      });\n    }\n    /**\n     * This method will close the WebSocket connection to this LiveQueryClient,\n     * cancel the auto reconnect and unsubscribe all subscriptions based on it.\n     *\n     */\n\n  }, {\n    key: \"close\",\n    value: function () {\n      if (this.state === CLIENT_STATE.INITIALIZED || this.state === CLIENT_STATE.DISCONNECTED) {\n        return;\n      }\n\n      this.state = CLIENT_STATE.DISCONNECTED;\n      this.socket.close(); // Notify each subscription about the close\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this.subscriptions.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var subscription = _step.value;\n          subscription.emit(SUBSCRIPTION_EMMITER_TYPES.CLOSE);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      this._handleReset();\n\n      this.emit(CLIENT_EMMITER_TYPES.CLOSE);\n    }\n  }, {\n    key: \"_getWebSocketImplementation\",\n    value: function ()\n    /*: any*/\n    {\n      return typeof WebSocket === 'function' || (typeof WebSocket === \"undefined\" ? \"undefined\" : (0, _typeof2.default)(WebSocket)) === 'object' ? WebSocket : null;\n    } // ensure we start with valid state if connect is called again after close\n\n  }, {\n    key: \"_handleReset\",\n    value: function () {\n      this.attempts = 1;\n      this.id = 0;\n      this.requestId = 1;\n      this.connectPromise = (0, _promiseUtils.resolvingPromise)();\n      this.subscriptions = new Map();\n    }\n  }, {\n    key: \"_handleWebSocketOpen\",\n    value: function () {\n      this.attempts = 1;\n      var connectRequest = {\n        op: OP_TYPES.CONNECT,\n        applicationId: this.applicationId,\n        javascriptKey: this.javascriptKey,\n        masterKey: this.masterKey,\n        sessionToken: this.sessionToken\n      };\n      this.socket.send(JSON.stringify(connectRequest));\n    }\n  }, {\n    key: \"_handleWebSocketMessage\",\n    value: function (event\n    /*: any*/\n    ) {\n      var data = event.data;\n\n      if (typeof data === 'string') {\n        data = JSON.parse(data);\n      }\n\n      var subscription = null;\n\n      if (data.requestId) {\n        subscription = this.subscriptions.get(data.requestId);\n      }\n\n      switch (data.op) {\n        case OP_EVENTS.CONNECTED:\n          if (this.state === CLIENT_STATE.RECONNECTING) {\n            this.resubscribe();\n          }\n\n          this.emit(CLIENT_EMMITER_TYPES.OPEN);\n          this.id = data.clientId;\n          this.connectPromise.resolve();\n          this.state = CLIENT_STATE.CONNECTED;\n          break;\n\n        case OP_EVENTS.SUBSCRIBED:\n          if (subscription) {\n            subscription.emit(SUBSCRIPTION_EMMITER_TYPES.OPEN);\n          }\n\n          break;\n\n        case OP_EVENTS.ERROR:\n          if (data.requestId) {\n            if (subscription) {\n              subscription.emit(SUBSCRIPTION_EMMITER_TYPES.ERROR, data.error);\n            }\n          } else {\n            this.emit(CLIENT_EMMITER_TYPES.ERROR, data.error);\n          }\n\n          break;\n\n        case OP_EVENTS.UNSUBSCRIBED:\n          // We have already deleted subscription in unsubscribe(), do nothing here\n          break;\n\n        default:\n          {\n            // create, update, enter, leave, delete cases\n            if (!subscription) {\n              break;\n            }\n\n            var override = false;\n\n            if (data.original) {\n              override = true;\n              delete data.original.__type; // Check for removed fields\n\n              for (var field in data.original) {\n                if (!(field in data.object)) {\n                  data.object[field] = undefined;\n                }\n              }\n\n              data.original = _ParseObject.default.fromJSON(data.original, false);\n            }\n\n            delete data.object.__type;\n\n            var parseObject = _ParseObject.default.fromJSON(data.object, override);\n\n            subscription.emit(data.op, parseObject, data.original);\n\n            var localDatastore = _CoreManager.default.getLocalDatastore();\n\n            if (override && localDatastore.isEnabled) {\n              localDatastore._updateObjectIfPinned(parseObject).then(function () {});\n            }\n          }\n      }\n    }\n  }, {\n    key: \"_handleWebSocketClose\",\n    value: function () {\n      if (this.state === CLIENT_STATE.DISCONNECTED) {\n        return;\n      }\n\n      this.state = CLIENT_STATE.CLOSED;\n      this.emit(CLIENT_EMMITER_TYPES.CLOSE); // Notify each subscription about the close\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = this.subscriptions.values()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var subscription = _step2.value;\n          subscription.emit(SUBSCRIPTION_EMMITER_TYPES.CLOSE);\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      this._handleReconnect();\n    }\n  }, {\n    key: \"_handleWebSocketError\",\n    value: function (error\n    /*: any*/\n    ) {\n      this.emit(CLIENT_EMMITER_TYPES.ERROR, error);\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = this.subscriptions.values()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var subscription = _step3.value;\n          subscription.emit(SUBSCRIPTION_EMMITER_TYPES.ERROR);\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      this._handleReconnect();\n    }\n  }, {\n    key: \"_handleReconnect\",\n    value: function () {\n      var _this6 = this; // if closed or currently reconnecting we stop attempting to reconnect\n\n\n      if (this.state === CLIENT_STATE.DISCONNECTED) {\n        return;\n      }\n\n      this.state = CLIENT_STATE.RECONNECTING;\n      var time = generateInterval(this.attempts); // handle case when both close/error occur at frequent rates we ensure we do not reconnect unnecessarily.\n      // we're unable to distinguish different between close/error when we're unable to reconnect therefore\n      // we try to reonnect in both cases\n      // server side ws and browser WebSocket behave differently in when close/error get triggered\n\n      if (this.reconnectHandle) {\n        clearTimeout(this.reconnectHandle);\n      }\n\n      this.reconnectHandle = setTimeout(function () {\n        _this6.attempts++;\n        _this6.connectPromise = (0, _promiseUtils.resolvingPromise)();\n\n        _this6.open();\n      }.bind(this), time);\n    }\n  }]);\n  return LiveQueryClient;\n}(_EventEmitter2.default);\n\nvar _default = LiveQueryClient;\nexports.default = _default;","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _EventEmitter2 = _interopRequireDefault(require(\"./EventEmitter\"));\n\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\n/*\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\n/**\n * Creates a new LiveQuery Subscription.\n * Extends events.EventEmitter\n * <a href=\"https://nodejs.org/api/events.html#events_class_eventemitter\">cloud functions</a>.\n *\n *\n * <p>Open Event - When you call query.subscribe(), we send a subscribe request to\n * the LiveQuery server, when we get the confirmation from the LiveQuery server,\n * this event will be emitted. When the client loses WebSocket connection to the\n * LiveQuery server, we will try to auto reconnect the LiveQuery server. If we\n * reconnect the LiveQuery server and successfully resubscribe the ParseQuery,\n * you'll also get this event.\n *\n * <pre>\n * subscription.on('open', () => {\n *\n * });</pre></p>\n *\n * <p>Create Event - When a new ParseObject is created and it fulfills the ParseQuery you subscribe,\n * you'll get this event. The object is the ParseObject which is created.\n *\n * <pre>\n * subscription.on('create', (object) => {\n *\n * });</pre></p>\n *\n * <p>Update Event - When an existing ParseObject (original) which fulfills the ParseQuery you subscribe\n * is updated (The ParseObject fulfills the ParseQuery before and after changes),\n * you'll get this event. The object is the ParseObject which is updated.\n * Its content is the latest value of the ParseObject.\n *\n * Parse-Server 3.1.3+ Required for original object parameter\n *\n * <pre>\n * subscription.on('update', (object, original) => {\n *\n * });</pre></p>\n *\n * <p>Enter Event - When an existing ParseObject's (original) old value doesn't fulfill the ParseQuery\n * but its new value fulfills the ParseQuery, you'll get this event. The object is the\n * ParseObject which enters the ParseQuery. Its content is the latest value of the ParseObject.\n *\n * Parse-Server 3.1.3+ Required for original object parameter\n *\n * <pre>\n * subscription.on('enter', (object, original) => {\n *\n * });</pre></p>\n *\n *\n * <p>Update Event - When an existing ParseObject's old value fulfills the ParseQuery but its new value\n * doesn't fulfill the ParseQuery, you'll get this event. The object is the ParseObject\n * which leaves the ParseQuery. Its content is the latest value of the ParseObject.\n *\n * <pre>\n * subscription.on('leave', (object) => {\n *\n * });</pre></p>\n *\n *\n * <p>Delete Event - When an existing ParseObject which fulfills the ParseQuery is deleted, you'll\n * get this event. The object is the ParseObject which is deleted.\n *\n * <pre>\n * subscription.on('delete', (object) => {\n *\n * });</pre></p>\n *\n *\n * <p>Close Event - When the client loses the WebSocket connection to the LiveQuery\n * server and we stop receiving events, you'll get this event.\n *\n * <pre>\n * subscription.on('close', () => {\n *\n * });</pre></p>\n *\n * @alias Parse.LiveQuerySubscription\n */\n\n\nvar Subscription =\n/*#__PURE__*/\nfunction (_EventEmitter) {\n  (0, _inherits2.default)(Subscription, _EventEmitter);\n  /*\n   * @param {string} id - subscription id\n   * @param {string} query - query to subscribe to\n   * @param {string} sessionToken - optional session token\n   */\n\n  function Subscription(id, query, sessionToken) {\n    var _this;\n\n    (0, _classCallCheck2.default)(this, Subscription);\n    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Subscription).call(this));\n    _this.id = id;\n    _this.query = query;\n    _this.sessionToken = sessionToken; // adding listener so process does not crash\n    // best practice is for developer to register their own listener\n\n    _this.on('error', function () {});\n\n    return _this;\n  }\n  /**\n   * Close the subscription\n   */\n\n\n  (0, _createClass2.default)(Subscription, [{\n    key: \"unsubscribe\",\n    value: function ()\n    /*: Promise*/\n    {\n      var _this2 = this;\n\n      return _CoreManager.default.getLiveQueryController().getDefaultLiveQueryClient().then(function (liveQueryClient) {\n        liveQueryClient.unsubscribe(_this2);\n\n        _this2.emit('close');\n      });\n    }\n  }]);\n  return Subscription;\n}(_EventEmitter2.default);\n\nvar _default = Subscription;\nexports.default = _default;","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\n\nvar _ParseQuery = _interopRequireDefault(require(\"./ParseQuery\"));\n\nvar _LocalDatastoreUtils = require(\"./LocalDatastoreUtils\");\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n/**\n * Provides a local datastore which can be used to store and retrieve <code>Parse.Object</code>. <br />\n * To enable this functionality, call <code>Parse.enableLocalDatastore()</code>.\n *\n * Pin object to add to local datastore\n *\n * <pre>await object.pin();</pre>\n * <pre>await object.pinWithName('pinName');</pre>\n *\n * Query pinned objects\n *\n * <pre>query.fromLocalDatastore();</pre>\n * <pre>query.fromPin();</pre>\n * <pre>query.fromPinWithName();</pre>\n *\n * <pre>const localObjects = await query.find();</pre>\n *\n * @class Parse.LocalDatastore\n * @static\n */\n\n\nvar LocalDatastore = {\n  isEnabled: false,\n  isSyncing: false,\n  fromPinWithName: function (name\n  /*: string*/\n  )\n  /*: Promise<Array<Object>>*/\n  {\n    var controller = _CoreManager.default.getLocalDatastoreController();\n\n    return controller.fromPinWithName(name);\n  },\n  pinWithName: function (name\n  /*: string*/\n  , value\n  /*: any*/\n  )\n  /*: Promise<void>*/\n  {\n    var controller = _CoreManager.default.getLocalDatastoreController();\n\n    return controller.pinWithName(name, value);\n  },\n  unPinWithName: function (name\n  /*: string*/\n  )\n  /*: Promise<void>*/\n  {\n    var controller = _CoreManager.default.getLocalDatastoreController();\n\n    return controller.unPinWithName(name);\n  },\n  _getAllContents: function ()\n  /*: Promise<Object>*/\n  {\n    var controller = _CoreManager.default.getLocalDatastoreController();\n\n    return controller.getAllContents();\n  },\n  // Use for testing\n  _getRawStorage: function ()\n  /*: Promise<Object>*/\n  {\n    var controller = _CoreManager.default.getLocalDatastoreController();\n\n    return controller.getRawStorage();\n  },\n  _clear: function ()\n  /*: Promise<void>*/\n  {\n    var controller = _CoreManager.default.getLocalDatastoreController();\n\n    return controller.clear();\n  },\n  // Pin the object and children recursively\n  // Saves the object and children key to Pin Name\n  _handlePinAllWithName: function () {\n    var _handlePinAllWithName2 = (0, _asyncToGenerator2.default)(\n    /*#__PURE__*/\n    _regenerator.default.mark(function _callee(name\n    /*: string*/\n    , objects\n    /*: Array<ParseObject>*/\n    ) {\n      var pinName, toPinPromises, objectKeys, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, parent, children, parentKey, json, objectKey, fromPinPromise, _ref, _ref2, pinned, toPin;\n\n      return _regenerator.default.wrap(function (_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              pinName = this.getPinName(name);\n              toPinPromises = [];\n              objectKeys = [];\n              _iteratorNormalCompletion = true;\n              _didIteratorError = false;\n              _iteratorError = undefined;\n              _context.prev = 6;\n\n              for (_iterator = objects[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                parent = _step.value;\n                children = this._getChildren(parent);\n                parentKey = this.getKeyForObject(parent);\n                json = parent._toFullJSON();\n\n                if (parent._localId) {\n                  json._localId = parent._localId;\n                }\n\n                children[parentKey] = json;\n\n                for (objectKey in children) {\n                  objectKeys.push(objectKey);\n                  toPinPromises.push(this.pinWithName(objectKey, [children[objectKey]]));\n                }\n              }\n\n              _context.next = 14;\n              break;\n\n            case 10:\n              _context.prev = 10;\n              _context.t0 = _context[\"catch\"](6);\n              _didIteratorError = true;\n              _iteratorError = _context.t0;\n\n            case 14:\n              _context.prev = 14;\n              _context.prev = 15;\n\n              if (!_iteratorNormalCompletion && _iterator.return != null) {\n                _iterator.return();\n              }\n\n            case 17:\n              _context.prev = 17;\n\n              if (!_didIteratorError) {\n                _context.next = 20;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 20:\n              return _context.finish(17);\n\n            case 21:\n              return _context.finish(14);\n\n            case 22:\n              fromPinPromise = this.fromPinWithName(pinName);\n              _context.next = 25;\n              return Promise.all([fromPinPromise, toPinPromises]);\n\n            case 25:\n              _ref = _context.sent;\n              _ref2 = (0, _slicedToArray2.default)(_ref, 1);\n              pinned = _ref2[0];\n              toPin = (0, _toConsumableArray2.default)(new Set([].concat((0, _toConsumableArray2.default)(pinned || []), objectKeys)));\n              return _context.abrupt(\"return\", this.pinWithName(pinName, toPin));\n\n            case 30:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, this, [[6, 10, 14, 22], [15,, 17, 21]]);\n    }));\n\n    return function () {\n      return _handlePinAllWithName2.apply(this, arguments);\n    };\n  }(),\n  // Removes object and children keys from pin name\n  // Keeps the object and children pinned\n  _handleUnPinAllWithName: function () {\n    var _handleUnPinAllWithName2 = (0, _asyncToGenerator2.default)(\n    /*#__PURE__*/\n    _regenerator.default.mark(function _callee2(name\n    /*: string*/\n    , objects\n    /*: Array<ParseObject>*/\n    ) {\n      var localDatastore, pinName, promises, objectKeys, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _objectKeys, parent, children, parentKey, pinned, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, objectKey, hasReference, key, pinnedObjects;\n\n      return _regenerator.default.wrap(function (_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return this._getAllContents();\n\n            case 2:\n              localDatastore = _context2.sent;\n              pinName = this.getPinName(name);\n              promises = [];\n              objectKeys = [];\n              _iteratorNormalCompletion2 = true;\n              _didIteratorError2 = false;\n              _iteratorError2 = undefined;\n              _context2.prev = 9;\n\n              for (_iterator2 = objects[Symbol.iterator](); !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                parent = _step2.value;\n                children = this._getChildren(parent);\n                parentKey = this.getKeyForObject(parent);\n\n                (_objectKeys = objectKeys).push.apply(_objectKeys, [parentKey].concat((0, _toConsumableArray2.default)(Object.keys(children))));\n              }\n\n              _context2.next = 17;\n              break;\n\n            case 13:\n              _context2.prev = 13;\n              _context2.t0 = _context2[\"catch\"](9);\n              _didIteratorError2 = true;\n              _iteratorError2 = _context2.t0;\n\n            case 17:\n              _context2.prev = 17;\n              _context2.prev = 18;\n\n              if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                _iterator2.return();\n              }\n\n            case 20:\n              _context2.prev = 20;\n\n              if (!_didIteratorError2) {\n                _context2.next = 23;\n                break;\n              }\n\n              throw _iteratorError2;\n\n            case 23:\n              return _context2.finish(20);\n\n            case 24:\n              return _context2.finish(17);\n\n            case 25:\n              objectKeys = (0, _toConsumableArray2.default)(new Set(objectKeys));\n              pinned = localDatastore[pinName] || [];\n              pinned = pinned.filter(function (item) {\n                return !objectKeys.includes(item);\n              });\n\n              if (pinned.length == 0) {\n                promises.push(this.unPinWithName(pinName));\n                delete localDatastore[pinName];\n              } else {\n                promises.push(this.pinWithName(pinName, pinned));\n                localDatastore[pinName] = pinned;\n              }\n\n              _iteratorNormalCompletion3 = true;\n              _didIteratorError3 = false;\n              _iteratorError3 = undefined;\n              _context2.prev = 32;\n              _iterator3 = objectKeys[Symbol.iterator]();\n\n            case 34:\n              if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {\n                _context2.next = 51;\n                break;\n              }\n\n              objectKey = _step3.value;\n              hasReference = false;\n              _context2.t1 = _regenerator.default.keys(localDatastore);\n\n            case 38:\n              if ((_context2.t2 = _context2.t1()).done) {\n                _context2.next = 47;\n                break;\n              }\n\n              key = _context2.t2.value;\n\n              if (!(key === _LocalDatastoreUtils.DEFAULT_PIN || key.startsWith(_LocalDatastoreUtils.PIN_PREFIX))) {\n                _context2.next = 45;\n                break;\n              }\n\n              pinnedObjects = localDatastore[key] || [];\n\n              if (!pinnedObjects.includes(objectKey)) {\n                _context2.next = 45;\n                break;\n              }\n\n              hasReference = true;\n              return _context2.abrupt(\"break\", 47);\n\n            case 45:\n              _context2.next = 38;\n              break;\n\n            case 47:\n              if (!hasReference) {\n                promises.push(this.unPinWithName(objectKey));\n              }\n\n            case 48:\n              _iteratorNormalCompletion3 = true;\n              _context2.next = 34;\n              break;\n\n            case 51:\n              _context2.next = 57;\n              break;\n\n            case 53:\n              _context2.prev = 53;\n              _context2.t3 = _context2[\"catch\"](32);\n              _didIteratorError3 = true;\n              _iteratorError3 = _context2.t3;\n\n            case 57:\n              _context2.prev = 57;\n              _context2.prev = 58;\n\n              if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n                _iterator3.return();\n              }\n\n            case 60:\n              _context2.prev = 60;\n\n              if (!_didIteratorError3) {\n                _context2.next = 63;\n                break;\n              }\n\n              throw _iteratorError3;\n\n            case 63:\n              return _context2.finish(60);\n\n            case 64:\n              return _context2.finish(57);\n\n            case 65:\n              return _context2.abrupt(\"return\", Promise.all(promises));\n\n            case 66:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, this, [[9, 13, 17, 25], [18,, 20, 24], [32, 53, 57, 65], [58,, 60, 64]]);\n    }));\n\n    return function () {\n      return _handleUnPinAllWithName2.apply(this, arguments);\n    };\n  }(),\n  // Retrieve all pointer fields from object recursively\n  _getChildren: function (object\n  /*: ParseObject*/\n  ) {\n    var encountered = {};\n\n    var json = object._toFullJSON();\n\n    for (var key in json) {\n      if (json[key] && json[key].__type && json[key].__type === 'Object') {\n        this._traverse(json[key], encountered);\n      }\n    }\n\n    return encountered;\n  },\n  _traverse: function (object\n  /*: any*/\n  , encountered\n  /*: any*/\n  ) {\n    if (!object.objectId) {\n      return;\n    } else {\n      var objectKey = this.getKeyForObject(object);\n\n      if (encountered[objectKey]) {\n        return;\n      }\n\n      encountered[objectKey] = object;\n    }\n\n    for (var key in object) {\n      var json = object[key];\n\n      if (!object[key]) {\n        json = object;\n      }\n\n      if (json.__type && json.__type === 'Object') {\n        this._traverse(json, encountered);\n      }\n    }\n  },\n  // Transform keys in pin name to objects\n  _serializeObjectsFromPinName: function () {\n    var _serializeObjectsFromPinName2 = (0, _asyncToGenerator2.default)(\n    /*#__PURE__*/\n    _regenerator.default.mark(function _callee3(name\n    /*: string*/\n    ) {\n      var _this = this,\n          _ref3;\n\n      var localDatastore, allObjects, key, pinName, pinned, promises, objects;\n      return _regenerator.default.wrap(function (_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.next = 2;\n              return this._getAllContents();\n\n            case 2:\n              localDatastore = _context3.sent;\n              allObjects = [];\n\n              for (key in localDatastore) {\n                if (key.startsWith(_LocalDatastoreUtils.OBJECT_PREFIX)) {\n                  allObjects.push(localDatastore[key][0]);\n                }\n              }\n\n              if (name) {\n                _context3.next = 7;\n                break;\n              }\n\n              return _context3.abrupt(\"return\", allObjects);\n\n            case 7:\n              pinName = this.getPinName(name);\n              pinned = localDatastore[pinName];\n\n              if (Array.isArray(pinned)) {\n                _context3.next = 11;\n                break;\n              }\n\n              return _context3.abrupt(\"return\", []);\n\n            case 11:\n              promises = pinned.map(function (objectKey) {\n                return _this.fromPinWithName(objectKey);\n              });\n              _context3.next = 14;\n              return Promise.all(promises);\n\n            case 14:\n              objects = _context3.sent;\n              objects = (_ref3 = []).concat.apply(_ref3, (0, _toConsumableArray2.default)(objects));\n              return _context3.abrupt(\"return\", objects.filter(function (object) {\n                return object != null;\n              }));\n\n            case 17:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3, this);\n    }));\n\n    return function () {\n      return _serializeObjectsFromPinName2.apply(this, arguments);\n    };\n  }(),\n  // Replaces object pointers with pinned pointers\n  // The object pointers may contain old data\n  // Uses Breadth First Search Algorithm\n  _serializeObject: function () {\n    var _serializeObject2 = (0, _asyncToGenerator2.default)(\n    /*#__PURE__*/\n    _regenerator.default.mark(function _callee4(objectKey\n    /*: string*/\n    , localDatastore\n    /*: any*/\n    ) {\n      var LDS, root, queue, meta, uniqueId, nodeId, subTreeRoot, field, value, key, pointer;\n      return _regenerator.default.wrap(function (_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              LDS = localDatastore;\n\n              if (LDS) {\n                _context4.next = 5;\n                break;\n              }\n\n              _context4.next = 4;\n              return this._getAllContents();\n\n            case 4:\n              LDS = _context4.sent;\n\n            case 5:\n              if (!(!LDS[objectKey] || LDS[objectKey].length === 0)) {\n                _context4.next = 7;\n                break;\n              }\n\n              return _context4.abrupt(\"return\", null);\n\n            case 7:\n              root = LDS[objectKey][0];\n              queue = [];\n              meta = {};\n              uniqueId = 0;\n              meta[uniqueId] = root;\n              queue.push(uniqueId);\n\n              while (queue.length !== 0) {\n                nodeId = queue.shift();\n                subTreeRoot = meta[nodeId];\n\n                for (field in subTreeRoot) {\n                  value = subTreeRoot[field];\n\n                  if (value.__type && value.__type === 'Object') {\n                    key = this.getKeyForObject(value);\n\n                    if (LDS[key] && LDS[key].length > 0) {\n                      pointer = LDS[key][0];\n                      uniqueId++;\n                      meta[uniqueId] = pointer;\n                      subTreeRoot[field] = pointer;\n                      queue.push(uniqueId);\n                    }\n                  }\n                }\n              }\n\n              return _context4.abrupt(\"return\", root);\n\n            case 15:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4, this);\n    }));\n\n    return function () {\n      return _serializeObject2.apply(this, arguments);\n    };\n  }(),\n  // Called when an object is save / fetched\n  // Update object pin value\n  _updateObjectIfPinned: function () {\n    var _updateObjectIfPinned2 = (0, _asyncToGenerator2.default)(\n    /*#__PURE__*/\n    _regenerator.default.mark(function _callee5(object\n    /*: ParseObject*/\n    ) {\n      var objectKey, pinned;\n      return _regenerator.default.wrap(function (_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              if (this.isEnabled) {\n                _context5.next = 2;\n                break;\n              }\n\n              return _context5.abrupt(\"return\");\n\n            case 2:\n              objectKey = this.getKeyForObject(object);\n              _context5.next = 5;\n              return this.fromPinWithName(objectKey);\n\n            case 5:\n              pinned = _context5.sent;\n\n              if (!(!pinned || pinned.length === 0)) {\n                _context5.next = 8;\n                break;\n              }\n\n              return _context5.abrupt(\"return\");\n\n            case 8:\n              return _context5.abrupt(\"return\", this.pinWithName(objectKey, [object._toFullJSON()]));\n\n            case 9:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, _callee5, this);\n    }));\n\n    return function () {\n      return _updateObjectIfPinned2.apply(this, arguments);\n    };\n  }(),\n  // Called when object is destroyed\n  // Unpin object and remove all references from pin names\n  // TODO: Destroy children?\n  _destroyObjectIfPinned: function () {\n    var _destroyObjectIfPinned2 = (0, _asyncToGenerator2.default)(\n    /*#__PURE__*/\n    _regenerator.default.mark(function _callee6(object\n    /*: ParseObject*/\n    ) {\n      var localDatastore, objectKey, pin, promises, key, pinned;\n      return _regenerator.default.wrap(function (_context6) {\n        while (1) {\n          switch (_context6.prev = _context6.next) {\n            case 0:\n              if (this.isEnabled) {\n                _context6.next = 2;\n                break;\n              }\n\n              return _context6.abrupt(\"return\");\n\n            case 2:\n              _context6.next = 4;\n              return this._getAllContents();\n\n            case 4:\n              localDatastore = _context6.sent;\n              objectKey = this.getKeyForObject(object);\n              pin = localDatastore[objectKey];\n\n              if (pin) {\n                _context6.next = 9;\n                break;\n              }\n\n              return _context6.abrupt(\"return\");\n\n            case 9:\n              promises = [this.unPinWithName(objectKey)];\n              delete localDatastore[objectKey];\n\n              for (key in localDatastore) {\n                if (key === _LocalDatastoreUtils.DEFAULT_PIN || key.startsWith(_LocalDatastoreUtils.PIN_PREFIX)) {\n                  pinned = localDatastore[key] || [];\n\n                  if (pinned.includes(objectKey)) {\n                    pinned = pinned.filter(function (item) {\n                      return item !== objectKey;\n                    });\n\n                    if (pinned.length == 0) {\n                      promises.push(this.unPinWithName(key));\n                      delete localDatastore[key];\n                    } else {\n                      promises.push(this.pinWithName(key, pinned));\n                      localDatastore[key] = pinned;\n                    }\n                  }\n                }\n              }\n\n              return _context6.abrupt(\"return\", Promise.all(promises));\n\n            case 13:\n            case \"end\":\n              return _context6.stop();\n          }\n        }\n      }, _callee6, this);\n    }));\n\n    return function () {\n      return _destroyObjectIfPinned2.apply(this, arguments);\n    };\n  }(),\n  // Update pin and references of the unsaved object\n  _updateLocalIdForObject: function () {\n    var _updateLocalIdForObject2 = (0, _asyncToGenerator2.default)(\n    /*#__PURE__*/\n    _regenerator.default.mark(function _callee7(localId\n    /*: string*/\n    , object\n    /*: ParseObject*/\n    ) {\n      var localKey, objectKey, unsaved, promises, localDatastore, key, pinned;\n      return _regenerator.default.wrap(function (_context7) {\n        while (1) {\n          switch (_context7.prev = _context7.next) {\n            case 0:\n              if (this.isEnabled) {\n                _context7.next = 2;\n                break;\n              }\n\n              return _context7.abrupt(\"return\");\n\n            case 2:\n              localKey = \"\".concat(_LocalDatastoreUtils.OBJECT_PREFIX).concat(object.className, \"_\").concat(localId);\n              objectKey = this.getKeyForObject(object);\n              _context7.next = 6;\n              return this.fromPinWithName(localKey);\n\n            case 6:\n              unsaved = _context7.sent;\n\n              if (!(!unsaved || unsaved.length === 0)) {\n                _context7.next = 9;\n                break;\n              }\n\n              return _context7.abrupt(\"return\");\n\n            case 9:\n              promises = [this.unPinWithName(localKey), this.pinWithName(objectKey, unsaved)];\n              _context7.next = 12;\n              return this._getAllContents();\n\n            case 12:\n              localDatastore = _context7.sent;\n\n              for (key in localDatastore) {\n                if (key === _LocalDatastoreUtils.DEFAULT_PIN || key.startsWith(_LocalDatastoreUtils.PIN_PREFIX)) {\n                  pinned = localDatastore[key] || [];\n\n                  if (pinned.includes(localKey)) {\n                    pinned = pinned.filter(function (item) {\n                      return item !== localKey;\n                    });\n                    pinned.push(objectKey);\n                    promises.push(this.pinWithName(key, pinned));\n                    localDatastore[key] = pinned;\n                  }\n                }\n              }\n\n              return _context7.abrupt(\"return\", Promise.all(promises));\n\n            case 15:\n            case \"end\":\n              return _context7.stop();\n          }\n        }\n      }, _callee7, this);\n    }));\n\n    return function () {\n      return _updateLocalIdForObject2.apply(this, arguments);\n    };\n  }(),\n\n  /**\n   * Updates Local Datastore from Server\n   *\n   * <pre>\n   * await Parse.LocalDatastore.updateFromServer();\n   * </pre>\n   * @method updateFromServer\n   * @name Parse.LocalDatastore.updateFromServer\n   * @static\n   */\n  updateFromServer: function () {\n    var _updateFromServer = (0, _asyncToGenerator2.default)(\n    /*#__PURE__*/\n    _regenerator.default.mark(function _callee8() {\n      var _this2 = this;\n\n      var localDatastore, keys, key, pointersHash, _i, _keys, _key, _key$split, _key$split2, className, objectId, queryPromises, responses, objects, pinPromises;\n\n      return _regenerator.default.wrap(function (_context8) {\n        while (1) {\n          switch (_context8.prev = _context8.next) {\n            case 0:\n              if (!(!this.checkIfEnabled() || this.isSyncing)) {\n                _context8.next = 2;\n                break;\n              }\n\n              return _context8.abrupt(\"return\");\n\n            case 2:\n              _context8.next = 4;\n              return this._getAllContents();\n\n            case 4:\n              localDatastore = _context8.sent;\n              keys = [];\n\n              for (key in localDatastore) {\n                if (key.startsWith(_LocalDatastoreUtils.OBJECT_PREFIX)) {\n                  keys.push(key);\n                }\n              }\n\n              if (!(keys.length === 0)) {\n                _context8.next = 9;\n                break;\n              }\n\n              return _context8.abrupt(\"return\");\n\n            case 9:\n              this.isSyncing = true;\n              pointersHash = {};\n              _i = 0, _keys = keys;\n\n            case 12:\n              if (!(_i < _keys.length)) {\n                _context8.next = 23;\n                break;\n              }\n\n              _key = _keys[_i]; // Ignore the OBJECT_PREFIX\n\n              _key$split = _key.split('_'), _key$split2 = (0, _slicedToArray2.default)(_key$split, 4), className = _key$split2[2], objectId = _key$split2[3]; // User key is split into [ 'Parse', 'LDS', '', 'User', 'objectId' ]\n\n              if (_key.split('_').length === 5 && _key.split('_')[3] === 'User') {\n                className = '_User';\n                objectId = _key.split('_')[4];\n              }\n\n              if (!objectId.startsWith('local')) {\n                _context8.next = 18;\n                break;\n              }\n\n              return _context8.abrupt(\"continue\", 20);\n\n            case 18:\n              if (!(className in pointersHash)) {\n                pointersHash[className] = new Set();\n              }\n\n              pointersHash[className].add(objectId);\n\n            case 20:\n              _i++;\n              _context8.next = 12;\n              break;\n\n            case 23:\n              queryPromises = Object.keys(pointersHash).map(function (className) {\n                var objectIds = Array.from(pointersHash[className]);\n                var query = new _ParseQuery.default(className);\n                query.limit(objectIds.length);\n\n                if (objectIds.length === 1) {\n                  query.equalTo('objectId', objectIds[0]);\n                } else {\n                  query.containedIn('objectId', objectIds);\n                }\n\n                return query.find();\n              });\n              _context8.prev = 24;\n              _context8.next = 27;\n              return Promise.all(queryPromises);\n\n            case 27:\n              responses = _context8.sent;\n              objects = [].concat.apply([], responses);\n              pinPromises = objects.map(function (object) {\n                var objectKey = _this2.getKeyForObject(object);\n\n                return _this2.pinWithName(objectKey, object._toFullJSON());\n              });\n              _context8.next = 32;\n              return Promise.all(pinPromises);\n\n            case 32:\n              this.isSyncing = false;\n              _context8.next = 39;\n              break;\n\n            case 35:\n              _context8.prev = 35;\n              _context8.t0 = _context8[\"catch\"](24);\n              console.error('Error syncing LocalDatastore: ', _context8.t0);\n              this.isSyncing = false;\n\n            case 39:\n            case \"end\":\n              return _context8.stop();\n          }\n        }\n      }, _callee8, this, [[24, 35]]);\n    }));\n\n    return function () {\n      return _updateFromServer.apply(this, arguments);\n    };\n  }(),\n  getKeyForObject: function (object\n  /*: any*/\n  ) {\n    var objectId = object.objectId || object._getId();\n\n    return \"\".concat(_LocalDatastoreUtils.OBJECT_PREFIX).concat(object.className, \"_\").concat(objectId);\n  },\n  getPinName: function (pinName\n  /*: ?string*/\n  ) {\n    if (!pinName || pinName === _LocalDatastoreUtils.DEFAULT_PIN) {\n      return _LocalDatastoreUtils.DEFAULT_PIN;\n    }\n\n    return _LocalDatastoreUtils.PIN_PREFIX + pinName;\n  },\n  checkIfEnabled: function () {\n    if (!this.isEnabled) {\n      console.error('Parse.enableLocalDatastore() must be called first');\n    }\n\n    return this.isEnabled;\n  }\n};\nmodule.exports = LocalDatastore;\n\n_CoreManager.default.setLocalDatastoreController(require('./LocalDatastoreController.browser'));\n\n_CoreManager.default.setLocalDatastore(LocalDatastore);","\"use strict\";\n\nvar _LocalDatastoreUtils = require(\"./LocalDatastoreUtils\");\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n/* global localStorage */\n\n\nvar LocalDatastoreController = {\n  fromPinWithName: function (name\n  /*: string*/\n  )\n  /*: Array<Object>*/\n  {\n    var values = localStorage.getItem(name);\n\n    if (!values) {\n      return [];\n    }\n\n    var objects = JSON.parse(values);\n    return objects;\n  },\n  pinWithName: function (name\n  /*: string*/\n  , value\n  /*: any*/\n  ) {\n    try {\n      var values = JSON.stringify(value);\n      localStorage.setItem(name, values);\n    } catch (e) {\n      // Quota exceeded, possibly due to Safari Private Browsing mode\n      console.log(e.message);\n    }\n  },\n  unPinWithName: function (name\n  /*: string*/\n  ) {\n    localStorage.removeItem(name);\n  },\n  getAllContents: function ()\n  /*: Object*/\n  {\n    var LDS = {};\n\n    for (var i = 0; i < localStorage.length; i += 1) {\n      var key = localStorage.key(i);\n\n      if ((0, _LocalDatastoreUtils.isLocalDatastoreKey)(key)) {\n        var value = localStorage.getItem(key);\n\n        try {\n          LDS[key] = JSON.parse(value);\n        } catch (error) {\n          console.error('Error getAllContents: ', error);\n        }\n      }\n    }\n\n    return LDS;\n  },\n  getRawStorage: function ()\n  /*: Object*/\n  {\n    var storage = {};\n\n    for (var i = 0; i < localStorage.length; i += 1) {\n      var key = localStorage.key(i);\n      var value = localStorage.getItem(key);\n      storage[key] = value;\n    }\n\n    return storage;\n  },\n  clear: function ()\n  /*: Promise*/\n  {\n    var toRemove = [];\n\n    for (var i = 0; i < localStorage.length; i += 1) {\n      var key = localStorage.key(i);\n\n      if ((0, _LocalDatastoreUtils.isLocalDatastoreKey)(key)) {\n        toRemove.push(key);\n      }\n    }\n\n    var promises = toRemove.map(this.unPinWithName);\n    return Promise.all(promises);\n  }\n};\nmodule.exports = LocalDatastoreController;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isLocalDatastoreKey = isLocalDatastoreKey;\nexports.OBJECT_PREFIX = exports.PIN_PREFIX = exports.DEFAULT_PIN = void 0;\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\nvar DEFAULT_PIN = '_default';\nexports.DEFAULT_PIN = DEFAULT_PIN;\nvar PIN_PREFIX = 'parsePin_';\nexports.PIN_PREFIX = PIN_PREFIX;\nvar OBJECT_PREFIX = 'Parse_LDS_';\nexports.OBJECT_PREFIX = OBJECT_PREFIX;\n\nfunction isLocalDatastoreKey(key\n/*: string*/\n)\n/*: boolean*/\n{\n  return !!(key && (key === DEFAULT_PIN || key.startsWith(PIN_PREFIX) || key.startsWith(OBJECT_PREFIX)));\n}","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.defaultState = defaultState;\nexports.setServerData = setServerData;\nexports.setPendingOp = setPendingOp;\nexports.pushPendingState = pushPendingState;\nexports.popPendingState = popPendingState;\nexports.mergeFirstPendingState = mergeFirstPendingState;\nexports.estimateAttribute = estimateAttribute;\nexports.estimateAttributes = estimateAttributes;\nexports.commitServerChanges = commitServerChanges;\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _encode = _interopRequireDefault(require(\"./encode\"));\n\nvar _ParseFile = _interopRequireDefault(require(\"./ParseFile\"));\n\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\n\nvar _ParseRelation = _interopRequireDefault(require(\"./ParseRelation\"));\n\nvar _TaskQueue = _interopRequireDefault(require(\"./TaskQueue\"));\n\nvar _ParseOp = require(\"./ParseOp\");\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n\nfunction defaultState()\n/*: State*/\n{\n  return {\n    serverData: {},\n    pendingOps: [{}],\n    objectCache: {},\n    tasks: new _TaskQueue.default(),\n    existed: false\n  };\n}\n\nfunction setServerData(serverData\n/*: AttributeMap*/\n, attributes\n/*: AttributeMap*/\n) {\n  for (var _attr in attributes) {\n    if (typeof attributes[_attr] !== 'undefined') {\n      serverData[_attr] = attributes[_attr];\n    } else {\n      delete serverData[_attr];\n    }\n  }\n}\n\nfunction setPendingOp(pendingOps\n/*: Array<OpsMap>*/\n, attr\n/*: string*/\n, op\n/*: ?Op*/\n) {\n  var last = pendingOps.length - 1;\n\n  if (op) {\n    pendingOps[last][attr] = op;\n  } else {\n    delete pendingOps[last][attr];\n  }\n}\n\nfunction pushPendingState(pendingOps\n/*: Array<OpsMap>*/\n) {\n  pendingOps.push({});\n}\n\nfunction popPendingState(pendingOps\n/*: Array<OpsMap>*/\n)\n/*: OpsMap*/\n{\n  var first = pendingOps.shift();\n\n  if (!pendingOps.length) {\n    pendingOps[0] = {};\n  }\n\n  return first;\n}\n\nfunction mergeFirstPendingState(pendingOps\n/*: Array<OpsMap>*/\n) {\n  var first = popPendingState(pendingOps);\n  var next = pendingOps[0];\n\n  for (var _attr2 in first) {\n    if (next[_attr2] && first[_attr2]) {\n      var merged = next[_attr2].mergeWith(first[_attr2]);\n\n      if (merged) {\n        next[_attr2] = merged;\n      }\n    } else {\n      next[_attr2] = first[_attr2];\n    }\n  }\n}\n\nfunction estimateAttribute(serverData\n/*: AttributeMap*/\n, pendingOps\n/*: Array<OpsMap>*/\n, className\n/*: string*/\n, id\n/*: ?string*/\n, attr\n/*: string*/\n)\n/*: mixed*/\n{\n  var value = serverData[attr];\n\n  for (var i = 0; i < pendingOps.length; i++) {\n    if (pendingOps[i][attr]) {\n      if (pendingOps[i][attr] instanceof _ParseOp.RelationOp) {\n        if (id) {\n          value = pendingOps[i][attr].applyTo(value, {\n            className: className,\n            id: id\n          }, attr);\n        }\n      } else {\n        value = pendingOps[i][attr].applyTo(value);\n      }\n    }\n  }\n\n  return value;\n}\n\nfunction estimateAttributes(serverData\n/*: AttributeMap*/\n, pendingOps\n/*: Array<OpsMap>*/\n, className\n/*: string*/\n, id\n/*: ?string*/\n)\n/*: AttributeMap*/\n{\n  var data = {};\n\n  for (var attr in serverData) {\n    data[attr] = serverData[attr];\n  }\n\n  for (var i = 0; i < pendingOps.length; i++) {\n    for (attr in pendingOps[i]) {\n      if (pendingOps[i][attr] instanceof _ParseOp.RelationOp) {\n        if (id) {\n          data[attr] = pendingOps[i][attr].applyTo(data[attr], {\n            className: className,\n            id: id\n          }, attr);\n        }\n      } else {\n        if (attr.includes('.')) {\n          // convert a.b.c into { a: { b: { c: value } } }\n          var fields = attr.split('.');\n          var last = fields[fields.length - 1];\n          var object = Object.assign({}, data);\n\n          for (var _i = 0; _i < fields.length - 1; _i++) {\n            object = object[fields[_i]];\n          }\n\n          object[last] = pendingOps[i][attr].applyTo(object[last]);\n        } else {\n          data[attr] = pendingOps[i][attr].applyTo(data[attr]);\n        }\n      }\n    }\n  }\n\n  return data;\n}\n\nfunction commitServerChanges(serverData\n/*: AttributeMap*/\n, objectCache\n/*: ObjectCache*/\n, changes\n/*: AttributeMap*/\n) {\n  for (var _attr3 in changes) {\n    var val = changes[_attr3];\n    serverData[_attr3] = val;\n\n    if (val && (0, _typeof2.default)(val) === 'object' && !(val instanceof _ParseObject.default) && !(val instanceof _ParseFile.default) && !(val instanceof _ParseRelation.default)) {\n      var json = (0, _encode.default)(val, false, true);\n      objectCache[_attr3] = JSON.stringify(json);\n    }\n  }\n}","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar equalObjects = require('./equals').default;\n\nvar decode = require('./decode').default;\n\nvar ParseError = require('./ParseError').default;\n\nvar ParsePolygon = require('./ParsePolygon').default;\n\nvar ParseGeoPoint = require('./ParseGeoPoint').default;\n/**\n * contains -- Determines if an object is contained in a list with special handling for Parse pointers.\n */\n\n\nfunction contains(haystack, needle) {\n  if (needle && needle.__type && (needle.__type === 'Pointer' || needle.__type === 'Object')) {\n    for (var i in haystack) {\n      var ptr = haystack[i];\n\n      if (typeof ptr === 'string' && ptr === needle.objectId) {\n        return true;\n      }\n\n      if (ptr.className === needle.className && ptr.objectId === needle.objectId) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  return haystack.indexOf(needle) > -1;\n}\n\nfunction transformObject(object) {\n  if (object._toFullJSON) {\n    return object._toFullJSON();\n  }\n\n  return object;\n}\n/**\n * matchesQuery -- Determines if an object would be returned by a Parse Query\n * It's a lightweight, where-clause only implementation of a full query engine.\n * Since we find queries that match objects, rather than objects that match\n * queries, we can avoid building a full-blown query tool.\n */\n\n\nfunction matchesQuery(className, object, objects, query) {\n  if (object.className !== className) {\n    return false;\n  }\n\n  var obj = object;\n  var q = query;\n\n  if (object.toJSON) {\n    obj = object.toJSON();\n  }\n\n  if (query.toJSON) {\n    q = query.toJSON().where;\n  }\n\n  obj.className = className;\n\n  for (var field in q) {\n    if (!matchesKeyConstraints(className, obj, objects, field, q[field])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction equalObjectsGeneric(obj, compareTo, eqlFn) {\n  if (Array.isArray(obj)) {\n    for (var i = 0; i < obj.length; i++) {\n      if (eqlFn(obj[i], compareTo)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  return eqlFn(obj, compareTo);\n}\n/**\n * Determines whether an object matches a single key's constraints\n */\n\n\nfunction matchesKeyConstraints(className, object, objects, key, constraints) {\n  if (constraints === null) {\n    return false;\n  }\n\n  if (key.indexOf('.') >= 0) {\n    // Key references a subobject\n    var keyComponents = key.split('.');\n    var subObjectKey = keyComponents[0];\n    var keyRemainder = keyComponents.slice(1).join('.');\n    return matchesKeyConstraints(className, object[subObjectKey] || {}, objects, keyRemainder, constraints);\n  }\n\n  var i;\n\n  if (key === '$or') {\n    for (i = 0; i < constraints.length; i++) {\n      if (matchesQuery(className, object, objects, constraints[i])) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  if (key === '$and') {\n    for (i = 0; i < constraints.length; i++) {\n      if (!matchesQuery(className, object, objects, constraints[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  if (key === '$nor') {\n    for (i = 0; i < constraints.length; i++) {\n      if (matchesQuery(className, object, objects, constraints[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  if (key === '$relatedTo') {\n    // Bail! We can't handle relational queries locally\n    return false;\n  }\n\n  if (!/^[A-Za-z][0-9A-Za-z_]*$/.test(key)) {\n    throw new ParseError(ParseError.INVALID_KEY_NAME, \"Invalid Key: \".concat(key));\n  } // Equality (or Array contains) cases\n\n\n  if ((0, _typeof2.default)(constraints) !== 'object') {\n    if (Array.isArray(object[key])) {\n      return object[key].indexOf(constraints) > -1;\n    }\n\n    return object[key] === constraints;\n  }\n\n  var compareTo;\n\n  if (constraints.__type) {\n    if (constraints.__type === 'Pointer') {\n      return equalObjectsGeneric(object[key], constraints, function (obj, ptr) {\n        return typeof obj !== 'undefined' && ptr.className === obj.className && ptr.objectId === obj.objectId;\n      });\n    }\n\n    return equalObjectsGeneric(decode(object[key]), decode(constraints), equalObjects);\n  } // More complex cases\n\n\n  for (var condition in constraints) {\n    compareTo = constraints[condition];\n\n    if (compareTo.__type) {\n      compareTo = decode(compareTo);\n    }\n\n    if (toString.call(compareTo) === '[object Date]') {\n      object[key] = new Date(object[key]);\n    }\n\n    switch (condition) {\n      case '$lt':\n        if (object[key] >= compareTo) {\n          return false;\n        }\n\n        break;\n\n      case '$lte':\n        if (object[key] > compareTo) {\n          return false;\n        }\n\n        break;\n\n      case '$gt':\n        if (object[key] <= compareTo) {\n          return false;\n        }\n\n        break;\n\n      case '$gte':\n        if (object[key] < compareTo) {\n          return false;\n        }\n\n        break;\n\n      case '$ne':\n        if (equalObjects(object[key], compareTo)) {\n          return false;\n        }\n\n        break;\n\n      case '$in':\n        if (!contains(compareTo, object[key])) {\n          return false;\n        }\n\n        break;\n\n      case '$nin':\n        if (contains(compareTo, object[key])) {\n          return false;\n        }\n\n        break;\n\n      case '$all':\n        for (i = 0; i < compareTo.length; i++) {\n          if (object[key].indexOf(compareTo[i]) < 0) {\n            return false;\n          }\n        }\n\n        break;\n\n      case '$exists':\n        {\n          var propertyExists = typeof object[key] !== 'undefined';\n          var existenceIsRequired = constraints['$exists'];\n\n          if (typeof constraints['$exists'] !== 'boolean') {\n            // The SDK will never submit a non-boolean for $exists, but if someone\n            // tries to submit a non-boolean for $exits outside the SDKs, just ignore it.\n            break;\n          }\n\n          if (!propertyExists && existenceIsRequired || propertyExists && !existenceIsRequired) {\n            return false;\n          }\n\n          break;\n        }\n\n      case '$regex':\n        {\n          if ((0, _typeof2.default)(compareTo) === 'object') {\n            return compareTo.test(object[key]);\n          } // JS doesn't support perl-style escaping\n\n\n          var expString = '';\n          var escapeEnd = -2;\n          var escapeStart = compareTo.indexOf('\\\\Q');\n\n          while (escapeStart > -1) {\n            // Add the unescaped portion\n            expString += compareTo.substring(escapeEnd + 2, escapeStart);\n            escapeEnd = compareTo.indexOf('\\\\E', escapeStart);\n\n            if (escapeEnd > -1) {\n              expString += compareTo.substring(escapeStart + 2, escapeEnd).replace(/\\\\\\\\\\\\\\\\E/g, '\\\\E').replace(/\\W/g, '\\\\$&');\n            }\n\n            escapeStart = compareTo.indexOf('\\\\Q', escapeEnd);\n          }\n\n          expString += compareTo.substring(Math.max(escapeStart, escapeEnd + 2));\n          var modifiers = constraints.$options || '';\n          modifiers = modifiers.replace('x', '').replace('s', ''); // Parse Server / Mongo support x and s modifiers but JS RegExp doesn't\n\n          var exp = new RegExp(expString, modifiers);\n\n          if (!exp.test(object[key])) {\n            return false;\n          }\n\n          break;\n        }\n\n      case '$nearSphere':\n        {\n          if (!compareTo || !object[key]) {\n            return false;\n          }\n\n          var distance = compareTo.radiansTo(object[key]);\n          var max = constraints.$maxDistance || Infinity;\n          return distance <= max;\n        }\n\n      case '$within':\n        {\n          if (!compareTo || !object[key]) {\n            return false;\n          }\n\n          var southWest = compareTo.$box[0];\n          var northEast = compareTo.$box[1];\n\n          if (southWest.latitude > northEast.latitude || southWest.longitude > northEast.longitude) {\n            // Invalid box, crosses the date line\n            return false;\n          }\n\n          return object[key].latitude > southWest.latitude && object[key].latitude < northEast.latitude && object[key].longitude > southWest.longitude && object[key].longitude < northEast.longitude;\n        }\n\n      case '$options':\n        // Not a query type, but a way to add options to $regex. Ignore and\n        // avoid the default\n        break;\n\n      case '$maxDistance':\n        // Not a query type, but a way to add a cap to $nearSphere. Ignore and\n        // avoid the default\n        break;\n\n      case '$select':\n        {\n          var subQueryObjects = objects.filter(function (obj, index, arr) {\n            return matchesQuery(compareTo.query.className, obj, arr, compareTo.query.where);\n          });\n\n          for (var _i = 0; _i < subQueryObjects.length; _i += 1) {\n            var subObject = transformObject(subQueryObjects[_i]);\n            return equalObjects(object[key], subObject[compareTo.key]);\n          }\n\n          return false;\n        }\n\n      case '$dontSelect':\n        {\n          var _subQueryObjects = objects.filter(function (obj, index, arr) {\n            return matchesQuery(compareTo.query.className, obj, arr, compareTo.query.where);\n          });\n\n          for (var _i2 = 0; _i2 < _subQueryObjects.length; _i2 += 1) {\n            var _subObject = transformObject(_subQueryObjects[_i2]);\n\n            return !equalObjects(object[key], _subObject[compareTo.key]);\n          }\n\n          return false;\n        }\n\n      case '$inQuery':\n        {\n          var _subQueryObjects2 = objects.filter(function (obj, index, arr) {\n            return matchesQuery(compareTo.className, obj, arr, compareTo.where);\n          });\n\n          for (var _i3 = 0; _i3 < _subQueryObjects2.length; _i3 += 1) {\n            var _subObject2 = transformObject(_subQueryObjects2[_i3]);\n\n            if (object[key].className === _subObject2.className && object[key].objectId === _subObject2.objectId) {\n              return true;\n            }\n          }\n\n          return false;\n        }\n\n      case '$notInQuery':\n        {\n          var _subQueryObjects3 = objects.filter(function (obj, index, arr) {\n            return matchesQuery(compareTo.className, obj, arr, compareTo.where);\n          });\n\n          for (var _i4 = 0; _i4 < _subQueryObjects3.length; _i4 += 1) {\n            var _subObject3 = transformObject(_subQueryObjects3[_i4]);\n\n            if (object[key].className === _subObject3.className && object[key].objectId === _subObject3.objectId) {\n              return false;\n            }\n          }\n\n          return true;\n        }\n\n      case '$containedBy':\n        {\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n\n          try {\n            for (var _iterator = object[key][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var value = _step.value;\n\n              if (!contains(compareTo, value)) {\n                return false;\n              }\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return != null) {\n                _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n\n          return true;\n        }\n\n      case '$geoWithin':\n        {\n          var points = compareTo.$polygon.map(function (geoPoint) {\n            return [geoPoint.latitude, geoPoint.longitude];\n          });\n          var polygon = new ParsePolygon(points);\n          return polygon.containsPoint(object[key]);\n        }\n\n      case '$geoIntersects':\n        {\n          var _polygon = new ParsePolygon(object[key].coordinates);\n\n          var point = new ParseGeoPoint(compareTo.$point);\n          return _polygon.containsPoint(point);\n        }\n\n      default:\n        return false;\n    }\n  }\n\n  return true;\n}\n\nfunction validateQuery(query\n/*: any*/\n) {\n  var q = query;\n\n  if (query.toJSON) {\n    q = query.toJSON().where;\n  }\n\n  var specialQuerykeys = ['$and', '$or', '$nor', '_rperm', '_wperm', '_perishable_token', '_email_verify_token', '_email_verify_token_expires_at', '_account_lockout_expires_at', '_failed_login_count'];\n  Object.keys(q).forEach(function (key) {\n    if (q && q[key] && q[key].$regex) {\n      if (typeof q[key].$options === 'string') {\n        if (!q[key].$options.match(/^[imxs]+$/)) {\n          throw new ParseError(ParseError.INVALID_QUERY, \"Bad $options value for query: \".concat(q[key].$options));\n        }\n      }\n    }\n\n    if (specialQuerykeys.indexOf(key) < 0 && !key.match(/^[a-zA-Z][a-zA-Z0-9_\\.]*$/)) {\n      throw new ParseError(ParseError.INVALID_KEY_NAME, \"Invalid key name: \".concat(key));\n    }\n  });\n}\n\nvar OfflineQuery = {\n  matchesQuery: matchesQuery,\n  validateQuery: validateQuery\n};\nmodule.exports = OfflineQuery;","\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _decode = _interopRequireDefault(require(\"./decode\"));\n\nvar _encode = _interopRequireDefault(require(\"./encode\"));\n\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\n\nvar _InstallationController = _interopRequireDefault(require(\"./InstallationController\"));\n\nvar ParseOp = _interopRequireWildcard(require(\"./ParseOp\"));\n\nvar _RESTController = _interopRequireDefault(require(\"./RESTController\"));\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/**\n * Contains all Parse API classes and functions.\n * @static\n * @global\n * @class\n * @hideconstructor\n */\n\n\nvar Parse = {\n  /**\n   * Call this method first to set up your authentication tokens for Parse.\n   * You can get your keys from the Data Browser on parse.com.\n   * @param {String} applicationId Your Parse Application ID.\n   * @param {String} javaScriptKey (optional) Your Parse JavaScript Key (Not needed for parse-server)\n   * @param {String} masterKey (optional) Your Parse Master Key. (Node.js only!)\n   * @static\n   */\n  initialize: function (applicationId\n  /*: string*/\n  , javaScriptKey\n  /*: string*/\n  ) {\n    if (\"browser\" === 'browser' && _CoreManager.default.get('IS_NODE') && !undefined) {\n      /* eslint-disable no-console */\n      console.log('It looks like you\\'re using the browser version of the SDK in a ' + 'node.js environment. You should require(\\'parse/node\\') instead.');\n      /* eslint-enable no-console */\n    }\n\n    Parse._initialize(applicationId, javaScriptKey);\n  },\n  _initialize: function (applicationId\n  /*: string*/\n  , javaScriptKey\n  /*: string*/\n  , masterKey\n  /*: string*/\n  ) {\n    _CoreManager.default.set('APPLICATION_ID', applicationId);\n\n    _CoreManager.default.set('JAVASCRIPT_KEY', javaScriptKey);\n\n    _CoreManager.default.set('MASTER_KEY', masterKey);\n\n    _CoreManager.default.set('USE_MASTER_KEY', false);\n  },\n\n  /**\n   * Call this method to set your AsyncStorage engine\n   * Starting Parse@1.11, the ParseSDK do not provide a React AsyncStorage as the ReactNative module\n   * is not provided at a stable path and changes over versions.\n   * @param {AsyncStorage} storage a react native async storage.\n   * @static\n   */\n  setAsyncStorage: function (storage\n  /*: any*/\n  ) {\n    _CoreManager.default.setAsyncStorage(storage);\n  },\n\n  /**\n   * Call this method to set your LocalDatastoreStorage engine\n   * If using React-Native use {@link Parse.setAsyncStorage Parse.setAsyncStorage()}\n   * @param {LocalDatastoreController} controller a data storage.\n   * @static\n   */\n  setLocalDatastoreController: function (controller\n  /*: any*/\n  ) {\n    _CoreManager.default.setLocalDatastoreController(controller);\n  }\n};\n/** These legacy setters may eventually be deprecated **/\n\n/**\n * @member Parse.applicationId\n * @type string\n * @static\n */\n\nObject.defineProperty(Parse, 'applicationId', {\n  get: function () {\n    return _CoreManager.default.get('APPLICATION_ID');\n  },\n  set: function (value) {\n    _CoreManager.default.set('APPLICATION_ID', value);\n  }\n});\n/**\n * @member Parse.javaScriptKey\n * @type string\n * @static\n */\n\nObject.defineProperty(Parse, 'javaScriptKey', {\n  get: function () {\n    return _CoreManager.default.get('JAVASCRIPT_KEY');\n  },\n  set: function (value) {\n    _CoreManager.default.set('JAVASCRIPT_KEY', value);\n  }\n});\n/**\n * @member Parse.masterKey\n * @type string\n * @static\n */\n\nObject.defineProperty(Parse, 'masterKey', {\n  get: function () {\n    return _CoreManager.default.get('MASTER_KEY');\n  },\n  set: function (value) {\n    _CoreManager.default.set('MASTER_KEY', value);\n  }\n});\n/**\n * @member Parse.serverURL\n * @type string\n * @static\n */\n\nObject.defineProperty(Parse, 'serverURL', {\n  get: function () {\n    return _CoreManager.default.get('SERVER_URL');\n  },\n  set: function (value) {\n    _CoreManager.default.set('SERVER_URL', value);\n  }\n});\n/**\n * @member Parse.serverAuthToken\n * @type string\n * @static\n */\n\nObject.defineProperty(Parse, 'serverAuthToken', {\n  get: function () {\n    return _CoreManager.default.get('SERVER_AUTH_TOKEN');\n  },\n  set: function (value) {\n    _CoreManager.default.set('SERVER_AUTH_TOKEN', value);\n  }\n});\n/**\n * @member Parse.serverAuthType\n * @type string\n * @static\n */\n\nObject.defineProperty(Parse, 'serverAuthType', {\n  get: function () {\n    return _CoreManager.default.get('SERVER_AUTH_TYPE');\n  },\n  set: function (value) {\n    _CoreManager.default.set('SERVER_AUTH_TYPE', value);\n  }\n});\n/**\n * @member Parse.liveQueryServerURL\n * @type string\n * @static\n */\n\nObject.defineProperty(Parse, 'liveQueryServerURL', {\n  get: function () {\n    return _CoreManager.default.get('LIVEQUERY_SERVER_URL');\n  },\n  set: function (value) {\n    _CoreManager.default.set('LIVEQUERY_SERVER_URL', value);\n  }\n});\n/* End setters */\n\nParse.ACL = require('./ParseACL').default;\nParse.Analytics = require('./Analytics');\nParse.AnonymousUtils = require('./AnonymousUtils').default;\nParse.Cloud = require('./Cloud');\nParse.CoreManager = require('./CoreManager');\nParse.Config = require('./ParseConfig').default;\nParse.Error = require('./ParseError').default;\nParse.FacebookUtils = require('./FacebookUtils').default;\nParse.File = require('./ParseFile').default;\nParse.GeoPoint = require('./ParseGeoPoint').default;\nParse.Polygon = require('./ParsePolygon').default;\nParse.Installation = require('./ParseInstallation').default;\nParse.LocalDatastore = require('./LocalDatastore');\nParse.Object = require('./ParseObject').default;\nParse.Op = {\n  Set: ParseOp.SetOp,\n  Unset: ParseOp.UnsetOp,\n  Increment: ParseOp.IncrementOp,\n  Add: ParseOp.AddOp,\n  Remove: ParseOp.RemoveOp,\n  AddUnique: ParseOp.AddUniqueOp,\n  Relation: ParseOp.RelationOp\n};\nParse.Push = require('./Push');\nParse.Query = require('./ParseQuery').default;\nParse.Relation = require('./ParseRelation').default;\nParse.Role = require('./ParseRole').default;\nParse.Schema = require('./ParseSchema').default;\nParse.Session = require('./ParseSession').default;\nParse.Storage = require('./Storage');\nParse.User = require('./ParseUser').default;\nParse.LiveQuery = require('./ParseLiveQuery').default;\nParse.LiveQueryClient = require('./LiveQueryClient').default;\n\nParse._request = function () {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return _CoreManager.default.getRESTController().request.apply(null, args);\n};\n\nParse._ajax = function () {\n  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n\n  return _CoreManager.default.getRESTController().ajax.apply(null, args);\n}; // We attempt to match the signatures of the legacy versions of these methods\n\n\nParse._decode = function (_, value) {\n  return (0, _decode.default)(value);\n};\n\nParse._encode = function (value, _, disallowObjects) {\n  return (0, _encode.default)(value, disallowObjects);\n};\n\nParse._getInstallationId = function () {\n  return _CoreManager.default.getInstallationController().currentInstallationId();\n};\n/**\n * Enable pinning in your application.\n * This must be called before your application can use pinning.\n *\n * @static\n */\n\n\nParse.enableLocalDatastore = function () {\n  Parse.LocalDatastore.isEnabled = true;\n};\n/**\n * Flag that indicates whether Local Datastore is enabled.\n *\n * @static\n */\n\n\nParse.isLocalDatastoreEnabled = function () {\n  return Parse.LocalDatastore.isEnabled;\n};\n/**\n * Gets all contents from Local Datastore\n *\n * <pre>\n * await Parse.dumpLocalDatastore();\n * </pre>\n *\n * @static\n */\n\n\nParse.dumpLocalDatastore = function () {\n  if (!Parse.LocalDatastore.isEnabled) {\n    console.log('Parse.enableLocalDatastore() must be called first'); // eslint-disable-line no-console\n\n    return Promise.resolve({});\n  } else {\n    return Parse.LocalDatastore._getAllContents();\n  }\n};\n\n_CoreManager.default.setInstallationController(_InstallationController.default);\n\n_CoreManager.default.setRESTController(_RESTController.default);\n\n// For legacy requires, of the form `var Parse = require('parse').Parse`\nParse.Parse = Parse;\nmodule.exports = Parse;","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _ParseRole = _interopRequireDefault(require(\"./ParseRole\"));\n\nvar _ParseUser = _interopRequireDefault(require(\"./ParseUser\"));\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n\nvar PUBLIC_KEY = '*';\n/**\n * Creates a new ACL.\n * If no argument is given, the ACL has no permissions for anyone.\n * If the argument is a Parse.User, the ACL will have read and write\n *   permission for only that user.\n * If the argument is any other JSON object, that object will be interpretted\n *   as a serialized ACL created with toJSON().\n *\n * <p>An ACL, or Access Control List can be added to any\n * <code>Parse.Object</code> to restrict access to only a subset of users\n * of your application.</p>\n * @alias Parse.ACL\n */\n\nvar ParseACL =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param {(Parse.User|Object)} user The user to initialize the ACL for\n   */\n  function ParseACL(arg1\n  /*: ParseUser | ByIdMap*/\n  ) {\n    (0, _classCallCheck2.default)(this, ParseACL);\n    (0, _defineProperty2.default)(this, \"permissionsById\", void 0);\n    this.permissionsById = {};\n\n    if (arg1 && (0, _typeof2.default)(arg1) === 'object') {\n      if (arg1 instanceof _ParseUser.default) {\n        this.setReadAccess(arg1, true);\n        this.setWriteAccess(arg1, true);\n      } else {\n        for (var _userId in arg1) {\n          var accessList = arg1[_userId];\n\n          if (typeof _userId !== 'string') {\n            throw new TypeError('Tried to create an ACL with an invalid user id.');\n          }\n\n          this.permissionsById[_userId] = {};\n\n          for (var _permission in accessList) {\n            var allowed = accessList[_permission];\n\n            if (_permission !== 'read' && _permission !== 'write') {\n              throw new TypeError('Tried to create an ACL with an invalid permission type.');\n            }\n\n            if (typeof allowed !== 'boolean') {\n              throw new TypeError('Tried to create an ACL with an invalid permission value.');\n            }\n\n            this.permissionsById[_userId][_permission] = allowed;\n          }\n        }\n      }\n    } else if (typeof arg1 === 'function') {\n      throw new TypeError('ParseACL constructed with a function. Did you forget ()?');\n    }\n  }\n  /**\n   * Returns a JSON-encoded version of the ACL.\n   * @return {Object}\n   */\n\n\n  (0, _createClass2.default)(ParseACL, [{\n    key: \"toJSON\",\n    value: function ()\n    /*: ByIdMap*/\n    {\n      var permissions = {};\n\n      for (var p in this.permissionsById) {\n        permissions[p] = this.permissionsById[p];\n      }\n\n      return permissions;\n    }\n    /**\n     * Returns whether this ACL is equal to another object\n     * @param other The other object to compare to\n     * @return {Boolean}\n     */\n\n  }, {\n    key: \"equals\",\n    value: function (other\n    /*: ParseACL*/\n    )\n    /*: boolean*/\n    {\n      if (!(other instanceof ParseACL)) {\n        return false;\n      }\n\n      var users = Object.keys(this.permissionsById);\n      var otherUsers = Object.keys(other.permissionsById);\n\n      if (users.length !== otherUsers.length) {\n        return false;\n      }\n\n      for (var u in this.permissionsById) {\n        if (!other.permissionsById[u]) {\n          return false;\n        }\n\n        if (this.permissionsById[u].read !== other.permissionsById[u].read) {\n          return false;\n        }\n\n        if (this.permissionsById[u].write !== other.permissionsById[u].write) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_setAccess\",\n    value: function (accessType\n    /*: string*/\n    , userId\n    /*: ParseUser | ParseRole | string*/\n    , allowed\n    /*: boolean*/\n    ) {\n      if (userId instanceof _ParseUser.default) {\n        userId = userId.id;\n      } else if (userId instanceof _ParseRole.default) {\n        var name = userId.getName();\n\n        if (!name) {\n          throw new TypeError('Role must have a name');\n        }\n\n        userId = 'role:' + name;\n      }\n\n      if (typeof userId !== 'string') {\n        throw new TypeError('userId must be a string.');\n      }\n\n      if (typeof allowed !== 'boolean') {\n        throw new TypeError('allowed must be either true or false.');\n      }\n\n      var permissions = this.permissionsById[userId];\n\n      if (!permissions) {\n        if (!allowed) {\n          // The user already doesn't have this permission, so no action is needed\n          return;\n        } else {\n          permissions = {};\n          this.permissionsById[userId] = permissions;\n        }\n      }\n\n      if (allowed) {\n        this.permissionsById[userId][accessType] = true;\n      } else {\n        delete permissions[accessType];\n\n        if (Object.keys(permissions).length === 0) {\n          delete this.permissionsById[userId];\n        }\n      }\n    }\n  }, {\n    key: \"_getAccess\",\n    value: function (accessType\n    /*: string*/\n    , userId\n    /*: ParseUser | ParseRole | string*/\n    )\n    /*: boolean*/\n    {\n      if (userId instanceof _ParseUser.default) {\n        userId = userId.id;\n\n        if (!userId) {\n          throw new Error('Cannot get access for a ParseUser without an ID');\n        }\n      } else if (userId instanceof _ParseRole.default) {\n        var name = userId.getName();\n\n        if (!name) {\n          throw new TypeError('Role must have a name');\n        }\n\n        userId = 'role:' + name;\n      }\n\n      var permissions = this.permissionsById[userId];\n\n      if (!permissions) {\n        return false;\n      }\n\n      return !!permissions[accessType];\n    }\n    /**\n     * Sets whether the given user is allowed to read this object.\n     * @param userId An instance of Parse.User or its objectId.\n     * @param {Boolean} allowed Whether that user should have read access.\n     */\n\n  }, {\n    key: \"setReadAccess\",\n    value: function (userId\n    /*: ParseUser | ParseRole | string*/\n    , allowed\n    /*: boolean*/\n    ) {\n      this._setAccess('read', userId, allowed);\n    }\n    /**\n     * Get whether the given user id is *explicitly* allowed to read this object.\n     * Even if this returns false, the user may still be able to access it if\n     * getPublicReadAccess returns true or a role that the user belongs to has\n     * write access.\n     * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n     * @return {Boolean}\n     */\n\n  }, {\n    key: \"getReadAccess\",\n    value: function (userId\n    /*: ParseUser | ParseRole | string*/\n    )\n    /*: boolean*/\n    {\n      return this._getAccess('read', userId);\n    }\n    /**\n     * Sets whether the given user id is allowed to write this object.\n     * @param userId An instance of Parse.User or its objectId, or a Parse.Role..\n     * @param {Boolean} allowed Whether that user should have write access.\n     */\n\n  }, {\n    key: \"setWriteAccess\",\n    value: function (userId\n    /*: ParseUser | ParseRole | string*/\n    , allowed\n    /*: boolean*/\n    ) {\n      this._setAccess('write', userId, allowed);\n    }\n    /**\n     * Gets whether the given user id is *explicitly* allowed to write this object.\n     * Even if this returns false, the user may still be able to write it if\n     * getPublicWriteAccess returns true or a role that the user belongs to has\n     * write access.\n     * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n     * @return {Boolean}\n     */\n\n  }, {\n    key: \"getWriteAccess\",\n    value: function (userId\n    /*: ParseUser | ParseRole | string*/\n    )\n    /*: boolean*/\n    {\n      return this._getAccess('write', userId);\n    }\n    /**\n     * Sets whether the public is allowed to read this object.\n     * @param {Boolean} allowed\n     */\n\n  }, {\n    key: \"setPublicReadAccess\",\n    value: function (allowed\n    /*: boolean*/\n    ) {\n      this.setReadAccess(PUBLIC_KEY, allowed);\n    }\n    /**\n     * Gets whether the public is allowed to read this object.\n     * @return {Boolean}\n     */\n\n  }, {\n    key: \"getPublicReadAccess\",\n    value: function ()\n    /*: boolean*/\n    {\n      return this.getReadAccess(PUBLIC_KEY);\n    }\n    /**\n     * Sets whether the public is allowed to write this object.\n     * @param {Boolean} allowed\n     */\n\n  }, {\n    key: \"setPublicWriteAccess\",\n    value: function (allowed\n    /*: boolean*/\n    ) {\n      this.setWriteAccess(PUBLIC_KEY, allowed);\n    }\n    /**\n     * Gets whether the public is allowed to write this object.\n     * @return {Boolean}\n     */\n\n  }, {\n    key: \"getPublicWriteAccess\",\n    value: function ()\n    /*: boolean*/\n    {\n      return this.getWriteAccess(PUBLIC_KEY);\n    }\n    /**\n     * Gets whether users belonging to the given role are allowed\n     * to read this object. Even if this returns false, the role may\n     * still be able to write it if a parent role has read access.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @return {Boolean} true if the role has read access. false otherwise.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n\n  }, {\n    key: \"getRoleReadAccess\",\n    value: function (role\n    /*: ParseRole | string*/\n    )\n    /*: boolean*/\n    {\n      if (role instanceof _ParseRole.default) {\n        // Normalize to the String name\n        role = role.getName();\n      }\n\n      if (typeof role !== 'string') {\n        throw new TypeError('role must be a ParseRole or a String');\n      }\n\n      return this.getReadAccess('role:' + role);\n    }\n    /**\n     * Gets whether users belonging to the given role are allowed\n     * to write this object. Even if this returns false, the role may\n     * still be able to write it if a parent role has write access.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @return {Boolean} true if the role has write access. false otherwise.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n\n  }, {\n    key: \"getRoleWriteAccess\",\n    value: function (role\n    /*: ParseRole | string*/\n    )\n    /*: boolean*/\n    {\n      if (role instanceof _ParseRole.default) {\n        // Normalize to the String name\n        role = role.getName();\n      }\n\n      if (typeof role !== 'string') {\n        throw new TypeError('role must be a ParseRole or a String');\n      }\n\n      return this.getWriteAccess('role:' + role);\n    }\n    /**\n     * Sets whether users belonging to the given role are allowed\n     * to read this object.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @param {Boolean} allowed Whether the given role can read this object.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n\n  }, {\n    key: \"setRoleReadAccess\",\n    value: function (role\n    /*: ParseRole | string*/\n    , allowed\n    /*: boolean*/\n    ) {\n      if (role instanceof _ParseRole.default) {\n        // Normalize to the String name\n        role = role.getName();\n      }\n\n      if (typeof role !== 'string') {\n        throw new TypeError('role must be a ParseRole or a String');\n      }\n\n      this.setReadAccess('role:' + role, allowed);\n    }\n    /**\n     * Sets whether users belonging to the given role are allowed\n     * to write this object.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @param {Boolean} allowed Whether the given role can write this object.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n\n  }, {\n    key: \"setRoleWriteAccess\",\n    value: function (role\n    /*: ParseRole | string*/\n    , allowed\n    /*: boolean*/\n    ) {\n      if (role instanceof _ParseRole.default) {\n        // Normalize to the String name\n        role = role.getName();\n      }\n\n      if (typeof role !== 'string') {\n        throw new TypeError('role must be a ParseRole or a String');\n      }\n\n      this.setWriteAccess('role:' + role, allowed);\n    }\n  }]);\n  return ParseACL;\n}();\n\nvar _default = ParseACL;\nexports.default = _default;","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\n\nvar _decode = _interopRequireDefault(require(\"./decode\"));\n\nvar _encode = _interopRequireDefault(require(\"./encode\"));\n\nvar _escape2 = _interopRequireDefault(require(\"./escape\"));\n\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\n\nvar _Storage = _interopRequireDefault(require(\"./Storage\"));\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n/**\n * Parse.Config is a local representation of configuration data that\n * can be set from the Parse dashboard.\n *\n * @alias Parse.Config\n */\n\n\nvar ParseConfig =\n/*#__PURE__*/\nfunction () {\n  function ParseConfig() {\n    (0, _classCallCheck2.default)(this, ParseConfig);\n    (0, _defineProperty2.default)(this, \"attributes\", void 0);\n    (0, _defineProperty2.default)(this, \"_escapedAttributes\", void 0);\n    this.attributes = {};\n    this._escapedAttributes = {};\n  }\n  /**\n   * Gets the value of an attribute.\n   * @param {String} attr The name of an attribute.\n   */\n\n\n  (0, _createClass2.default)(ParseConfig, [{\n    key: \"get\",\n    value: function (attr\n    /*: string*/\n    )\n    /*: any*/\n    {\n      return this.attributes[attr];\n    }\n    /**\n     * Gets the HTML-escaped value of an attribute.\n     * @param {String} attr The name of an attribute.\n     */\n\n  }, {\n    key: \"escape\",\n    value: function (attr\n    /*: string*/\n    )\n    /*: string*/\n    {\n      var html = this._escapedAttributes[attr];\n\n      if (html) {\n        return html;\n      }\n\n      var val = this.attributes[attr];\n      var escaped = '';\n\n      if (val != null) {\n        escaped = (0, _escape2.default)(val.toString());\n      }\n\n      this._escapedAttributes[attr] = escaped;\n      return escaped;\n    }\n    /**\n     * Retrieves the most recently-fetched configuration object, either from\n     * memory or from local storage if necessary.\n     *\n     * @static\n     * @return {Config} The most recently-fetched Parse.Config if it\n     *     exists, else an empty Parse.Config.\n     */\n\n  }], [{\n    key: \"current\",\n    value: function () {\n      var controller = _CoreManager.default.getConfigController();\n\n      return controller.current();\n    }\n    /**\n     * Gets a new configuration object from the server.\n     * @static\n     * @return {Promise} A promise that is resolved with a newly-created\n     *     configuration object when the get completes.\n     */\n\n  }, {\n    key: \"get\",\n    value: function () {\n      var controller = _CoreManager.default.getConfigController();\n\n      return controller.get();\n    }\n    /**\n     * Save value keys to the server.\n     * @static\n     * @return {Promise} A promise that is resolved with a newly-created\n     *     configuration object or with the current with the update.\n     */\n\n  }, {\n    key: \"save\",\n    value: function (attrs\n    /*: { [key: string]: any }*/\n    ) {\n      var controller = _CoreManager.default.getConfigController(); //To avoid a mismatch with the local and the cloud config we get a new version\n\n\n      return controller.save(attrs).then(function () {\n        return controller.get();\n      }, function (error) {\n        return Promise.reject(error);\n      });\n    }\n  }]);\n  return ParseConfig;\n}();\n\nvar currentConfig = null;\nvar CURRENT_CONFIG_KEY = 'currentConfig';\n\nfunction decodePayload(data) {\n  try {\n    var json = JSON.parse(data);\n\n    if (json && (0, _typeof2.default)(json) === 'object') {\n      return (0, _decode.default)(json);\n    }\n  } catch (e) {\n    return null;\n  }\n}\n\nvar DefaultController = {\n  current: function () {\n    if (currentConfig) {\n      return currentConfig;\n    }\n\n    var config = new ParseConfig();\n\n    var storagePath = _Storage.default.generatePath(CURRENT_CONFIG_KEY);\n\n    var configData;\n\n    if (!_Storage.default.async()) {\n      configData = _Storage.default.getItem(storagePath);\n\n      if (configData) {\n        var attributes = decodePayload(configData);\n\n        if (attributes) {\n          config.attributes = attributes;\n          currentConfig = config;\n        }\n      }\n\n      return config;\n    } // Return a promise for async storage controllers\n\n\n    return _Storage.default.getItemAsync(storagePath).then(function (configData) {\n      if (configData) {\n        var _attributes = decodePayload(configData);\n\n        if (_attributes) {\n          config.attributes = _attributes;\n          currentConfig = config;\n        }\n      }\n\n      return config;\n    });\n  },\n  get: function () {\n    var RESTController = _CoreManager.default.getRESTController();\n\n    return RESTController.request('GET', 'config', {}, {}).then(function (response) {\n      if (!response || !response.params) {\n        var error = new _ParseError.default(_ParseError.default.INVALID_JSON, 'Config JSON response invalid.');\n        return Promise.reject(error);\n      }\n\n      var config = new ParseConfig();\n      config.attributes = {};\n\n      for (var attr in response.params) {\n        config.attributes[attr] = (0, _decode.default)(response.params[attr]);\n      }\n\n      currentConfig = config;\n      return _Storage.default.setItemAsync(_Storage.default.generatePath(CURRENT_CONFIG_KEY), JSON.stringify(response.params)).then(function () {\n        return config;\n      });\n    });\n  },\n  save: function (attrs\n  /*: { [key: string]: any }*/\n  ) {\n    var RESTController = _CoreManager.default.getRESTController();\n\n    var encodedAttrs = {};\n\n    for (var _key in attrs) {\n      encodedAttrs[_key] = (0, _encode.default)(attrs[_key]);\n    }\n\n    return RESTController.request('PUT', 'config', {\n      params: encodedAttrs\n    }, {\n      useMasterKey: true\n    }).then(function (response) {\n      if (response && response.result) {\n        return Promise.resolve();\n      } else {\n        var error = new _ParseError.default(_ParseError.default.INTERNAL_SERVER_ERROR, 'Error occured updating Config.');\n        return Promise.reject(error);\n      }\n    });\n  }\n};\n\n_CoreManager.default.setConfigController(DefaultController);\n\nvar _default = ParseConfig;\nexports.default = _default;","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _wrapNativeSuper2 = _interopRequireDefault(require(\"@babel/runtime/helpers/wrapNativeSuper\"));\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/**\n  * Constructs a new Parse.Error object with the given code and message.\n  * @alias Parse.Error\n  */\n\n\nvar ParseError =\n/*#__PURE__*/\nfunction (_Error) {\n  (0, _inherits2.default)(ParseError, _Error);\n  /**\n   * @param {Number} code An error code constant from <code>Parse.Error</code>.\n   * @param {String} message A detailed description of the error.\n   */\n\n  function ParseError(code, message) {\n    var _this;\n\n    (0, _classCallCheck2.default)(this, ParseError);\n    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(ParseError).call(this, message));\n    _this.code = code;\n    Object.defineProperty((0, _assertThisInitialized2.default)(_this), 'message', {\n      enumerable: true,\n      value: message\n    });\n    return _this;\n  }\n\n  (0, _createClass2.default)(ParseError, [{\n    key: \"toString\",\n    value: function () {\n      return 'ParseError: ' + this.code + ' ' + this.message;\n    }\n  }]);\n  return ParseError;\n}((0, _wrapNativeSuper2.default)(Error));\n/**\n * Error code indicating some error other than those enumerated here.\n * @property OTHER_CAUSE\n * @static\n * @final\n */\n\n\nParseError.OTHER_CAUSE = -1;\n/**\n * Error code indicating that something has gone wrong with the server.\n * If you get this error code, it is Parse's fault. Contact us at\n * https://parse.com/help\n * @property INTERNAL_SERVER_ERROR\n * @static\n * @final\n */\n\nParseError.INTERNAL_SERVER_ERROR = 1;\n/**\n * Error code indicating the connection to the Parse servers failed.\n * @property CONNECTION_FAILED\n * @static\n * @final\n */\n\nParseError.CONNECTION_FAILED = 100;\n/**\n * Error code indicating the specified object doesn't exist.\n * @property OBJECT_NOT_FOUND\n * @static\n * @final\n */\n\nParseError.OBJECT_NOT_FOUND = 101;\n/**\n * Error code indicating you tried to query with a datatype that doesn't\n * support it, like exact matching an array or object.\n * @property INVALID_QUERY\n * @static\n * @final\n */\n\nParseError.INVALID_QUERY = 102;\n/**\n * Error code indicating a missing or invalid classname. Classnames are\n * case-sensitive. They must start with a letter, and a-zA-Z0-9_ are the\n * only valid characters.\n * @property INVALID_CLASS_NAME\n * @static\n * @final\n */\n\nParseError.INVALID_CLASS_NAME = 103;\n/**\n * Error code indicating an unspecified object id.\n * @property MISSING_OBJECT_ID\n * @static\n * @final\n */\n\nParseError.MISSING_OBJECT_ID = 104;\n/**\n * Error code indicating an invalid key name. Keys are case-sensitive. They\n * must start with a letter, and a-zA-Z0-9_ are the only valid characters.\n * @property INVALID_KEY_NAME\n * @static\n * @final\n */\n\nParseError.INVALID_KEY_NAME = 105;\n/**\n * Error code indicating a malformed pointer. You should not see this unless\n * you have been mucking about changing internal Parse code.\n * @property INVALID_POINTER\n * @static\n * @final\n */\n\nParseError.INVALID_POINTER = 106;\n/**\n * Error code indicating that badly formed JSON was received upstream. This\n * either indicates you have done something unusual with modifying how\n * things encode to JSON, or the network is failing badly.\n * @property INVALID_JSON\n * @static\n * @final\n */\n\nParseError.INVALID_JSON = 107;\n/**\n * Error code indicating that the feature you tried to access is only\n * available internally for testing purposes.\n * @property COMMAND_UNAVAILABLE\n * @static\n * @final\n */\n\nParseError.COMMAND_UNAVAILABLE = 108;\n/**\n * You must call Parse.initialize before using the Parse library.\n * @property NOT_INITIALIZED\n * @static\n * @final\n */\n\nParseError.NOT_INITIALIZED = 109;\n/**\n * Error code indicating that a field was set to an inconsistent type.\n * @property INCORRECT_TYPE\n * @static\n * @final\n */\n\nParseError.INCORRECT_TYPE = 111;\n/**\n * Error code indicating an invalid channel name. A channel name is either\n * an empty string (the broadcast channel) or contains only a-zA-Z0-9_\n * characters and starts with a letter.\n * @property INVALID_CHANNEL_NAME\n * @static\n * @final\n */\n\nParseError.INVALID_CHANNEL_NAME = 112;\n/**\n * Error code indicating that push is misconfigured.\n * @property PUSH_MISCONFIGURED\n * @static\n * @final\n */\n\nParseError.PUSH_MISCONFIGURED = 115;\n/**\n * Error code indicating that the object is too large.\n * @property OBJECT_TOO_LARGE\n * @static\n * @final\n */\n\nParseError.OBJECT_TOO_LARGE = 116;\n/**\n * Error code indicating that the operation isn't allowed for clients.\n * @property OPERATION_FORBIDDEN\n * @static\n * @final\n */\n\nParseError.OPERATION_FORBIDDEN = 119;\n/**\n * Error code indicating the result was not found in the cache.\n * @property CACHE_MISS\n * @static\n * @final\n */\n\nParseError.CACHE_MISS = 120;\n/**\n * Error code indicating that an invalid key was used in a nested\n * JSONObject.\n * @property INVALID_NESTED_KEY\n * @static\n * @final\n */\n\nParseError.INVALID_NESTED_KEY = 121;\n/**\n * Error code indicating that an invalid filename was used for ParseFile.\n * A valid file name contains only a-zA-Z0-9_. characters and is between 1\n * and 128 characters.\n * @property INVALID_FILE_NAME\n * @static\n * @final\n */\n\nParseError.INVALID_FILE_NAME = 122;\n/**\n * Error code indicating an invalid ACL was provided.\n * @property INVALID_ACL\n * @static\n * @final\n */\n\nParseError.INVALID_ACL = 123;\n/**\n * Error code indicating that the request timed out on the server. Typically\n * this indicates that the request is too expensive to run.\n * @property TIMEOUT\n * @static\n * @final\n */\n\nParseError.TIMEOUT = 124;\n/**\n * Error code indicating that the email address was invalid.\n * @property INVALID_EMAIL_ADDRESS\n * @static\n * @final\n */\n\nParseError.INVALID_EMAIL_ADDRESS = 125;\n/**\n * Error code indicating a missing content type.\n * @property MISSING_CONTENT_TYPE\n * @static\n * @final\n */\n\nParseError.MISSING_CONTENT_TYPE = 126;\n/**\n * Error code indicating a missing content length.\n * @property MISSING_CONTENT_LENGTH\n * @static\n * @final\n */\n\nParseError.MISSING_CONTENT_LENGTH = 127;\n/**\n * Error code indicating an invalid content length.\n * @property INVALID_CONTENT_LENGTH\n * @static\n * @final\n */\n\nParseError.INVALID_CONTENT_LENGTH = 128;\n/**\n * Error code indicating a file that was too large.\n * @property FILE_TOO_LARGE\n * @static\n * @final\n */\n\nParseError.FILE_TOO_LARGE = 129;\n/**\n * Error code indicating an error saving a file.\n * @property FILE_SAVE_ERROR\n * @static\n * @final\n */\n\nParseError.FILE_SAVE_ERROR = 130;\n/**\n * Error code indicating that a unique field was given a value that is\n * already taken.\n * @property DUPLICATE_VALUE\n * @static\n * @final\n */\n\nParseError.DUPLICATE_VALUE = 137;\n/**\n * Error code indicating that a role's name is invalid.\n * @property INVALID_ROLE_NAME\n * @static\n * @final\n */\n\nParseError.INVALID_ROLE_NAME = 139;\n/**\n * Error code indicating that an application quota was exceeded.  Upgrade to\n * resolve.\n * @property EXCEEDED_QUOTA\n * @static\n * @final\n */\n\nParseError.EXCEEDED_QUOTA = 140;\n/**\n * Error code indicating that a Cloud Code script failed.\n * @property SCRIPT_FAILED\n * @static\n * @final\n */\n\nParseError.SCRIPT_FAILED = 141;\n/**\n * Error code indicating that a Cloud Code validation failed.\n * @property VALIDATION_ERROR\n * @static\n * @final\n */\n\nParseError.VALIDATION_ERROR = 142;\n/**\n * Error code indicating that invalid image data was provided.\n * @property INVALID_IMAGE_DATA\n * @static\n * @final\n */\n\nParseError.INVALID_IMAGE_DATA = 143;\n/**\n * Error code indicating an unsaved file.\n * @property UNSAVED_FILE_ERROR\n * @static\n * @final\n */\n\nParseError.UNSAVED_FILE_ERROR = 151;\n/**\n * Error code indicating an invalid push time.\n * @property INVALID_PUSH_TIME_ERROR\n * @static\n * @final\n */\n\nParseError.INVALID_PUSH_TIME_ERROR = 152;\n/**\n * Error code indicating an error deleting a file.\n * @property FILE_DELETE_ERROR\n * @static\n * @final\n */\n\nParseError.FILE_DELETE_ERROR = 153;\n/**\n * Error code indicating that the application has exceeded its request\n * limit.\n * @property REQUEST_LIMIT_EXCEEDED\n * @static\n * @final\n */\n\nParseError.REQUEST_LIMIT_EXCEEDED = 155;\n/**\n * Error code indicating an invalid event name.\n * @property INVALID_EVENT_NAME\n * @static\n * @final\n */\n\nParseError.INVALID_EVENT_NAME = 160;\n/**\n * Error code indicating that the username is missing or empty.\n * @property USERNAME_MISSING\n * @static\n * @final\n */\n\nParseError.USERNAME_MISSING = 200;\n/**\n * Error code indicating that the password is missing or empty.\n * @property PASSWORD_MISSING\n * @static\n * @final\n */\n\nParseError.PASSWORD_MISSING = 201;\n/**\n * Error code indicating that the username has already been taken.\n * @property USERNAME_TAKEN\n * @static\n * @final\n */\n\nParseError.USERNAME_TAKEN = 202;\n/**\n * Error code indicating that the email has already been taken.\n * @property EMAIL_TAKEN\n * @static\n * @final\n */\n\nParseError.EMAIL_TAKEN = 203;\n/**\n * Error code indicating that the email is missing, but must be specified.\n * @property EMAIL_MISSING\n * @static\n * @final\n */\n\nParseError.EMAIL_MISSING = 204;\n/**\n * Error code indicating that a user with the specified email was not found.\n * @property EMAIL_NOT_FOUND\n * @static\n * @final\n */\n\nParseError.EMAIL_NOT_FOUND = 205;\n/**\n * Error code indicating that a user object without a valid session could\n * not be altered.\n * @property SESSION_MISSING\n * @static\n * @final\n */\n\nParseError.SESSION_MISSING = 206;\n/**\n * Error code indicating that a user can only be created through signup.\n * @property MUST_CREATE_USER_THROUGH_SIGNUP\n * @static\n * @final\n */\n\nParseError.MUST_CREATE_USER_THROUGH_SIGNUP = 207;\n/**\n * Error code indicating that an an account being linked is already linked\n * to another user.\n * @property ACCOUNT_ALREADY_LINKED\n * @static\n * @final\n */\n\nParseError.ACCOUNT_ALREADY_LINKED = 208;\n/**\n * Error code indicating that the current session token is invalid.\n * @property INVALID_SESSION_TOKEN\n * @static\n * @final\n */\n\nParseError.INVALID_SESSION_TOKEN = 209;\n/**\n * Error code indicating that a user cannot be linked to an account because\n * that account's id could not be found.\n * @property LINKED_ID_MISSING\n * @static\n * @final\n */\n\nParseError.LINKED_ID_MISSING = 250;\n/**\n * Error code indicating that a user with a linked (e.g. Facebook) account\n * has an invalid session.\n * @property INVALID_LINKED_SESSION\n * @static\n * @final\n */\n\nParseError.INVALID_LINKED_SESSION = 251;\n/**\n * Error code indicating that a service being linked (e.g. Facebook or\n * Twitter) is unsupported.\n * @property UNSUPPORTED_SERVICE\n * @static\n * @final\n */\n\nParseError.UNSUPPORTED_SERVICE = 252;\n/**\n * Error code indicating an invalid operation occured on schema\n * @property INVALID_SCHEMA_OPERATION\n * @static\n * @final\n */\n\nParseError.INVALID_SCHEMA_OPERATION = 255;\n/**\n * Error code indicating that there were multiple errors. Aggregate errors\n * have an \"errors\" property, which is an array of error objects with more\n * detail about each error that occurred.\n * @property AGGREGATE_ERROR\n * @static\n * @final\n */\n\nParseError.AGGREGATE_ERROR = 600;\n/**\n * Error code indicating the client was unable to read an input file.\n * @property FILE_READ_ERROR\n * @static\n * @final\n */\n\nParseError.FILE_READ_ERROR = 601;\n/**\n * Error code indicating a real error code is unavailable because\n * we had to use an XDomainRequest object to allow CORS requests in\n * Internet Explorer, which strips the body from HTTP responses that have\n * a non-2XX status code.\n * @property X_DOMAIN_REQUEST\n * @static\n * @final\n */\n\nParseError.X_DOMAIN_REQUEST = 602;\nvar _default = ParseError;\nexports.default = _default;","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n/* global XMLHttpRequest, File */\n\n\nvar XHR = null;\n\nif (typeof XMLHttpRequest !== 'undefined') {\n  XHR = XMLHttpRequest;\n}\n/*:: type Base64 = { base64: string };*/\n\n/*:: type Uri = { uri: string };*/\n\n/*:: type FileData = Array<number> | Base64 | File | Uri;*/\n\n/*:: export type FileSource = {\n  format: 'file';\n  file: File;\n  type: string\n} | {\n  format: 'base64';\n  base64: string;\n  type: string\n} | {\n  format: 'uri';\n  uri: string;\n  type: string\n};*/\n\n\nvar dataUriRegexp = /^data:([a-zA-Z]+\\/[-a-zA-Z0-9+.]+)(;charset=[a-zA-Z0-9\\-\\/]*)?;base64,/;\n\nfunction b64Digit(number\n/*: number*/\n)\n/*: string*/\n{\n  if (number < 26) {\n    return String.fromCharCode(65 + number);\n  }\n\n  if (number < 52) {\n    return String.fromCharCode(97 + (number - 26));\n  }\n\n  if (number < 62) {\n    return String.fromCharCode(48 + (number - 52));\n  }\n\n  if (number === 62) {\n    return '+';\n  }\n\n  if (number === 63) {\n    return '/';\n  }\n\n  throw new TypeError('Tried to encode large digit ' + number + ' in base64.');\n}\n/**\n * A Parse.File is a local representation of a file that is saved to the Parse\n * cloud.\n * @alias Parse.File\n */\n\n\nvar ParseFile =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param name {String} The file's name. This will be prefixed by a unique\n   *     value once the file has finished saving. The file name must begin with\n   *     an alphanumeric character, and consist of alphanumeric characters,\n   *     periods, spaces, underscores, or dashes.\n   * @param data {Array} The data for the file, as either:\n   *     1. an Array of byte value Numbers, or\n   *     2. an Object like { base64: \"...\" } with a base64-encoded String.\n   *     3. an Object like { uri: \"...\" } with a uri String.\n   *     4. a File object selected with a file upload control. (3) only works\n   *        in Firefox 3.6+, Safari 6.0.2+, Chrome 7+, and IE 10+.\n   *        For example:\n   * <pre>\n   * var fileUploadControl = $(\"#profilePhotoFileUpload\")[0];\n   * if (fileUploadControl.files.length > 0) {\n   *   var file = fileUploadControl.files[0];\n   *   var name = \"photo.jpg\";\n   *   var parseFile = new Parse.File(name, file);\n   *   parseFile.save().then(function() {\n   *     // The file has been saved to Parse.\n   *   }, function(error) {\n   *     // The file either could not be read, or could not be saved to Parse.\n   *   });\n   * }</pre>\n   * @param type {String} Optional Content-Type header to use for the file. If\n   *     this is omitted, the content type will be inferred from the name's\n   *     extension.\n   */\n  function ParseFile(name\n  /*: string*/\n  , data\n  /*:: ?: FileData*/\n  , type\n  /*:: ?: string*/\n  ) {\n    (0, _classCallCheck2.default)(this, ParseFile);\n    (0, _defineProperty2.default)(this, \"_name\", void 0);\n    (0, _defineProperty2.default)(this, \"_url\", void 0);\n    (0, _defineProperty2.default)(this, \"_source\", void 0);\n    (0, _defineProperty2.default)(this, \"_previousSave\", void 0);\n    (0, _defineProperty2.default)(this, \"_data\", void 0);\n    var specifiedType = type || '';\n    this._name = name;\n\n    if (data !== undefined) {\n      if (Array.isArray(data)) {\n        this._data = ParseFile.encodeBase64(data);\n        this._source = {\n          format: 'base64',\n          base64: this._data,\n          type: specifiedType\n        };\n      } else if (typeof File !== 'undefined' && data instanceof File) {\n        this._source = {\n          format: 'file',\n          file: data,\n          type: specifiedType\n        };\n      } else if (data && typeof data.uri === 'string' && data.uri !== undefined) {\n        this._source = {\n          format: 'uri',\n          uri: data.uri,\n          type: specifiedType\n        };\n      } else if (data && typeof data.base64 === 'string') {\n        var base64 = data.base64;\n        var commaIndex = base64.indexOf(',');\n\n        if (commaIndex !== -1) {\n          var matches = dataUriRegexp.exec(base64.slice(0, commaIndex + 1)); // if data URI with type and charset, there will be 4 matches.\n\n          this._data = base64.slice(commaIndex + 1);\n          this._source = {\n            format: 'base64',\n            base64: this._data,\n            type: matches[1]\n          };\n        } else {\n          this._data = base64;\n          this._source = {\n            format: 'base64',\n            base64: base64,\n            type: specifiedType\n          };\n        }\n      } else {\n        throw new TypeError('Cannot create a Parse.File with that data.');\n      }\n    }\n  }\n  /**\n   * Return the data for the file, downloading it if not already present.\n   * Data is present if initialized with Byte Array, Base64 or Saved with Uri.\n   * Data is cleared if saved with File object selected with a file upload control\n   *\n   * @return {Promise} Promise that is resolve with base64 data\n   */\n\n\n  (0, _createClass2.default)(ParseFile, [{\n    key: \"getData\",\n    value: function () {\n      var _getData = (0, _asyncToGenerator2.default)(\n      /*#__PURE__*/\n      _regenerator.default.mark(function _callee() {\n        var controller, result;\n        return _regenerator.default.wrap(function (_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!this._data) {\n                  _context.next = 2;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", this._data);\n\n              case 2:\n                if (this._url) {\n                  _context.next = 4;\n                  break;\n                }\n\n                throw new Error('Cannot retrieve data for unsaved ParseFile.');\n\n              case 4:\n                controller = _CoreManager.default.getFileController();\n                _context.next = 7;\n                return controller.download(this._url);\n\n              case 7:\n                result = _context.sent;\n                this._data = result.base64;\n                return _context.abrupt(\"return\", this._data);\n\n              case 10:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      return function () {\n        return _getData.apply(this, arguments);\n      };\n    }()\n    /**\n     * Gets the name of the file. Before save is called, this is the filename\n     * given by the user. After save is called, that name gets prefixed with a\n     * unique identifier.\n     * @return {String}\n     */\n\n  }, {\n    key: \"name\",\n    value: function ()\n    /*: string*/\n    {\n      return this._name;\n    }\n    /**\n     * Gets the url of the file. It is only available after you save the file or\n     * after you get the file from a Parse.Object.\n     * @param {Object} options An object to specify url options\n     * @return {String}\n     */\n\n  }, {\n    key: \"url\",\n    value: function (options\n    /*:: ?: { forceSecure?: boolean }*/\n    )\n    /*: ?string*/\n    {\n      options = options || {};\n\n      if (!this._url) {\n        return;\n      }\n\n      if (options.forceSecure) {\n        return this._url.replace(/^http:\\/\\//i, 'https://');\n      } else {\n        return this._url;\n      }\n    }\n    /**\n     * Saves the file to the Parse cloud.\n     * @param {Object} options\n     *  * Valid options are:<ul>\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n     *     be used for this request.\n     *   <li>progress: In Browser only, callback for upload progress\n     * </ul>\n     * @return {Promise} Promise that is resolved when the save finishes.\n     */\n\n  }, {\n    key: \"save\",\n    value: function (options\n    /*:: ?: FullOptions*/\n    ) {\n      var _this = this;\n\n      options = options || {};\n\n      var controller = _CoreManager.default.getFileController();\n\n      if (!this._previousSave) {\n        if (this._source.format === 'file') {\n          this._previousSave = controller.saveFile(this._name, this._source, options).then(function (res) {\n            _this._name = res.name;\n            _this._url = res.url;\n            _this._data = null;\n            return _this;\n          });\n        } else if (this._source.format === 'uri') {\n          this._previousSave = controller.download(this._source.uri).then(function (result) {\n            var newSource = {\n              format: 'base64',\n              base64: result.base64,\n              type: result.contentType\n            };\n            _this._data = result.base64;\n            return controller.saveBase64(_this._name, newSource, options);\n          }).then(function (res) {\n            _this._name = res.name;\n            _this._url = res.url;\n            return _this;\n          });\n        } else {\n          this._previousSave = controller.saveBase64(this._name, this._source, options).then(function (res) {\n            _this._name = res.name;\n            _this._url = res.url;\n            return _this;\n          });\n        }\n      }\n\n      if (this._previousSave) {\n        return this._previousSave;\n      }\n    }\n  }, {\n    key: \"toJSON\",\n    value: function ()\n    /*: { name: ?string, url: ?string }*/\n    {\n      return {\n        __type: 'File',\n        name: this._name,\n        url: this._url\n      };\n    }\n  }, {\n    key: \"equals\",\n    value: function (other\n    /*: mixed*/\n    )\n    /*: boolean*/\n    {\n      if (this === other) {\n        return true;\n      } // Unsaved Files are never equal, since they will be saved to different URLs\n\n\n      return other instanceof ParseFile && this.name() === other.name() && this.url() === other.url() && typeof this.url() !== 'undefined';\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function (obj)\n    /*: ParseFile*/\n    {\n      if (obj.__type !== 'File') {\n        throw new TypeError('JSON object does not represent a ParseFile');\n      }\n\n      var file = new ParseFile(obj.name);\n      file._url = obj.url;\n      return file;\n    }\n  }, {\n    key: \"encodeBase64\",\n    value: function (bytes\n    /*: Array<number>*/\n    )\n    /*: string*/\n    {\n      var chunks = [];\n      chunks.length = Math.ceil(bytes.length / 3);\n\n      for (var i = 0; i < chunks.length; i++) {\n        var b1 = bytes[i * 3];\n        var b2 = bytes[i * 3 + 1] || 0;\n        var b3 = bytes[i * 3 + 2] || 0;\n        var has2 = i * 3 + 1 < bytes.length;\n        var has3 = i * 3 + 2 < bytes.length;\n        chunks[i] = [b64Digit(b1 >> 2 & 0x3F), b64Digit(b1 << 4 & 0x30 | b2 >> 4 & 0x0F), has2 ? b64Digit(b2 << 2 & 0x3C | b3 >> 6 & 0x03) : '=', has3 ? b64Digit(b3 & 0x3F) : '='].join('');\n      }\n\n      return chunks.join('');\n    }\n  }]);\n  return ParseFile;\n}();\n\nvar DefaultController = {\n  saveFile: function (name\n  /*: string*/\n  , source\n  /*: FileSource*/\n  , options\n  /*:: ?: FullOptions*/\n  ) {\n    if (source.format !== 'file') {\n      throw new Error('saveFile can only be used with File-type sources.');\n    } // To directly upload a File, we use a REST-style AJAX request\n\n\n    var headers = {\n      'X-Parse-Application-ID': _CoreManager.default.get('APPLICATION_ID'),\n      'Content-Type': source.type || (source.file ? source.file.type : null)\n    };\n\n    var jsKey = _CoreManager.default.get('JAVASCRIPT_KEY');\n\n    if (jsKey) {\n      headers['X-Parse-JavaScript-Key'] = jsKey;\n    }\n\n    var url = _CoreManager.default.get('SERVER_URL');\n\n    if (url[url.length - 1] !== '/') {\n      url += '/';\n    }\n\n    url += 'files/' + name;\n    return _CoreManager.default.getRESTController().ajax('POST', url, source.file, headers, options).then(function (res) {\n      return res.response;\n    });\n  },\n  saveBase64: function (name\n  /*: string*/\n  , source\n  /*: FileSource*/\n  , options\n  /*:: ?: FullOptions*/\n  ) {\n    if (source.format !== 'base64') {\n      throw new Error('saveBase64 can only be used with Base64-type sources.');\n    }\n\n    var data\n    /*: { base64: any; _ContentType?: any }*/\n    = {\n      base64: source.base64\n    };\n\n    if (source.type) {\n      data._ContentType = source.type;\n    }\n\n    return _CoreManager.default.getRESTController().request('POST', 'files/' + name, data, options);\n  },\n  download: function (uri) {\n    if (XHR) {\n      return this.downloadAjax(uri);\n    } else {\n      return Promise.reject('Cannot make a request: No definition of XMLHttpRequest was found.');\n    }\n  },\n  downloadAjax: function (uri) {\n    return new Promise(function (resolve, reject) {\n      var xhr = new XHR();\n      xhr.open('GET', uri, true);\n      xhr.responseType = 'arraybuffer';\n\n      xhr.onerror = function (e) {\n        reject(e);\n      };\n\n      xhr.onreadystatechange = function () {\n        if (xhr.readyState !== 4) {\n          return;\n        }\n\n        var bytes = new Uint8Array(this.response);\n        resolve({\n          base64: ParseFile.encodeBase64(bytes),\n          contentType: xhr.getResponseHeader('content-type')\n        });\n      };\n\n      xhr.send();\n    });\n  },\n  _setXHR: function (xhr\n  /*: any*/\n  ) {\n    XHR = xhr;\n  }\n};\n\n_CoreManager.default.setFileController(DefaultController);\n\nvar _default = ParseFile;\nexports.default = _default;","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n/**\n * Creates a new GeoPoint with any of the following forms:<br>\n *   <pre>\n *   new GeoPoint(otherGeoPoint)\n *   new GeoPoint(30, 30)\n *   new GeoPoint([30, 30])\n *   new GeoPoint({latitude: 30, longitude: 30})\n *   new GeoPoint()  // defaults to (0, 0)\n *   </pre>\n * <p>Represents a latitude / longitude point that may be associated\n * with a key in a ParseObject or used as a reference point for geo queries.\n * This allows proximity-based queries on the key.</p>\n *\n * <p>Only one key in a class may contain a GeoPoint.</p>\n *\n * <p>Example:<pre>\n *   var point = new Parse.GeoPoint(30.0, -20.0);\n *   var object = new Parse.Object(\"PlaceObject\");\n *   object.set(\"location\", point);\n *   object.save();</pre></p>\n * @alias Parse.GeoPoint\n */\n\n/* global navigator */\n\n\nvar ParseGeoPoint =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param {(Number[]|Object|Number)} options Either a list of coordinate pairs, an object with `latitude`, `longitude`, or the latitude or the point.\n   * @param {Number} longitude The longitude of the GeoPoint\n   */\n  function ParseGeoPoint(arg1\n  /*: Array<number> |\n      { latitude: number; longitude: number } |\n      number*/\n  , arg2\n  /*:: ?: number*/\n  ) {\n    (0, _classCallCheck2.default)(this, ParseGeoPoint);\n    (0, _defineProperty2.default)(this, \"_latitude\", void 0);\n    (0, _defineProperty2.default)(this, \"_longitude\", void 0);\n\n    if (Array.isArray(arg1)) {\n      ParseGeoPoint._validate(arg1[0], arg1[1]);\n\n      this._latitude = arg1[0];\n      this._longitude = arg1[1];\n    } else if ((0, _typeof2.default)(arg1) === 'object') {\n      ParseGeoPoint._validate(arg1.latitude, arg1.longitude);\n\n      this._latitude = arg1.latitude;\n      this._longitude = arg1.longitude;\n    } else if (arg1 !== undefined && arg2 !== undefined) {\n      ParseGeoPoint._validate(arg1, arg2);\n\n      this._latitude = arg1;\n      this._longitude = arg2;\n    } else {\n      this._latitude = 0;\n      this._longitude = 0;\n    }\n  }\n  /**\n   * North-south portion of the coordinate, in range [-90, 90].\n   * Throws an exception if set out of range in a modern browser.\n   * @property latitude\n   * @type Number\n   */\n\n\n  (0, _createClass2.default)(ParseGeoPoint, [{\n    key: \"toJSON\",\n\n    /**\n     * Returns a JSON representation of the GeoPoint, suitable for Parse.\n      * @return {Object}\n     */\n    value: function ()\n    /*: { __type: string; latitude: number; longitude: number }*/\n    {\n      ParseGeoPoint._validate(this._latitude, this._longitude);\n\n      return {\n        __type: 'GeoPoint',\n        latitude: this._latitude,\n        longitude: this._longitude\n      };\n    }\n  }, {\n    key: \"equals\",\n    value: function (other\n    /*: mixed*/\n    )\n    /*: boolean*/\n    {\n      return other instanceof ParseGeoPoint && this.latitude === other.latitude && this.longitude === other.longitude;\n    }\n    /**\n     * Returns the distance from this GeoPoint to another in radians.\n      * @param {Parse.GeoPoint} point the other Parse.GeoPoint.\n     * @return {Number}\n     */\n\n  }, {\n    key: \"radiansTo\",\n    value: function (point\n    /*: ParseGeoPoint*/\n    )\n    /*: number*/\n    {\n      var d2r = Math.PI / 180.0;\n      var lat1rad = this.latitude * d2r;\n      var long1rad = this.longitude * d2r;\n      var lat2rad = point.latitude * d2r;\n      var long2rad = point.longitude * d2r;\n      var sinDeltaLatDiv2 = Math.sin((lat1rad - lat2rad) / 2);\n      var sinDeltaLongDiv2 = Math.sin((long1rad - long2rad) / 2); // Square of half the straight line chord distance between both points.\n\n      var a = sinDeltaLatDiv2 * sinDeltaLatDiv2 + Math.cos(lat1rad) * Math.cos(lat2rad) * sinDeltaLongDiv2 * sinDeltaLongDiv2;\n      a = Math.min(1.0, a);\n      return 2 * Math.asin(Math.sqrt(a));\n    }\n    /**\n     * Returns the distance from this GeoPoint to another in kilometers.\n      * @param {Parse.GeoPoint} point the other Parse.GeoPoint.\n     * @return {Number}\n     */\n\n  }, {\n    key: \"kilometersTo\",\n    value: function (point\n    /*: ParseGeoPoint*/\n    )\n    /*: number*/\n    {\n      return this.radiansTo(point) * 6371.0;\n    }\n    /**\n     * Returns the distance from this GeoPoint to another in miles.\n      * @param {Parse.GeoPoint} point the other Parse.GeoPoint.\n     * @return {Number}\n     */\n\n  }, {\n    key: \"milesTo\",\n    value: function (point\n    /*: ParseGeoPoint*/\n    )\n    /*: number*/\n    {\n      return this.radiansTo(point) * 3958.8;\n    }\n    /*\n     * Throws an exception if the given lat-long is out of bounds.\n     */\n\n  }, {\n    key: \"latitude\",\n    get: function ()\n    /*: number*/\n    {\n      return this._latitude;\n    },\n    set: function (val\n    /*: number*/\n    ) {\n      ParseGeoPoint._validate(val, this.longitude);\n\n      this._latitude = val;\n    }\n    /**\n     * East-west portion of the coordinate, in range [-180, 180].\n     * Throws if set out of range in a modern browser.\n     * @property longitude\n     * @type Number\n     */\n\n  }, {\n    key: \"longitude\",\n    get: function ()\n    /*: number*/\n    {\n      return this._longitude;\n    },\n    set: function (val\n    /*: number*/\n    ) {\n      ParseGeoPoint._validate(this.latitude, val);\n\n      this._longitude = val;\n    }\n  }], [{\n    key: \"_validate\",\n    value: function (latitude\n    /*: number*/\n    , longitude\n    /*: number*/\n    ) {\n      if (isNaN(latitude) || isNaN(longitude) || typeof latitude !== 'number' || typeof longitude !== 'number') {\n        throw new TypeError('GeoPoint latitude and longitude must be valid numbers');\n      }\n\n      if (latitude < -90.0) {\n        throw new TypeError('GeoPoint latitude out of bounds: ' + latitude + ' < -90.0.');\n      }\n\n      if (latitude > 90.0) {\n        throw new TypeError('GeoPoint latitude out of bounds: ' + latitude + ' > 90.0.');\n      }\n\n      if (longitude < -180.0) {\n        throw new TypeError('GeoPoint longitude out of bounds: ' + longitude + ' < -180.0.');\n      }\n\n      if (longitude > 180.0) {\n        throw new TypeError('GeoPoint longitude out of bounds: ' + longitude + ' > 180.0.');\n      }\n    }\n    /**\n     * Creates a GeoPoint with the user's current location, if available.\n     * Calls options.success with a new GeoPoint instance or calls options.error.\n     * @static\n     */\n\n  }, {\n    key: \"current\",\n    value: function () {\n      return navigator.geolocation.getCurrentPosition(function (location) {\n        return new ParseGeoPoint(location.coords.latitude, location.coords.longitude);\n      });\n    }\n  }]);\n  return ParseGeoPoint;\n}();\n\nvar _default = ParseGeoPoint;\nexports.default = _default;","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _ParseObject2 = _interopRequireDefault(require(\"./ParseObject\"));\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n\nvar Installation =\n/*#__PURE__*/\nfunction (_ParseObject) {\n  (0, _inherits2.default)(Installation, _ParseObject);\n\n  function Installation(attributes\n  /*: ?AttributeMap*/\n  ) {\n    var _this;\n\n    (0, _classCallCheck2.default)(this, Installation);\n    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Installation).call(this, '_Installation'));\n\n    if (attributes && (0, _typeof2.default)(attributes) === 'object') {\n      if (!_this.set(attributes || {})) {\n        throw new Error('Can\\'t create an invalid Session');\n      }\n    }\n\n    return _this;\n  }\n\n  return Installation;\n}(_ParseObject2.default);\n\nexports.default = Installation;\n\n_ParseObject2.default.registerSubclass('_Installation', Installation);","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _EventEmitter = _interopRequireDefault(require(\"./EventEmitter\"));\n\nvar _LiveQueryClient = _interopRequireDefault(require(\"./LiveQueryClient\"));\n\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n\nfunction getLiveQueryClient()\n/*: LiveQueryClient*/\n{\n  return _CoreManager.default.getLiveQueryController().getDefaultLiveQueryClient();\n}\n/**\n *\n * We expose three events to help you monitor the status of the WebSocket connection:\n *\n * <p>Open - When we establish the WebSocket connection to the LiveQuery server, you'll get this event.\n *\n * <pre>\n * Parse.LiveQuery.on('open', () => {\n *\n * });</pre></p>\n *\n * <p>Close - When we lose the WebSocket connection to the LiveQuery server, you'll get this event.\n *\n * <pre>\n * Parse.LiveQuery.on('close', () => {\n *\n * });</pre></p>\n *\n * <p>Error - When some network error or LiveQuery server error happens, you'll get this event.\n *\n * <pre>\n * Parse.LiveQuery.on('error', (error) => {\n *\n * });</pre></p>\n *\n * @class Parse.LiveQuery\n * @static\n *\n */\n\n\nvar LiveQuery = new _EventEmitter.default();\n/**\n * After open is called, the LiveQuery will try to send a connect request\n * to the LiveQuery server.\n */\n\nLiveQuery.open =\n/*#__PURE__*/\n(0, _asyncToGenerator2.default)(\n/*#__PURE__*/\n_regenerator.default.mark(function _callee() {\n  var liveQueryClient;\n  return _regenerator.default.wrap(function (_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          _context.next = 2;\n          return getLiveQueryClient();\n\n        case 2:\n          liveQueryClient = _context.sent;\n          return _context.abrupt(\"return\", liveQueryClient.open());\n\n        case 4:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _callee);\n}));\n/**\n * When you're done using LiveQuery, you can call Parse.LiveQuery.close().\n * This function will close the WebSocket connection to the LiveQuery server,\n * cancel the auto reconnect, and unsubscribe all subscriptions based on it.\n * If you call query.subscribe() after this, we'll create a new WebSocket\n * connection to the LiveQuery server.\n */\n\nLiveQuery.close =\n/*#__PURE__*/\n(0, _asyncToGenerator2.default)(\n/*#__PURE__*/\n_regenerator.default.mark(function _callee2() {\n  var liveQueryClient;\n  return _regenerator.default.wrap(function (_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          _context2.next = 2;\n          return getLiveQueryClient();\n\n        case 2:\n          liveQueryClient = _context2.sent;\n          return _context2.abrupt(\"return\", liveQueryClient.close());\n\n        case 4:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, _callee2);\n})); // Register a default onError callback to make sure we do not crash on error\n\nLiveQuery.on('error', function () {});\nvar _default = LiveQuery;\nexports.default = _default;\nvar defaultLiveQueryClient;\nvar DefaultLiveQueryController = {\n  setDefaultLiveQueryClient: function (liveQueryClient\n  /*: LiveQueryClient*/\n  ) {\n    defaultLiveQueryClient = liveQueryClient;\n  },\n  getDefaultLiveQueryClient: function () {\n    var _getDefaultLiveQueryClient = (0, _asyncToGenerator2.default)(\n    /*#__PURE__*/\n    _regenerator.default.mark(function _callee3() {\n      var currentUser, sessionToken, liveQueryServerURL, serverURL, protocol, host, applicationId, javascriptKey, masterKey;\n      return _regenerator.default.wrap(function (_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              if (!defaultLiveQueryClient) {\n                _context3.next = 2;\n                break;\n              }\n\n              return _context3.abrupt(\"return\", defaultLiveQueryClient);\n\n            case 2:\n              _context3.next = 4;\n              return _CoreManager.default.getUserController().currentUserAsync();\n\n            case 4:\n              currentUser = _context3.sent;\n              sessionToken = currentUser ? currentUser.getSessionToken() : undefined;\n              liveQueryServerURL = _CoreManager.default.get('LIVEQUERY_SERVER_URL');\n\n              if (!(liveQueryServerURL && liveQueryServerURL.indexOf('ws') !== 0)) {\n                _context3.next = 9;\n                break;\n              }\n\n              throw new Error('You need to set a proper Parse LiveQuery server url before using LiveQueryClient');\n\n            case 9:\n              // If we can not find Parse.liveQueryServerURL, we try to extract it from Parse.serverURL\n              if (!liveQueryServerURL) {\n                serverURL = _CoreManager.default.get('SERVER_URL');\n                protocol = serverURL.indexOf('https') === 0 ? 'wss://' : 'ws://';\n                host = serverURL.replace(/^https?:\\/\\//, '');\n                liveQueryServerURL = protocol + host;\n\n                _CoreManager.default.set('LIVEQUERY_SERVER_URL', liveQueryServerURL);\n              }\n\n              applicationId = _CoreManager.default.get('APPLICATION_ID');\n              javascriptKey = _CoreManager.default.get('JAVASCRIPT_KEY');\n              masterKey = _CoreManager.default.get('MASTER_KEY');\n              defaultLiveQueryClient = new _LiveQueryClient.default({\n                applicationId: applicationId,\n                serverURL: liveQueryServerURL,\n                javascriptKey: javascriptKey,\n                masterKey: masterKey,\n                sessionToken: sessionToken\n              });\n              defaultLiveQueryClient.on('error', function (error) {\n                LiveQuery.emit('error', error);\n              });\n              defaultLiveQueryClient.on('open', function () {\n                LiveQuery.emit('open');\n              });\n              defaultLiveQueryClient.on('close', function () {\n                LiveQuery.emit('close');\n              });\n              return _context3.abrupt(\"return\", defaultLiveQueryClient);\n\n            case 18:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    }));\n\n    return function () {\n      return _getDefaultLiveQueryClient.apply(this, arguments);\n    };\n  }(),\n  _clearCachedDefaultClient: function () {\n    defaultLiveQueryClient = null;\n  }\n};\n\n_CoreManager.default.setLiveQueryController(DefaultLiveQueryController);","\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\n\nvar _canBeSerialized = _interopRequireDefault(require(\"./canBeSerialized\"));\n\nvar _decode = _interopRequireDefault(require(\"./decode\"));\n\nvar _encode = _interopRequireDefault(require(\"./encode\"));\n\nvar _escape2 = _interopRequireDefault(require(\"./escape\"));\n\nvar _ParseACL = _interopRequireDefault(require(\"./ParseACL\"));\n\nvar _parseDate = _interopRequireDefault(require(\"./parseDate\"));\n\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\n\nvar _ParseFile = _interopRequireDefault(require(\"./ParseFile\"));\n\nvar _promiseUtils = require(\"./promiseUtils\");\n\nvar _LocalDatastoreUtils = require(\"./LocalDatastoreUtils\");\n\nvar _ParseOp = require(\"./ParseOp\");\n\nvar _ParseQuery = _interopRequireDefault(require(\"./ParseQuery\"));\n\nvar _ParseRelation = _interopRequireDefault(require(\"./ParseRelation\"));\n\nvar SingleInstanceStateController = _interopRequireWildcard(require(\"./SingleInstanceStateController\"));\n\nvar _unique = _interopRequireDefault(require(\"./unique\"));\n\nvar UniqueInstanceStateController = _interopRequireWildcard(require(\"./UniqueInstanceStateController\"));\n\nvar _unsavedChildren = _interopRequireDefault(require(\"./unsavedChildren\"));\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n\nvar DEFAULT_BATCH_SIZE = 20; // Mapping of class names to constructors, so we can populate objects from the\n// server with appropriate subclasses of ParseObject\n\nvar classMap = {}; // Global counter for generating unique local Ids\n\nvar localCount = 0; // Global counter for generating unique Ids for non-single-instance objects\n\nvar objectCount = 0; // On web clients, objects are single-instance: any two objects with the same Id\n// will have the same attributes. However, this may be dangerous default\n// behavior in a server scenario\n\nvar singleInstance = !_CoreManager.default.get('IS_NODE');\n\nif (singleInstance) {\n  _CoreManager.default.setObjectStateController(SingleInstanceStateController);\n} else {\n  _CoreManager.default.setObjectStateController(UniqueInstanceStateController);\n}\n\nfunction getServerUrlPath() {\n  var serverUrl = _CoreManager.default.get('SERVER_URL');\n\n  if (serverUrl[serverUrl.length - 1] !== '/') {\n    serverUrl += '/';\n  }\n\n  var url = serverUrl.replace(/https?:\\/\\//, '');\n  return url.substr(url.indexOf('/'));\n}\n/**\n * Creates a new model with defined attributes.\n  *\n  * <p>You won't normally call this method directly.  It is recommended that\n  * you use a subclass of <code>Parse.Object</code> instead, created by calling\n  * <code>extend</code>.</p>\n  *\n  * <p>However, if you don't want to use a subclass, or aren't sure which\n  * subclass is appropriate, you can use this form:<pre>\n  *     var object = new Parse.Object(\"ClassName\");\n  * </pre>\n  * That is basically equivalent to:<pre>\n  *     var MyClass = Parse.Object.extend(\"ClassName\");\n  *     var object = new MyClass();\n  * </pre></p>\n  *\n * @alias Parse.Object\n */\n\n\nvar ParseObject =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param {String} className The class name for the object\n   * @param {Object} attributes The initial set of data to store in the object.\n   * @param {Object} options The options for this object instance.\n   */\n  function ParseObject(className\n  /*: ?string | { className: string, [attr: string]: mixed }*/\n  , attributes\n  /*:: ?: { [attr: string]: mixed }*/\n  , options\n  /*:: ?: { ignoreValidation: boolean }*/\n  ) {\n    (0, _classCallCheck2.default)(this, ParseObject);\n    (0, _defineProperty2.default)(this, \"id\", void 0);\n    (0, _defineProperty2.default)(this, \"_localId\", void 0);\n    (0, _defineProperty2.default)(this, \"_objCount\", void 0);\n    (0, _defineProperty2.default)(this, \"className\", void 0); // Enable legacy initializers\n\n    if (typeof this.initialize === 'function') {\n      this.initialize.apply(this, arguments);\n    }\n\n    var toSet = null;\n    this._objCount = objectCount++;\n\n    if (typeof className === 'string') {\n      this.className = className;\n\n      if (attributes && (0, _typeof2.default)(attributes) === 'object') {\n        toSet = attributes;\n      }\n    } else if (className && (0, _typeof2.default)(className) === 'object') {\n      this.className = className.className;\n      toSet = {};\n\n      for (var _attr in className) {\n        if (_attr !== 'className') {\n          toSet[_attr] = className[_attr];\n        }\n      }\n\n      if (attributes && (0, _typeof2.default)(attributes) === 'object') {\n        options = attributes;\n      }\n    }\n\n    if (toSet && !this.set(toSet, options)) {\n      throw new Error('Can\\'t create an invalid Parse Object');\n    }\n  }\n  /**\n   * The ID of this object, unique within its class.\n   * @property id\n   * @type String\n   */\n\n\n  (0, _createClass2.default)(ParseObject, [{\n    key: \"_getId\",\n\n    /** Private methods **/\n\n    /**\n     * Returns a local or server Id used uniquely identify this object\n     */\n    value: function ()\n    /*: string*/\n    {\n      if (typeof this.id === 'string') {\n        return this.id;\n      }\n\n      if (typeof this._localId === 'string') {\n        return this._localId;\n      }\n\n      var localId = 'local' + String(localCount++);\n      this._localId = localId;\n      return localId;\n    }\n    /**\n     * Returns a unique identifier used to pull data from the State Controller.\n     */\n\n  }, {\n    key: \"_getStateIdentifier\",\n    value: function ()\n    /*: ParseObject | {id: string, className: string}*/\n    {\n      if (singleInstance) {\n        var id = this.id;\n\n        if (!id) {\n          id = this._getId();\n        }\n\n        return {\n          id: id,\n          className: this.className\n        };\n      } else {\n        return this;\n      }\n    }\n  }, {\n    key: \"_getServerData\",\n    value: function ()\n    /*: AttributeMap*/\n    {\n      var stateController = _CoreManager.default.getObjectStateController();\n\n      return stateController.getServerData(this._getStateIdentifier());\n    }\n  }, {\n    key: \"_clearServerData\",\n    value: function () {\n      var serverData = this._getServerData();\n\n      var unset = {};\n\n      for (var _attr2 in serverData) {\n        unset[_attr2] = undefined;\n      }\n\n      var stateController = _CoreManager.default.getObjectStateController();\n\n      stateController.setServerData(this._getStateIdentifier(), unset);\n    }\n  }, {\n    key: \"_getPendingOps\",\n    value: function ()\n    /*: Array<OpsMap>*/\n    {\n      var stateController = _CoreManager.default.getObjectStateController();\n\n      return stateController.getPendingOps(this._getStateIdentifier());\n    }\n    /**\n     * @param {Array<string>} [keysToClear] - if specified, only ops matching\n     * these fields will be cleared\n     */\n\n  }, {\n    key: \"_clearPendingOps\",\n    value: function (keysToClear\n    /*:: ?: Array<string>*/\n    ) {\n      var pending = this._getPendingOps();\n\n      var latest = pending[pending.length - 1];\n      var keys = keysToClear || Object.keys(latest);\n      keys.forEach(function (key) {\n        delete latest[key];\n      });\n    }\n  }, {\n    key: \"_getDirtyObjectAttributes\",\n    value: function ()\n    /*: AttributeMap*/\n    {\n      var attributes = this.attributes;\n\n      var stateController = _CoreManager.default.getObjectStateController();\n\n      var objectCache = stateController.getObjectCache(this._getStateIdentifier());\n      var dirty = {};\n\n      for (var _attr3 in attributes) {\n        var val = attributes[_attr3];\n\n        if (val && (0, _typeof2.default)(val) === 'object' && !(val instanceof ParseObject) && !(val instanceof _ParseFile.default) && !(val instanceof _ParseRelation.default)) {\n          // Due to the way browsers construct maps, the key order will not change\n          // unless the object is changed\n          try {\n            var json = (0, _encode.default)(val, false, true);\n            var stringified = JSON.stringify(json);\n\n            if (objectCache[_attr3] !== stringified) {\n              dirty[_attr3] = val;\n            }\n          } catch (e) {\n            // Error occurred, possibly by a nested unsaved pointer in a mutable container\n            // No matter how it happened, it indicates a change in the attribute\n            dirty[_attr3] = val;\n          }\n        }\n      }\n\n      return dirty;\n    }\n  }, {\n    key: \"_toFullJSON\",\n    value: function (seen\n    /*:: ?: Array<any>*/\n    )\n    /*: AttributeMap*/\n    {\n      var json\n      /*: { [key: string]: mixed }*/\n      = this.toJSON(seen);\n      json.__type = 'Object';\n      json.className = this.className;\n      return json;\n    }\n  }, {\n    key: \"_getSaveJSON\",\n    value: function ()\n    /*: AttributeMap*/\n    {\n      var pending = this._getPendingOps();\n\n      var dirtyObjects = this._getDirtyObjectAttributes();\n\n      var json = {};\n\n      for (var attr in dirtyObjects) {\n        var isDotNotation = false;\n\n        for (var i = 0; i < pending.length; i += 1) {\n          for (var field in pending[i]) {\n            // Dot notation operations are handled later\n            if (field.includes('.')) {\n              var fieldName = field.split('.')[0];\n\n              if (fieldName === attr) {\n                isDotNotation = true;\n                break;\n              }\n            }\n          }\n        }\n\n        if (!isDotNotation) {\n          json[attr] = new _ParseOp.SetOp(dirtyObjects[attr]).toJSON();\n        }\n      }\n\n      for (attr in pending[0]) {\n        json[attr] = pending[0][attr].toJSON();\n      }\n\n      return json;\n    }\n  }, {\n    key: \"_getSaveParams\",\n    value: function ()\n    /*: SaveParams*/\n    {\n      var method = this.id ? 'PUT' : 'POST';\n\n      var body = this._getSaveJSON();\n\n      var path = 'classes/' + this.className;\n\n      if (this.id) {\n        path += '/' + this.id;\n      } else if (this.className === '_User') {\n        path = 'users';\n      }\n\n      return {\n        method: method,\n        body: body,\n        path: path\n      };\n    }\n  }, {\n    key: \"_finishFetch\",\n    value: function (serverData\n    /*: AttributeMap*/\n    ) {\n      if (!this.id && serverData.objectId) {\n        this.id = serverData.objectId;\n      }\n\n      var stateController = _CoreManager.default.getObjectStateController();\n\n      stateController.initializeState(this._getStateIdentifier());\n      var decoded = {};\n\n      for (var _attr4 in serverData) {\n        if (_attr4 === 'ACL') {\n          decoded[_attr4] = new _ParseACL.default(serverData[_attr4]);\n        } else if (_attr4 !== 'objectId') {\n          decoded[_attr4] = (0, _decode.default)(serverData[_attr4]);\n\n          if (decoded[_attr4] instanceof _ParseRelation.default) {\n            decoded[_attr4]._ensureParentAndKey(this, _attr4);\n          }\n        }\n      }\n\n      if (decoded.createdAt && typeof decoded.createdAt === 'string') {\n        decoded.createdAt = (0, _parseDate.default)(decoded.createdAt);\n      }\n\n      if (decoded.updatedAt && typeof decoded.updatedAt === 'string') {\n        decoded.updatedAt = (0, _parseDate.default)(decoded.updatedAt);\n      }\n\n      if (!decoded.updatedAt && decoded.createdAt) {\n        decoded.updatedAt = decoded.createdAt;\n      }\n\n      stateController.commitServerChanges(this._getStateIdentifier(), decoded);\n    }\n  }, {\n    key: \"_setExisted\",\n    value: function (existed\n    /*: boolean*/\n    ) {\n      var stateController = _CoreManager.default.getObjectStateController();\n\n      var state = stateController.getState(this._getStateIdentifier());\n\n      if (state) {\n        state.existed = existed;\n      }\n    }\n  }, {\n    key: \"_migrateId\",\n    value: function (serverId\n    /*: string*/\n    ) {\n      if (this._localId && serverId) {\n        if (singleInstance) {\n          var stateController = _CoreManager.default.getObjectStateController();\n\n          var oldState = stateController.removeState(this._getStateIdentifier());\n          this.id = serverId;\n          delete this._localId;\n\n          if (oldState) {\n            stateController.initializeState(this._getStateIdentifier(), oldState);\n          }\n        } else {\n          this.id = serverId;\n          delete this._localId;\n        }\n      }\n    }\n  }, {\n    key: \"_handleSaveResponse\",\n    value: function (response\n    /*: AttributeMap*/\n    , status\n    /*: number*/\n    ) {\n      var changes = {};\n\n      var stateController = _CoreManager.default.getObjectStateController();\n\n      var pending = stateController.popPendingState(this._getStateIdentifier());\n\n      for (var attr in pending) {\n        if (pending[attr] instanceof _ParseOp.RelationOp) {\n          changes[attr] = pending[attr].applyTo(undefined, this, attr);\n        } else if (!(attr in response)) {\n          // Only SetOps and UnsetOps should not come back with results\n          changes[attr] = pending[attr].applyTo(undefined);\n        }\n      }\n\n      for (attr in response) {\n        if ((attr === 'createdAt' || attr === 'updatedAt') && typeof response[attr] === 'string') {\n          changes[attr] = (0, _parseDate.default)(response[attr]);\n        } else if (attr === 'ACL') {\n          changes[attr] = new _ParseACL.default(response[attr]);\n        } else if (attr !== 'objectId') {\n          changes[attr] = (0, _decode.default)(response[attr]);\n\n          if (changes[attr] instanceof _ParseOp.UnsetOp) {\n            changes[attr] = undefined;\n          }\n        }\n      }\n\n      if (changes.createdAt && !changes.updatedAt) {\n        changes.updatedAt = changes.createdAt;\n      }\n\n      this._migrateId(response.objectId);\n\n      if (status !== 201) {\n        this._setExisted(true);\n      }\n\n      stateController.commitServerChanges(this._getStateIdentifier(), changes);\n    }\n  }, {\n    key: \"_handleSaveError\",\n    value: function () {\n      var stateController = _CoreManager.default.getObjectStateController();\n\n      stateController.mergeFirstPendingState(this._getStateIdentifier());\n    }\n    /** Public methods **/\n\n  }, {\n    key: \"initialize\",\n    value: function () {} // NOOP\n\n    /**\n     * Returns a JSON version of the object suitable for saving to Parse.\n     * @return {Object}\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function (seen\n    /*: Array<any> | void*/\n    )\n    /*: AttributeMap*/\n    {\n      var seenEntry = this.id ? this.className + ':' + this.id : this;\n      seen = seen || [seenEntry];\n      var json = {};\n      var attrs = this.attributes;\n\n      for (var _attr5 in attrs) {\n        if ((_attr5 === 'createdAt' || _attr5 === 'updatedAt') && attrs[_attr5].toJSON) {\n          json[_attr5] = attrs[_attr5].toJSON();\n        } else {\n          json[_attr5] = (0, _encode.default)(attrs[_attr5], false, false, seen);\n        }\n      }\n\n      var pending = this._getPendingOps();\n\n      for (var _attr6 in pending[0]) {\n        json[_attr6] = pending[0][_attr6].toJSON();\n      }\n\n      if (this.id) {\n        json.objectId = this.id;\n      }\n\n      return json;\n    }\n    /**\n     * Determines whether this ParseObject is equal to another ParseObject\n     * @param {Object} other - An other object ot compare\n     * @return {Boolean}\n     */\n\n  }, {\n    key: \"equals\",\n    value: function (other\n    /*: mixed*/\n    )\n    /*: boolean*/\n    {\n      if (this === other) {\n        return true;\n      }\n\n      return other instanceof ParseObject && this.className === other.className && this.id === other.id && typeof this.id !== 'undefined';\n    }\n    /**\n     * Returns true if this object has been modified since its last\n     * save/refresh.  If an attribute is specified, it returns true only if that\n     * particular attribute has been modified since the last save/refresh.\n     * @param {String} attr An attribute name (optional).\n     * @return {Boolean}\n     */\n\n  }, {\n    key: \"dirty\",\n    value: function (attr\n    /*:: ?: string*/\n    )\n    /*: boolean*/\n    {\n      if (!this.id) {\n        return true;\n      }\n\n      var pendingOps = this._getPendingOps();\n\n      var dirtyObjects = this._getDirtyObjectAttributes();\n\n      if (attr) {\n        if (dirtyObjects.hasOwnProperty(attr)) {\n          return true;\n        }\n\n        for (var i = 0; i < pendingOps.length; i++) {\n          if (pendingOps[i].hasOwnProperty(attr)) {\n            return true;\n          }\n        }\n\n        return false;\n      }\n\n      if (Object.keys(pendingOps[0]).length !== 0) {\n        return true;\n      }\n\n      if (Object.keys(dirtyObjects).length !== 0) {\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * Returns an array of keys that have been modified since last save/refresh\n     * @return {String[]}\n     */\n\n  }, {\n    key: \"dirtyKeys\",\n    value: function ()\n    /*: Array<string>*/\n    {\n      var pendingOps = this._getPendingOps();\n\n      var keys = {};\n\n      for (var i = 0; i < pendingOps.length; i++) {\n        for (var _attr7 in pendingOps[i]) {\n          keys[_attr7] = true;\n        }\n      }\n\n      var dirtyObjects = this._getDirtyObjectAttributes();\n\n      for (var _attr8 in dirtyObjects) {\n        keys[_attr8] = true;\n      }\n\n      return Object.keys(keys);\n    }\n    /**\n     * Gets a Pointer referencing this Object.\n     * @return {Pointer}\n     */\n\n  }, {\n    key: \"toPointer\",\n    value: function ()\n    /*: Pointer*/\n    {\n      if (!this.id) {\n        throw new Error('Cannot create a pointer to an unsaved ParseObject');\n      }\n\n      return {\n        __type: 'Pointer',\n        className: this.className,\n        objectId: this.id\n      };\n    }\n    /**\n     * Gets the value of an attribute.\n     * @param {String} attr The string name of an attribute.\n     */\n\n  }, {\n    key: \"get\",\n    value: function (attr\n    /*: string*/\n    )\n    /*: mixed*/\n    {\n      return this.attributes[attr];\n    }\n    /**\n     * Gets a relation on the given class for the attribute.\n     * @param String attr The attribute to get the relation for.\n     * @return {Parse.Relation}\n     */\n\n  }, {\n    key: \"relation\",\n    value: function (attr\n    /*: string*/\n    )\n    /*: ParseRelation*/\n    {\n      var value = this.get(attr);\n\n      if (value) {\n        if (!(value instanceof _ParseRelation.default)) {\n          throw new Error('Called relation() on non-relation field ' + attr);\n        }\n\n        value._ensureParentAndKey(this, attr);\n\n        return value;\n      }\n\n      return new _ParseRelation.default(this, attr);\n    }\n    /**\n     * Gets the HTML-escaped value of an attribute.\n     * @param {String} attr The string name of an attribute.\n     */\n\n  }, {\n    key: \"escape\",\n    value: function (attr\n    /*: string*/\n    )\n    /*: string*/\n    {\n      var val = this.attributes[attr];\n\n      if (val == null) {\n        return '';\n      }\n\n      if (typeof val !== 'string') {\n        if (typeof val.toString !== 'function') {\n          return '';\n        }\n\n        val = val.toString();\n      }\n\n      return (0, _escape2.default)(val);\n    }\n    /**\n     * Returns <code>true</code> if the attribute contains a value that is not\n     * null or undefined.\n     * @param {String} attr The string name of the attribute.\n     * @return {Boolean}\n     */\n\n  }, {\n    key: \"has\",\n    value: function (attr\n    /*: string*/\n    )\n    /*: boolean*/\n    {\n      var attributes = this.attributes;\n\n      if (attributes.hasOwnProperty(attr)) {\n        return attributes[attr] != null;\n      }\n\n      return false;\n    }\n    /**\n     * Sets a hash of model attributes on the object.\n     *\n     * <p>You can call it with an object containing keys and values, with one\n     * key and value, or dot notation.  For example:<pre>\n     *   gameTurn.set({\n     *     player: player1,\n     *     diceRoll: 2\n     *   }, {\n     *     error: function(gameTurnAgain, error) {\n     *       // The set failed validation.\n     *     }\n     *   });\n     *\n     *   game.set(\"currentPlayer\", player2, {\n     *     error: function(gameTurnAgain, error) {\n     *       // The set failed validation.\n     *     }\n     *   });\n     *\n     *   game.set(\"finished\", true);</pre></p>\n     *\n     *   game.set(\"player.score\", 10);</pre></p>\n     *\n     * @param {String} key The key to set.\n     * @param {} value The value to give it.\n     * @param {Object} options A set of options for the set.\n     *     The only supported option is <code>error</code>.\n     * @return {Boolean} true if the set succeeded.\n     */\n\n  }, {\n    key: \"set\",\n    value: function (key\n    /*: mixed*/\n    , value\n    /*: mixed*/\n    , options\n    /*:: ?: mixed*/\n    )\n    /*: ParseObject | boolean*/\n    {\n      var changes = {};\n      var newOps = {};\n\n      if (key && (0, _typeof2.default)(key) === 'object') {\n        changes = key;\n        options = value;\n      } else if (typeof key === 'string') {\n        changes[key] = value;\n      } else {\n        return this;\n      }\n\n      options = options || {};\n      var readonly = [];\n\n      if (typeof this.constructor.readOnlyAttributes === 'function') {\n        readonly = readonly.concat(this.constructor.readOnlyAttributes());\n      }\n\n      for (var k in changes) {\n        if (k === 'createdAt' || k === 'updatedAt') {\n          // This property is read-only, but for legacy reasons we silently\n          // ignore it\n          continue;\n        }\n\n        if (readonly.indexOf(k) > -1) {\n          throw new Error('Cannot modify readonly attribute: ' + k);\n        }\n\n        if (options.unset) {\n          newOps[k] = new _ParseOp.UnsetOp();\n        } else if (changes[k] instanceof _ParseOp.Op) {\n          newOps[k] = changes[k];\n        } else if (changes[k] && (0, _typeof2.default)(changes[k]) === 'object' && typeof changes[k].__op === 'string') {\n          newOps[k] = (0, _ParseOp.opFromJSON)(changes[k]);\n        } else if (k === 'objectId' || k === 'id') {\n          if (typeof changes[k] === 'string') {\n            this.id = changes[k];\n          }\n        } else if (k === 'ACL' && (0, _typeof2.default)(changes[k]) === 'object' && !(changes[k] instanceof _ParseACL.default)) {\n          newOps[k] = new _ParseOp.SetOp(new _ParseACL.default(changes[k]));\n        } else if (changes[k] instanceof _ParseRelation.default) {\n          var relation = new _ParseRelation.default(this, k);\n          relation.targetClassName = changes[k].targetClassName;\n          newOps[k] = new _ParseOp.SetOp(relation);\n        } else {\n          newOps[k] = new _ParseOp.SetOp(changes[k]);\n        }\n      }\n\n      var currentAttributes = this.attributes; // Only set nested fields if exists\n\n      var serverData = this._getServerData();\n\n      if (typeof key === 'string' && key.includes('.')) {\n        var field = key.split('.')[0];\n\n        if (!serverData[field]) {\n          return this;\n        }\n      } // Calculate new values\n\n\n      var newValues = {};\n\n      for (var _attr9 in newOps) {\n        if (newOps[_attr9] instanceof _ParseOp.RelationOp) {\n          newValues[_attr9] = newOps[_attr9].applyTo(currentAttributes[_attr9], this, _attr9);\n        } else if (!(newOps[_attr9] instanceof _ParseOp.UnsetOp)) {\n          newValues[_attr9] = newOps[_attr9].applyTo(currentAttributes[_attr9]);\n        }\n      } // Validate changes\n\n\n      if (!options.ignoreValidation) {\n        var validation = this.validate(newValues);\n\n        if (validation) {\n          if (typeof options.error === 'function') {\n            options.error(this, validation);\n          }\n\n          return false;\n        }\n      } // Consolidate Ops\n\n\n      var pendingOps = this._getPendingOps();\n\n      var last = pendingOps.length - 1;\n\n      var stateController = _CoreManager.default.getObjectStateController();\n\n      for (var _attr10 in newOps) {\n        var nextOp = newOps[_attr10].mergeWith(pendingOps[last][_attr10]);\n\n        stateController.setPendingOp(this._getStateIdentifier(), _attr10, nextOp);\n      }\n\n      return this;\n    }\n    /**\n     * Remove an attribute from the model. This is a noop if the attribute doesn't\n     * exist.\n     * @param {String} attr The string name of an attribute.\n     */\n\n  }, {\n    key: \"unset\",\n    value: function (attr\n    /*: string*/\n    , options\n    /*:: ?: { [opt: string]: mixed }*/\n    )\n    /*: ParseObject | boolean*/\n    {\n      options = options || {};\n      options.unset = true;\n      return this.set(attr, null, options);\n    }\n    /**\n     * Atomically increments the value of the given attribute the next time the\n     * object is saved. If no amount is specified, 1 is used by default.\n     *\n     * @param attr {String} The key.\n     * @param amount {Number} The amount to increment by (optional).\n     */\n\n  }, {\n    key: \"increment\",\n    value: function (attr\n    /*: string*/\n    , amount\n    /*:: ?: number*/\n    )\n    /*: ParseObject | boolean*/\n    {\n      if (typeof amount === 'undefined') {\n        amount = 1;\n      }\n\n      if (typeof amount !== 'number') {\n        throw new Error('Cannot increment by a non-numeric amount.');\n      }\n\n      return this.set(attr, new _ParseOp.IncrementOp(amount));\n    }\n    /**\n     * Atomically add an object to the end of the array associated with a given\n     * key.\n     * @param attr {String} The key.\n     * @param item {} The item to add.\n     * @return {(ParseObject|Boolean)}\n     */\n\n  }, {\n    key: \"add\",\n    value: function (attr\n    /*: string*/\n    , item\n    /*: mixed*/\n    )\n    /*: ParseObject | boolean*/\n    {\n      return this.set(attr, new _ParseOp.AddOp([item]));\n    }\n    /**\n     * Atomically add the objects to the end of the array associated with a given\n     * key.\n     * @param attr {String} The key.\n     * @param items {Object[]} The items to add.\n     */\n\n  }, {\n    key: \"addAll\",\n    value: function (attr\n    /*: string*/\n    , items\n    /*: Array<mixed>*/\n    )\n    /*: ParseObject | boolean*/\n    {\n      return this.set(attr, new _ParseOp.AddOp(items));\n    }\n    /**\n     * Atomically add an object to the array associated with a given key, only\n     * if it is not already present in the array. The position of the insert is\n     * not guaranteed.\n     *\n     * @param attr {String} The key.\n     * @param item {} The object to add.\n     */\n\n  }, {\n    key: \"addUnique\",\n    value: function (attr\n    /*: string*/\n    , item\n    /*: mixed*/\n    )\n    /*: ParseObject | boolean*/\n    {\n      return this.set(attr, new _ParseOp.AddUniqueOp([item]));\n    }\n    /**\n     * Atomically add the objects to the array associated with a given key, only\n     * if it is not already present in the array. The position of the insert is\n     * not guaranteed.\n     *\n     * @param attr {String} The key.\n     * @param items {Object[]} The objects to add.\n     */\n\n  }, {\n    key: \"addAllUnique\",\n    value: function (attr\n    /*: string*/\n    , items\n    /*: Array<mixed>*/\n    )\n    /*: ParseObject | boolean*/\n    {\n      return this.set(attr, new _ParseOp.AddUniqueOp(items));\n    }\n    /**\n     * Atomically remove all instances of an object from the array associated\n     * with a given key.\n     *\n     * @param attr {String} The key.\n     * @param item {} The object to remove.\n     */\n\n  }, {\n    key: \"remove\",\n    value: function (attr\n    /*: string*/\n    , item\n    /*: mixed*/\n    )\n    /*: ParseObject | boolean*/\n    {\n      return this.set(attr, new _ParseOp.RemoveOp([item]));\n    }\n    /**\n     * Atomically remove all instances of the objects from the array associated\n     * with a given key.\n     *\n     * @param attr {String} The key.\n     * @param items {Object[]} The object to remove.\n     */\n\n  }, {\n    key: \"removeAll\",\n    value: function (attr\n    /*: string*/\n    , items\n    /*: Array<mixed>*/\n    )\n    /*: ParseObject | boolean*/\n    {\n      return this.set(attr, new _ParseOp.RemoveOp(items));\n    }\n    /**\n     * Returns an instance of a subclass of Parse.Op describing what kind of\n     * modification has been performed on this field since the last time it was\n     * saved. For example, after calling object.increment(\"x\"), calling\n     * object.op(\"x\") would return an instance of Parse.Op.Increment.\n     *\n     * @param attr {String} The key.\n     * @returns {Parse.Op} The operation, or undefined if none.\n     */\n\n  }, {\n    key: \"op\",\n    value: function (attr\n    /*: string*/\n    )\n    /*: ?Op*/\n    {\n      var pending = this._getPendingOps();\n\n      for (var i = pending.length; i--;) {\n        if (pending[i][attr]) {\n          return pending[i][attr];\n        }\n      }\n    }\n    /**\n     * Creates a new model with identical attributes to this one.\n     * @return {Parse.Object}\n     */\n\n  }, {\n    key: \"clone\",\n    value: function clone()\n    /*: any*/\n    {\n      var clone = new this.constructor();\n\n      if (!clone.className) {\n        clone.className = this.className;\n      }\n\n      var attributes = this.attributes;\n\n      if (typeof this.constructor.readOnlyAttributes === 'function') {\n        var readonly = this.constructor.readOnlyAttributes() || []; // Attributes are frozen, so we have to rebuild an object,\n        // rather than delete readonly keys\n\n        var copy = {};\n\n        for (var a in attributes) {\n          if (readonly.indexOf(a) < 0) {\n            copy[a] = attributes[a];\n          }\n        }\n\n        attributes = copy;\n      }\n\n      if (clone.set) {\n        clone.set(attributes);\n      }\n\n      return clone;\n    }\n    /**\n     * Creates a new instance of this object. Not to be confused with clone()\n     * @return {Parse.Object}\n     */\n\n  }, {\n    key: \"newInstance\",\n    value: function ()\n    /*: any*/\n    {\n      var clone = new this.constructor();\n\n      if (!clone.className) {\n        clone.className = this.className;\n      }\n\n      clone.id = this.id;\n\n      if (singleInstance) {\n        // Just return an object with the right id\n        return clone;\n      }\n\n      var stateController = _CoreManager.default.getObjectStateController();\n\n      if (stateController) {\n        stateController.duplicateState(this._getStateIdentifier(), clone._getStateIdentifier());\n      }\n\n      return clone;\n    }\n    /**\n     * Returns true if this object has never been saved to Parse.\n     * @return {Boolean}\n     */\n\n  }, {\n    key: \"isNew\",\n    value: function ()\n    /*: boolean*/\n    {\n      return !this.id;\n    }\n    /**\n     * Returns true if this object was created by the Parse server when the\n     * object might have already been there (e.g. in the case of a Facebook\n     * login)\n     * @return {Boolean}\n     */\n\n  }, {\n    key: \"existed\",\n    value: function ()\n    /*: boolean*/\n    {\n      if (!this.id) {\n        return false;\n      }\n\n      var stateController = _CoreManager.default.getObjectStateController();\n\n      var state = stateController.getState(this._getStateIdentifier());\n\n      if (state) {\n        return state.existed;\n      }\n\n      return false;\n    }\n    /**\n     * Checks if the model is currently in a valid state.\n     * @return {Boolean}\n     */\n\n  }, {\n    key: \"isValid\",\n    value: function ()\n    /*: boolean*/\n    {\n      return !this.validate(this.attributes);\n    }\n    /**\n     * You should not call this function directly unless you subclass\n     * <code>Parse.Object</code>, in which case you can override this method\n     * to provide additional validation on <code>set</code> and\n     * <code>save</code>.  Your implementation should return\n     *\n     * @param {Object} attrs The current data to validate.\n     * @return {} False if the data is valid.  An error object otherwise.\n     * @see Parse.Object#set\n     */\n\n  }, {\n    key: \"validate\",\n    value: function (attrs\n    /*: AttributeMap*/\n    )\n    /*: ParseError | boolean*/\n    {\n      if (attrs.hasOwnProperty('ACL') && !(attrs.ACL instanceof _ParseACL.default)) {\n        return new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'ACL must be a Parse ACL.');\n      }\n\n      for (var _key in attrs) {\n        if (!/^[A-Za-z][0-9A-Za-z_.]*$/.test(_key)) {\n          return new _ParseError.default(_ParseError.default.INVALID_KEY_NAME);\n        }\n      }\n\n      return false;\n    }\n    /**\n     * Returns the ACL for this object.\n     * @returns {Parse.ACL} An instance of Parse.ACL.\n     * @see Parse.Object#get\n     */\n\n  }, {\n    key: \"getACL\",\n    value: function ()\n    /*: ?ParseACL*/\n    {\n      var acl = this.get('ACL');\n\n      if (acl instanceof _ParseACL.default) {\n        return acl;\n      }\n\n      return null;\n    }\n    /**\n     * Sets the ACL to be used for this object.\n     * @param {Parse.ACL} acl An instance of Parse.ACL.\n     * @param {Object} options\n     * @return {Boolean} Whether the set passed validation.\n     * @see Parse.Object#set\n     */\n\n  }, {\n    key: \"setACL\",\n    value: function (acl\n    /*: ParseACL*/\n    , options\n    /*:: ?: mixed*/\n    )\n    /*: ParseObject | boolean*/\n    {\n      return this.set('ACL', acl, options);\n    }\n    /**\n     * Clears any (or specific) changes to this object made since the last call to save()\n     * @param {string} [keys] - specify which fields to revert\n     */\n\n  }, {\n    key: \"revert\",\n    value: function ()\n    /*: void*/\n    {\n      var keysToRevert;\n\n      for (var _len = arguments.length, keys = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {\n        keys[_key2] = arguments[_key2];\n      }\n\n      if (keys.length) {\n        keysToRevert = [];\n\n        for (var _i = 0, _keys = keys; _i < _keys.length; _i++) {\n          var _key3 = _keys[_i];\n\n          if (typeof _key3 === \"string\") {\n            keysToRevert.push(_key3);\n          } else {\n            throw new Error(\"Parse.Object#revert expects either no, or a list of string, arguments.\");\n          }\n        }\n      }\n\n      this._clearPendingOps(keysToRevert);\n    }\n    /**\n     * Clears all attributes on a model\n     * @return {(ParseObject | boolean)}\n     */\n\n  }, {\n    key: \"clear\",\n    value: function ()\n    /*: ParseObject | boolean*/\n    {\n      var attributes = this.attributes;\n      var erasable = {};\n      var readonly = ['createdAt', 'updatedAt'];\n\n      if (typeof this.constructor.readOnlyAttributes === 'function') {\n        readonly = readonly.concat(this.constructor.readOnlyAttributes());\n      }\n\n      for (var _attr11 in attributes) {\n        if (readonly.indexOf(_attr11) < 0) {\n          erasable[_attr11] = true;\n        }\n      }\n\n      return this.set(erasable, {\n        unset: true\n      });\n    }\n    /**\n     * Fetch the model from the server. If the server's representation of the\n     * model differs from its current attributes, they will be overriden.\n     *\n     * @param {Object} options\n     * Valid options are:<ul>\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n     *     be used for this request.\n     *   <li>sessionToken: A valid session token, used for making a request on\n     *       behalf of a specific user.\n     *   <li>include: The name(s) of the key(s) to include. Can be a string, an array of strings,\n     *       or an array of array of strings.\n     * </ul>\n     * @return {Promise} A promise that is fulfilled when the fetch\n     *     completes.\n     */\n\n  }, {\n    key: \"fetch\",\n    value: function (options\n    /*: RequestOptions*/\n    )\n    /*: Promise*/\n    {\n      options = options || {};\n      var fetchOptions = {};\n\n      if (options.hasOwnProperty('useMasterKey')) {\n        fetchOptions.useMasterKey = options.useMasterKey;\n      }\n\n      if (options.hasOwnProperty('sessionToken')) {\n        fetchOptions.sessionToken = options.sessionToken;\n      }\n\n      if (options.hasOwnProperty('include')) {\n        fetchOptions.include = [];\n\n        if (Array.isArray(options.include)) {\n          options.include.forEach(function (key) {\n            if (Array.isArray(key)) {\n              fetchOptions.include = fetchOptions.include.concat(key);\n            } else {\n              fetchOptions.include.push(key);\n            }\n          });\n        } else {\n          fetchOptions.include.push(options.include);\n        }\n      }\n\n      var controller = _CoreManager.default.getObjectController();\n\n      return controller.fetch(this, true, fetchOptions);\n    }\n    /**\n     * Fetch the model from the server. If the server's representation of the\n     * model differs from its current attributes, they will be overriden.\n     *\n     * Includes nested Parse.Objects for the provided key. You can use dot\n     * notation to specify which fields in the included object are also fetched.\n     *\n     * @param {String|Array<string|Array<string>>} keys The name(s) of the key(s) to include.\n     * @param {Object} options\n     * Valid options are:<ul>\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n     *     be used for this request.\n     *   <li>sessionToken: A valid session token, used for making a request on\n     *       behalf of a specific user.\n     * </ul>\n     * @return {Promise} A promise that is fulfilled when the fetch\n     *     completes.\n     */\n\n  }, {\n    key: \"fetchWithInclude\",\n    value: function (keys\n    /*: String|Array<string|Array<string>>*/\n    , options\n    /*: RequestOptions*/\n    )\n    /*: Promise*/\n    {\n      options = options || {};\n      options.include = keys;\n      return this.fetch(options);\n    }\n    /**\n     * Set a hash of model attributes, and save the model to the server.\n     * updatedAt will be updated when the request returns.\n     * You can either call it as:<pre>\n     *   object.save();</pre>\n     * or<pre>\n     *   object.save(attrs);</pre>\n     * or<pre>\n     *   object.save(null, options);</pre>\n     * or<pre>\n     *   object.save(attrs, options);</pre>\n     * or<pre>\n     *   object.save(key, value, options);</pre>\n     *\n     * For example, <pre>\n     *   gameTurn.save({\n     *     player: \"Jake Cutter\",\n     *     diceRoll: 2\n     *   }).then(function(gameTurnAgain) {\n     *     // The save was successful.\n     *   }, function(error) {\n     *     // The save failed.  Error is an instance of Parse.Error.\n     *   });</pre>\n     *\n     * @param {String|Object|null} [attrs]\n     * Valid options are:<ul>\n     *   <li>`Object` - Key/value pairs to update on the object.</li>\n     *   <li>`String` Key - Key of attribute to update (requires arg2 to also be string)</li>\n     *   <li>`null` - Passing null for arg1 allows you to save the object with options passed in arg2.</li>\n     * </ul>\n     *\n     * @param {String|Object} [options]\n     * <ul>\n     *   <li>`String` Value - If arg1 was passed as a key, arg2 is the value that should be set on that key.</li>\n     *   <li>`Object` Options - Valid options are:\n     *     <ul>\n     *       <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n     *     be used for this request.\n     *       <li>sessionToken: A valid session token, used for making a request on\n     *       behalf of a specific user.\n     *     </ul>\n     *   </li>\n     * </ul>\n     *\n     * @param {Object} [options]\n     * Used to pass option parameters to method if arg1 and arg2 were both passed as strings.\n     * Valid options are:\n     * <ul>\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n     *       be used for this request.\n     *   <li>sessionToken: A valid session token, used for making a request on\n     *       behalf of a specific user.\n     * </ul>\n     *\n     * @return {Promise} A promise that is fulfilled when the save\n     *     completes.\n     */\n\n  }, {\n    key: \"save\",\n    value: function (arg1\n    /*: ?string | { [attr: string]: mixed }*/\n    , arg2\n    /*: FullOptions | mixed*/\n    , arg3\n    /*:: ?: FullOptions*/\n    )\n    /*: Promise*/\n    {\n      var _this = this;\n\n      var attrs;\n      var options;\n\n      if ((0, _typeof2.default)(arg1) === 'object' || typeof arg1 === 'undefined') {\n        attrs = arg1;\n\n        if ((0, _typeof2.default)(arg2) === 'object') {\n          options = arg2;\n        }\n      } else {\n        attrs = {};\n        attrs[arg1] = arg2;\n        options = arg3;\n      } // TODO: safely remove me\n      // Support save({ success: function() {}, error: function() {} })\n\n\n      if (!options && attrs) {\n        options = {};\n\n        if (typeof attrs.success === 'function') {\n          options.success = attrs.success;\n          delete attrs.success;\n        }\n\n        if (typeof attrs.error === 'function') {\n          options.error = attrs.error;\n          delete attrs.error;\n        }\n      }\n\n      if (attrs) {\n        var validation = this.validate(attrs);\n\n        if (validation) {\n          if (options && typeof options.error === 'function') {\n            options.error(this, validation);\n          }\n\n          return Promise.reject(validation);\n        }\n\n        this.set(attrs, options);\n      }\n\n      options = options || {};\n      var saveOptions = {};\n\n      if (options.hasOwnProperty('useMasterKey')) {\n        saveOptions.useMasterKey = !!options.useMasterKey;\n      }\n\n      if (options.hasOwnProperty('sessionToken') && typeof options.sessionToken === 'string') {\n        saveOptions.sessionToken = options.sessionToken;\n      }\n\n      var controller = _CoreManager.default.getObjectController();\n\n      var unsaved = (0, _unsavedChildren.default)(this);\n      return controller.save(unsaved, saveOptions).then(function () {\n        return controller.save(_this, saveOptions);\n      });\n    }\n    /**\n     * Destroy this model on the server if it was already persisted.\n     *\n     * @param {Object} options\n     * Valid options are:<ul>\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n     *     be used for this request.\n     *   <li>sessionToken: A valid session token, used for making a request on\n     *       behalf of a specific user.\n     * </ul>\n     * @return {Promise} A promise that is fulfilled when the destroy\n     *     completes.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function (options\n    /*: RequestOptions*/\n    )\n    /*: Promise*/\n    {\n      options = options || {};\n      var destroyOptions = {};\n\n      if (options.hasOwnProperty('useMasterKey')) {\n        destroyOptions.useMasterKey = options.useMasterKey;\n      }\n\n      if (options.hasOwnProperty('sessionToken')) {\n        destroyOptions.sessionToken = options.sessionToken;\n      }\n\n      if (!this.id) {\n        return Promise.resolve();\n      }\n\n      return _CoreManager.default.getObjectController().destroy(this, destroyOptions);\n    }\n    /**\n     * Asynchronously stores the object and every object it points to in the local datastore,\n     * recursively, using a default pin name: _default.\n     *\n     * If those other objects have not been fetched from Parse, they will not be stored.\n     * However, if they have changed data, all the changes will be retained.\n     *\n     * <pre>\n     * await object.pin();\n     * </pre>\n     *\n     * To retrieve object:\n     * <code>query.fromLocalDatastore()</code> or <code>query.fromPin()</code>\n     *\n     * @return {Promise} A promise that is fulfilled when the pin completes.\n     */\n\n  }, {\n    key: \"pin\",\n    value: function ()\n    /*: Promise<void>*/\n    {\n      return ParseObject.pinAllWithName(_LocalDatastoreUtils.DEFAULT_PIN, [this]);\n    }\n    /**\n     * Asynchronously removes the object and every object it points to in the local datastore,\n     * recursively, using a default pin name: _default.\n     *\n     * <pre>\n     * await object.unPin();\n     * </pre>\n     *\n     * @return {Promise} A promise that is fulfilled when the unPin completes.\n     */\n\n  }, {\n    key: \"unPin\",\n    value: function ()\n    /*: Promise<void>*/\n    {\n      return ParseObject.unPinAllWithName(_LocalDatastoreUtils.DEFAULT_PIN, [this]);\n    }\n    /**\n     * Asynchronously returns if the object is pinned\n     *\n     * <pre>\n     * const isPinned = await object.isPinned();\n     * </pre>\n     *\n     * @return {Promise<boolean>} A boolean promise that is fulfilled if object is pinned.\n     */\n\n  }, {\n    key: \"isPinned\",\n    value: function () {\n      var _isPinned = (0, _asyncToGenerator2.default)(\n      /*#__PURE__*/\n      _regenerator.default.mark(function _callee() {\n        var localDatastore, objectKey, pin;\n        return _regenerator.default.wrap(function (_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                localDatastore = _CoreManager.default.getLocalDatastore();\n\n                if (localDatastore.isEnabled) {\n                  _context.next = 3;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", Promise.reject('Parse.enableLocalDatastore() must be called first'));\n\n              case 3:\n                objectKey = localDatastore.getKeyForObject(this);\n                _context.next = 6;\n                return localDatastore.fromPinWithName(objectKey);\n\n              case 6:\n                pin = _context.sent;\n                return _context.abrupt(\"return\", pin.length > 0);\n\n              case 8:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      return function () {\n        return _isPinned.apply(this, arguments);\n      };\n    }()\n    /**\n     * Asynchronously stores the objects and every object they point to in the local datastore, recursively.\n     *\n     * If those other objects have not been fetched from Parse, they will not be stored.\n     * However, if they have changed data, all the changes will be retained.\n     *\n     * <pre>\n     * await object.pinWithName(name);\n     * </pre>\n     *\n     * To retrieve object:\n     * <code>query.fromLocalDatastore()</code> or <code>query.fromPinWithName(name)</code>\n     *\n     * @param {String} name Name of Pin.\n     * @return {Promise} A promise that is fulfilled when the pin completes.\n     */\n\n  }, {\n    key: \"pinWithName\",\n    value: function (name\n    /*: string*/\n    )\n    /*: Promise<void>*/\n    {\n      return ParseObject.pinAllWithName(name, [this]);\n    }\n    /**\n     * Asynchronously removes the object and every object it points to in the local datastore, recursively.\n     *\n     * <pre>\n     * await object.unPinWithName(name);\n     * </pre>\n     *\n     * @param {String} name Name of Pin.\n     * @return {Promise} A promise that is fulfilled when the unPin completes.\n     */\n\n  }, {\n    key: \"unPinWithName\",\n    value: function (name\n    /*: string*/\n    )\n    /*: Promise<void>*/\n    {\n      return ParseObject.unPinAllWithName(name, [this]);\n    }\n    /**\n     * Asynchronously loads data from the local datastore into this object.\n     *\n     * <pre>\n     * await object.fetchFromLocalDatastore();\n     * </pre>\n     *\n     * You can create an unfetched pointer with <code>Parse.Object.createWithoutData()</code>\n     * and then call <code>fetchFromLocalDatastore()</code> on it.\n     *\n     * @return {Promise} A promise that is fulfilled when the fetch completes.\n     */\n\n  }, {\n    key: \"fetchFromLocalDatastore\",\n    value: function () {\n      var _fetchFromLocalDatastore = (0, _asyncToGenerator2.default)(\n      /*#__PURE__*/\n      _regenerator.default.mark(function _callee2() {\n        var localDatastore, objectKey, pinned, result;\n        return _regenerator.default.wrap(function (_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                localDatastore = _CoreManager.default.getLocalDatastore();\n\n                if (localDatastore.isEnabled) {\n                  _context2.next = 3;\n                  break;\n                }\n\n                throw new Error('Parse.enableLocalDatastore() must be called first');\n\n              case 3:\n                objectKey = localDatastore.getKeyForObject(this);\n                _context2.next = 6;\n                return localDatastore._serializeObject(objectKey);\n\n              case 6:\n                pinned = _context2.sent;\n\n                if (pinned) {\n                  _context2.next = 9;\n                  break;\n                }\n\n                throw new Error('Cannot fetch an unsaved ParseObject');\n\n              case 9:\n                result = ParseObject.fromJSON(pinned);\n\n                this._finishFetch(result.toJSON());\n\n                return _context2.abrupt(\"return\", this);\n\n              case 12:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      return function () {\n        return _fetchFromLocalDatastore.apply(this, arguments);\n      };\n    }()\n    /** Static methods **/\n\n  }, {\n    key: \"attributes\",\n\n    /** Prototype getters / setters **/\n    get: function ()\n    /*: AttributeMap*/\n    {\n      var stateController = _CoreManager.default.getObjectStateController();\n\n      return Object.freeze(stateController.estimateAttributes(this._getStateIdentifier()));\n    }\n    /**\n     * The first time this object was saved on the server.\n     * @property createdAt\n     * @type Date\n     */\n\n  }, {\n    key: \"createdAt\",\n    get: function ()\n    /*: ?Date*/\n    {\n      return this._getServerData().createdAt;\n    }\n    /**\n     * The last time this object was updated on the server.\n     * @property updatedAt\n     * @type Date\n     */\n\n  }, {\n    key: \"updatedAt\",\n    get: function ()\n    /*: ?Date*/\n    {\n      return this._getServerData().updatedAt;\n    }\n  }], [{\n    key: \"_clearAllState\",\n    value: function () {\n      var stateController = _CoreManager.default.getObjectStateController();\n\n      stateController.clearAllState();\n    }\n    /**\n     * Fetches the given list of Parse.Object.\n     * If any error is encountered, stops and calls the error handler.\n     *\n     * <pre>\n     *   Parse.Object.fetchAll([object1, object2, ...])\n     *    .then((list) => {\n     *      // All the objects were fetched.\n     *    }, (error) => {\n     *      // An error occurred while fetching one of the objects.\n     *    });\n     * </pre>\n     *\n     * @param {Array} list A list of <code>Parse.Object</code>.\n     * @param {Object} options\n     * Valid options are:<ul>\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n     *     be used for this request.\n     *   <li>sessionToken: A valid session token, used for making a request on\n     *       behalf of a specific user.\n     *   <li>include: The name(s) of the key(s) to include. Can be a string, an array of strings,\n     *       or an array of array of strings.\n     * </ul>\n     * @static\n     */\n\n  }, {\n    key: \"fetchAll\",\n    value: function (list\n    /*: Array<ParseObject>*/\n    ) {\n      var options\n      /*: RequestOptions*/\n      = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var queryOptions = {};\n\n      if (options.hasOwnProperty('useMasterKey')) {\n        queryOptions.useMasterKey = options.useMasterKey;\n      }\n\n      if (options.hasOwnProperty('sessionToken')) {\n        queryOptions.sessionToken = options.sessionToken;\n      }\n\n      if (options.hasOwnProperty('include')) {\n        queryOptions.include = [];\n\n        if (Array.isArray(options.include)) {\n          options.include.forEach(function (key) {\n            if (Array.isArray(key)) {\n              queryOptions.include = queryOptions.include.concat(key);\n            } else {\n              queryOptions.include.push(key);\n            }\n          });\n        } else {\n          queryOptions.include.push(options.include);\n        }\n      }\n\n      return _CoreManager.default.getObjectController().fetch(list, true, queryOptions);\n    }\n    /**\n     * Fetches the given list of Parse.Object.\n     *\n     * Includes nested Parse.Objects for the provided key. You can use dot\n     * notation to specify which fields in the included object are also fetched.\n     *\n     * If any error is encountered, stops and calls the error handler.\n     *\n     * <pre>\n     *   Parse.Object.fetchAllWithInclude([object1, object2, ...], [pointer1, pointer2, ...])\n     *    .then((list) => {\n     *      // All the objects were fetched.\n     *    }, (error) => {\n     *      // An error occurred while fetching one of the objects.\n     *    });\n     * </pre>\n     *\n     * @param {Array} list A list of <code>Parse.Object</code>.\n     * @param {String|Array<string|Array<string>>} keys The name(s) of the key(s) to include.\n     * @param {Object} options\n     * Valid options are:<ul>\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n     *     be used for this request.\n     *   <li>sessionToken: A valid session token, used for making a request on\n     *       behalf of a specific user.\n     * </ul>\n     * @static\n     */\n\n  }, {\n    key: \"fetchAllWithInclude\",\n    value: function (list\n    /*: Array<ParseObject>*/\n    , keys\n    /*: String|Array<string|Array<string>>*/\n    , options\n    /*: RequestOptions*/\n    ) {\n      options = options || {};\n      options.include = keys;\n      return ParseObject.fetchAll(list, options);\n    }\n    /**\n     * Fetches the given list of Parse.Object if needed.\n     * If any error is encountered, stops and calls the error handler.\n     *\n     * <pre>\n     *   Parse.Object.fetchAllIfNeeded([object1, ...])\n     *    .then((list) => {\n     *      // Objects were fetched and updated.\n     *    }, (error) => {\n     *      // An error occurred while fetching one of the objects.\n     *    });\n     * </pre>\n     *\n     * @param {Array} list A list of <code>Parse.Object</code>.\n     * @param {Object} options\n     * @static\n     */\n\n  }, {\n    key: \"fetchAllIfNeeded\",\n    value: function (list\n    /*: Array<ParseObject>*/\n    , options) {\n      options = options || {};\n      var queryOptions = {};\n\n      if (options.hasOwnProperty('useMasterKey')) {\n        queryOptions.useMasterKey = options.useMasterKey;\n      }\n\n      if (options.hasOwnProperty('sessionToken')) {\n        queryOptions.sessionToken = options.sessionToken;\n      }\n\n      return _CoreManager.default.getObjectController().fetch(list, false, queryOptions);\n    }\n    /**\n     * Destroy the given list of models on the server if it was already persisted.\n     *\n     * <p>Unlike saveAll, if an error occurs while deleting an individual model,\n     * this method will continue trying to delete the rest of the models if\n     * possible, except in the case of a fatal error like a connection error.\n     *\n     * <p>In particular, the Parse.Error object returned in the case of error may\n     * be one of two types:\n     *\n     * <ul>\n     *   <li>A Parse.Error.AGGREGATE_ERROR. This object's \"errors\" property is an\n     *       array of other Parse.Error objects. Each error object in this array\n     *       has an \"object\" property that references the object that could not be\n     *       deleted (for instance, because that object could not be found).</li>\n     *   <li>A non-aggregate Parse.Error. This indicates a serious error that\n     *       caused the delete operation to be aborted partway through (for\n     *       instance, a connection failure in the middle of the delete).</li>\n     * </ul>\n     *\n     * <pre>\n     *   Parse.Object.destroyAll([object1, object2, ...])\n     *    .then((list) => {\n     *      // All the objects were deleted.\n     *    }, (error) => {\n     *      // An error occurred while deleting one or more of the objects.\n     *      // If this is an aggregate error, then we can inspect each error\n     *      // object individually to determine the reason why a particular\n     *      // object was not deleted.\n     *      if (error.code === Parse.Error.AGGREGATE_ERROR) {\n     *        for (var i = 0; i < error.errors.length; i++) {\n     *          console.log(\"Couldn't delete \" + error.errors[i].object.id +\n     *            \"due to \" + error.errors[i].message);\n     *        }\n     *      } else {\n     *        console.log(\"Delete aborted because of \" + error.message);\n     *      }\n     *   });\n     * </pre>\n     *\n     * @param {Array} list A list of <code>Parse.Object</code>.\n     * @param {Object} options\n     * @static\n     * Valid options are:<ul>\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n     *     be used for this request.\n     *   <li>sessionToken: A valid session token, used for making a request on\n     *       behalf of a specific user.\n     *   <li>batchSize: Number of objects to process per request\n     * </ul>\n     * @return {Promise} A promise that is fulfilled when the destroyAll\n     *     completes.\n     */\n\n  }, {\n    key: \"destroyAll\",\n    value: function (list\n    /*: Array<ParseObject>*/\n    ) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var destroyOptions = {};\n\n      if (options.hasOwnProperty('useMasterKey')) {\n        destroyOptions.useMasterKey = options.useMasterKey;\n      }\n\n      if (options.hasOwnProperty('sessionToken')) {\n        destroyOptions.sessionToken = options.sessionToken;\n      }\n\n      if (options.hasOwnProperty('batchSize') && typeof options.batchSize === 'number') {\n        destroyOptions.batchSize = options.batchSize;\n      }\n\n      return _CoreManager.default.getObjectController().destroy(list, destroyOptions);\n    }\n    /**\n     * Saves the given list of Parse.Object.\n     * If any error is encountered, stops and calls the error handler.\n     *\n     * <pre>\n     *   Parse.Object.saveAll([object1, object2, ...])\n     *    .then((list) => {\n     *       // All the objects were saved.\n     *    }, (error) => {\n     *       // An error occurred while saving one of the objects.\n     *    });\n     * </pre>\n     *\n     * @param {Array} list A list of <code>Parse.Object</code>.\n     * @param {Object} options\n     * @static\n     * Valid options are:<ul>\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n     *     be used for this request.\n     *   <li>sessionToken: A valid session token, used for making a request on\n     *       behalf of a specific user.\n     *   <li>batchSize: Number of objects to process per request\n     * </ul>\n     */\n\n  }, {\n    key: \"saveAll\",\n    value: function (list\n    /*: Array<ParseObject>*/\n    ) {\n      var options\n      /*: RequestOptions*/\n      = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var saveOptions = {};\n\n      if (options.hasOwnProperty('useMasterKey')) {\n        saveOptions.useMasterKey = options.useMasterKey;\n      }\n\n      if (options.hasOwnProperty('sessionToken')) {\n        saveOptions.sessionToken = options.sessionToken;\n      }\n\n      if (options.hasOwnProperty('batchSize') && typeof options.batchSize === 'number') {\n        saveOptions.batchSize = options.batchSize;\n      }\n\n      return _CoreManager.default.getObjectController().save(list, saveOptions);\n    }\n    /**\n     * Creates a reference to a subclass of Parse.Object with the given id. This\n     * does not exist on Parse.Object, only on subclasses.\n     *\n     * <p>A shortcut for: <pre>\n     *  var Foo = Parse.Object.extend(\"Foo\");\n     *  var pointerToFoo = new Foo();\n     *  pointerToFoo.id = \"myObjectId\";\n     * </pre>\n     *\n     * @param {String} id The ID of the object to create a reference to.\n     * @static\n     * @return {Parse.Object} A Parse.Object reference.\n     */\n\n  }, {\n    key: \"createWithoutData\",\n    value: function (id\n    /*: string*/\n    ) {\n      var obj = new this();\n      obj.id = id;\n      return obj;\n    }\n    /**\n     * Creates a new instance of a Parse Object from a JSON representation.\n     * @param {Object} json The JSON map of the Object's data\n     * @param {boolean} override In single instance mode, all old server data\n     *   is overwritten if this is set to true\n     * @static\n     * @return {Parse.Object} A Parse.Object reference\n     */\n\n  }, {\n    key: \"fromJSON\",\n    value: function (json\n    /*: any*/\n    , override\n    /*:: ?: boolean*/\n    ) {\n      if (!json.className) {\n        throw new Error('Cannot create an object without a className');\n      }\n\n      var constructor = classMap[json.className];\n      var o = constructor ? new constructor() : new ParseObject(json.className);\n      var otherAttributes = {};\n\n      for (var _attr12 in json) {\n        if (_attr12 !== 'className' && _attr12 !== '__type') {\n          otherAttributes[_attr12] = json[_attr12];\n        }\n      }\n\n      if (override) {\n        // id needs to be set before clearServerData can work\n        if (otherAttributes.objectId) {\n          o.id = otherAttributes.objectId;\n        }\n\n        var preserved = null;\n\n        if (typeof o._preserveFieldsOnFetch === 'function') {\n          preserved = o._preserveFieldsOnFetch();\n        }\n\n        o._clearServerData();\n\n        if (preserved) {\n          o._finishFetch(preserved);\n        }\n      }\n\n      o._finishFetch(otherAttributes);\n\n      if (json.objectId) {\n        o._setExisted(true);\n      }\n\n      return o;\n    }\n    /**\n     * Registers a subclass of Parse.Object with a specific class name.\n     * When objects of that class are retrieved from a query, they will be\n     * instantiated with this subclass.\n     * This is only necessary when using ES6 subclassing.\n     * @param {String} className The class name of the subclass\n     * @param {Class} constructor The subclass\n     */\n\n  }, {\n    key: \"registerSubclass\",\n    value: function (className\n    /*: string*/\n    , constructor\n    /*: any*/\n    ) {\n      if (typeof className !== 'string') {\n        throw new TypeError('The first argument must be a valid class name.');\n      }\n\n      if (typeof constructor === 'undefined') {\n        throw new TypeError('You must supply a subclass constructor.');\n      }\n\n      if (typeof constructor !== 'function') {\n        throw new TypeError('You must register the subclass constructor. ' + 'Did you attempt to register an instance of the subclass?');\n      }\n\n      classMap[className] = constructor;\n\n      if (!constructor.className) {\n        constructor.className = className;\n      }\n    }\n    /**\n     * Creates a new subclass of Parse.Object for the given Parse class name.\n     *\n     * <p>Every extension of a Parse class will inherit from the most recent\n     * previous extension of that class. When a Parse.Object is automatically\n     * created by parsing JSON, it will use the most recent extension of that\n     * class.</p>\n     *\n     * <p>You should call either:<pre>\n     *     var MyClass = Parse.Object.extend(\"MyClass\", {\n     *         <i>Instance methods</i>,\n     *         initialize: function(attrs, options) {\n     *             this.someInstanceProperty = [],\n     *             <i>Other instance properties</i>\n     *         }\n     *     }, {\n     *         <i>Class properties</i>\n     *     });</pre>\n     * or, for Backbone compatibility:<pre>\n     *     var MyClass = Parse.Object.extend({\n     *         className: \"MyClass\",\n     *         <i>Instance methods</i>,\n     *         initialize: function(attrs, options) {\n     *             this.someInstanceProperty = [],\n     *             <i>Other instance properties</i>\n     *         }\n     *     }, {\n     *         <i>Class properties</i>\n     *     });</pre></p>\n     *\n     * @param {String} className The name of the Parse class backing this model.\n     * @param {Object} protoProps Instance properties to add to instances of the\n     *     class returned from this method.\n     * @param {Object} classProps Class properties to add the class returned from\n     *     this method.\n     * @return {Class} A new subclass of Parse.Object.\n     */\n\n  }, {\n    key: \"extend\",\n    value: function (className\n    /*: any*/\n    , protoProps\n    /*: any*/\n    , classProps\n    /*: any*/\n    ) {\n      if (typeof className !== 'string') {\n        if (className && typeof className.className === 'string') {\n          return ParseObject.extend(className.className, className, protoProps);\n        } else {\n          throw new Error('Parse.Object.extend\\'s first argument should be the className.');\n        }\n      }\n\n      var adjustedClassName = className;\n\n      if (adjustedClassName === 'User' && _CoreManager.default.get('PERFORM_USER_REWRITE')) {\n        adjustedClassName = '_User';\n      }\n\n      var parentProto = ParseObject.prototype;\n\n      if (this.hasOwnProperty('__super__') && this.__super__) {\n        parentProto = this.prototype;\n      } else if (classMap[adjustedClassName]) {\n        parentProto = classMap[adjustedClassName].prototype;\n      }\n\n      var ParseObjectSubclass = function (attributes, options) {\n        this.className = adjustedClassName;\n        this._objCount = objectCount++; // Enable legacy initializers\n\n        if (typeof this.initialize === 'function') {\n          this.initialize.apply(this, arguments);\n        }\n\n        if (attributes && (0, _typeof2.default)(attributes) === 'object') {\n          if (!this.set(attributes || {}, options)) {\n            throw new Error('Can\\'t create an invalid Parse Object');\n          }\n        }\n      };\n\n      ParseObjectSubclass.className = adjustedClassName;\n      ParseObjectSubclass.__super__ = parentProto;\n      ParseObjectSubclass.prototype = Object.create(parentProto, {\n        constructor: {\n          value: ParseObjectSubclass,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      });\n\n      if (protoProps) {\n        for (var prop in protoProps) {\n          if (prop !== 'className') {\n            Object.defineProperty(ParseObjectSubclass.prototype, prop, {\n              value: protoProps[prop],\n              enumerable: false,\n              writable: true,\n              configurable: true\n            });\n          }\n        }\n      }\n\n      if (classProps) {\n        for (var _prop in classProps) {\n          if (_prop !== 'className') {\n            Object.defineProperty(ParseObjectSubclass, _prop, {\n              value: classProps[_prop],\n              enumerable: false,\n              writable: true,\n              configurable: true\n            });\n          }\n        }\n      }\n\n      ParseObjectSubclass.extend = function (name, protoProps, classProps) {\n        if (typeof name === 'string') {\n          return ParseObject.extend.call(ParseObjectSubclass, name, protoProps, classProps);\n        }\n\n        return ParseObject.extend.call(ParseObjectSubclass, adjustedClassName, name, protoProps);\n      };\n\n      ParseObjectSubclass.createWithoutData = ParseObject.createWithoutData;\n      classMap[adjustedClassName] = ParseObjectSubclass;\n      return ParseObjectSubclass;\n    }\n    /**\n     * Enable single instance objects, where any local objects with the same Id\n     * share the same attributes, and stay synchronized with each other.\n     * This is disabled by default in server environments, since it can lead to\n     * security issues.\n     * @static\n     */\n\n  }, {\n    key: \"enableSingleInstance\",\n    value: function () {\n      singleInstance = true;\n\n      _CoreManager.default.setObjectStateController(SingleInstanceStateController);\n    }\n    /**\n     * Disable single instance objects, where any local objects with the same Id\n     * share the same attributes, and stay synchronized with each other.\n     * When disabled, you can have two instances of the same object in memory\n     * without them sharing attributes.\n     * @static\n     */\n\n  }, {\n    key: \"disableSingleInstance\",\n    value: function () {\n      singleInstance = false;\n\n      _CoreManager.default.setObjectStateController(UniqueInstanceStateController);\n    }\n    /**\n     * Asynchronously stores the objects and every object they point to in the local datastore,\n     * recursively, using a default pin name: _default.\n     *\n     * If those other objects have not been fetched from Parse, they will not be stored.\n     * However, if they have changed data, all the changes will be retained.\n     *\n     * <pre>\n     * await Parse.Object.pinAll([...]);\n     * </pre>\n     *\n     * To retrieve object:\n     * <code>query.fromLocalDatastore()</code> or <code>query.fromPin()</code>\n     *\n     * @param {Array} objects A list of <code>Parse.Object</code>.\n     * @return {Promise} A promise that is fulfilled when the pin completes.\n     * @static\n     */\n\n  }, {\n    key: \"pinAll\",\n    value: function (objects\n    /*: Array<ParseObject>*/\n    )\n    /*: Promise<void>*/\n    {\n      var localDatastore = _CoreManager.default.getLocalDatastore();\n\n      if (!localDatastore.isEnabled) {\n        return Promise.reject('Parse.enableLocalDatastore() must be called first');\n      }\n\n      return ParseObject.pinAllWithName(_LocalDatastoreUtils.DEFAULT_PIN, objects);\n    }\n    /**\n     * Asynchronously stores the objects and every object they point to in the local datastore, recursively.\n     *\n     * If those other objects have not been fetched from Parse, they will not be stored.\n     * However, if they have changed data, all the changes will be retained.\n     *\n     * <pre>\n     * await Parse.Object.pinAllWithName(name, [obj1, obj2, ...]);\n     * </pre>\n     *\n     * To retrieve object:\n     * <code>query.fromLocalDatastore()</code> or <code>query.fromPinWithName(name)</code>\n     *\n     * @param {String} name Name of Pin.\n     * @param {Array} objects A list of <code>Parse.Object</code>.\n     * @return {Promise} A promise that is fulfilled when the pin completes.\n     * @static\n     */\n\n  }, {\n    key: \"pinAllWithName\",\n    value: function (name\n    /*: string*/\n    , objects\n    /*: Array<ParseObject>*/\n    )\n    /*: Promise<void>*/\n    {\n      var localDatastore = _CoreManager.default.getLocalDatastore();\n\n      if (!localDatastore.isEnabled) {\n        return Promise.reject('Parse.enableLocalDatastore() must be called first');\n      }\n\n      return localDatastore._handlePinAllWithName(name, objects);\n    }\n    /**\n     * Asynchronously removes the objects and every object they point to in the local datastore,\n     * recursively, using a default pin name: _default.\n     *\n     * <pre>\n     * await Parse.Object.unPinAll([...]);\n     * </pre>\n     *\n     * @param {Array} objects A list of <code>Parse.Object</code>.\n     * @return {Promise} A promise that is fulfilled when the unPin completes.\n     * @static\n     */\n\n  }, {\n    key: \"unPinAll\",\n    value: function (objects\n    /*: Array<ParseObject>*/\n    )\n    /*: Promise<void>*/\n    {\n      var localDatastore = _CoreManager.default.getLocalDatastore();\n\n      if (!localDatastore.isEnabled) {\n        return Promise.reject('Parse.enableLocalDatastore() must be called first');\n      }\n\n      return ParseObject.unPinAllWithName(_LocalDatastoreUtils.DEFAULT_PIN, objects);\n    }\n    /**\n     * Asynchronously removes the objects and every object they point to in the local datastore, recursively.\n     *\n     * <pre>\n     * await Parse.Object.unPinAllWithName(name, [obj1, obj2, ...]);\n     * </pre>\n     *\n     * @param {String} name Name of Pin.\n     * @param {Array} objects A list of <code>Parse.Object</code>.\n     * @return {Promise} A promise that is fulfilled when the unPin completes.\n     * @static\n     */\n\n  }, {\n    key: \"unPinAllWithName\",\n    value: function (name\n    /*: string*/\n    , objects\n    /*: Array<ParseObject>*/\n    )\n    /*: Promise<void>*/\n    {\n      var localDatastore = _CoreManager.default.getLocalDatastore();\n\n      if (!localDatastore.isEnabled) {\n        return Promise.reject('Parse.enableLocalDatastore() must be called first');\n      }\n\n      return localDatastore._handleUnPinAllWithName(name, objects);\n    }\n    /**\n     * Asynchronously removes all objects in the local datastore using a default pin name: _default.\n     *\n     * <pre>\n     * await Parse.Object.unPinAllObjects();\n     * </pre>\n     *\n     * @return {Promise} A promise that is fulfilled when the unPin completes.\n     * @static\n     */\n\n  }, {\n    key: \"unPinAllObjects\",\n    value: function ()\n    /*: Promise<void>*/\n    {\n      var localDatastore = _CoreManager.default.getLocalDatastore();\n\n      if (!localDatastore.isEnabled) {\n        return Promise.reject('Parse.enableLocalDatastore() must be called first');\n      }\n\n      return localDatastore.unPinWithName(_LocalDatastoreUtils.DEFAULT_PIN);\n    }\n    /**\n     * Asynchronously removes all objects with the specified pin name.\n     * Deletes the pin name also.\n     *\n     * <pre>\n     * await Parse.Object.unPinAllObjectsWithName(name);\n     * </pre>\n     *\n     * @param {String} name Name of Pin.\n     * @return {Promise} A promise that is fulfilled when the unPin completes.\n     * @static\n     */\n\n  }, {\n    key: \"unPinAllObjectsWithName\",\n    value: function (name\n    /*: string*/\n    )\n    /*: Promise<void>*/\n    {\n      var localDatastore = _CoreManager.default.getLocalDatastore();\n\n      if (!localDatastore.isEnabled) {\n        return Promise.reject('Parse.enableLocalDatastore() must be called first');\n      }\n\n      return localDatastore.unPinWithName(_LocalDatastoreUtils.PIN_PREFIX + name);\n    }\n  }]);\n  return ParseObject;\n}();\n\nvar DefaultController = {\n  fetch: function (target\n  /*: ParseObject | Array<ParseObject>*/\n  , forceFetch\n  /*: boolean*/\n  , options\n  /*: RequestOptions*/\n  )\n  /*: Promise<Array<void> | ParseObject>*/\n  {\n    var localDatastore = _CoreManager.default.getLocalDatastore();\n\n    if (Array.isArray(target)) {\n      if (target.length < 1) {\n        return Promise.resolve([]);\n      }\n\n      var objs = [];\n      var ids = [];\n      var className = null;\n      var results = [];\n      var error = null;\n      target.forEach(function (el) {\n        if (error) {\n          return;\n        }\n\n        if (!className) {\n          className = el.className;\n        }\n\n        if (className !== el.className) {\n          error = new _ParseError.default(_ParseError.default.INVALID_CLASS_NAME, 'All objects should be of the same class');\n        }\n\n        if (!el.id) {\n          error = new _ParseError.default(_ParseError.default.MISSING_OBJECT_ID, 'All objects must have an ID');\n        }\n\n        if (forceFetch || Object.keys(el._getServerData()).length === 0) {\n          ids.push(el.id);\n          objs.push(el);\n        }\n\n        results.push(el);\n      });\n\n      if (error) {\n        return Promise.reject(error);\n      }\n\n      var query = new _ParseQuery.default(className);\n      query.containedIn('objectId', ids);\n\n      if (options && options.include) {\n        query.include(options.include);\n      }\n\n      query._limit = ids.length;\n      return query.find(options).then(\n      /*#__PURE__*/\n      function () {\n        var _ref = (0, _asyncToGenerator2.default)(\n        /*#__PURE__*/\n        _regenerator.default.mark(function _callee3(objects) {\n          var idMap, i, obj, _i2, _obj, id, _i3, _results, object;\n\n          return _regenerator.default.wrap(function (_context3) {\n            while (1) {\n              switch (_context3.prev = _context3.next) {\n                case 0:\n                  idMap = {};\n                  objects.forEach(function (o) {\n                    idMap[o.id] = o;\n                  });\n                  i = 0;\n\n                case 3:\n                  if (!(i < objs.length)) {\n                    _context3.next = 11;\n                    break;\n                  }\n\n                  obj = objs[i];\n\n                  if (!(!obj || !obj.id || !idMap[obj.id])) {\n                    _context3.next = 8;\n                    break;\n                  }\n\n                  if (!forceFetch) {\n                    _context3.next = 8;\n                    break;\n                  }\n\n                  return _context3.abrupt(\"return\", Promise.reject(new _ParseError.default(_ParseError.default.OBJECT_NOT_FOUND, 'All objects must exist on the server.')));\n\n                case 8:\n                  i++;\n                  _context3.next = 3;\n                  break;\n\n                case 11:\n                  if (!singleInstance) {\n                    // If single instance objects are disabled, we need to replace the\n                    for (_i2 = 0; _i2 < results.length; _i2++) {\n                      _obj = results[_i2];\n\n                      if (_obj && _obj.id && idMap[_obj.id]) {\n                        id = _obj.id;\n\n                        _obj._finishFetch(idMap[id].toJSON());\n\n                        results[_i2] = idMap[id];\n                      }\n                    }\n                  }\n\n                  _i3 = 0, _results = results;\n\n                case 13:\n                  if (!(_i3 < _results.length)) {\n                    _context3.next = 20;\n                    break;\n                  }\n\n                  object = _results[_i3];\n                  _context3.next = 17;\n                  return localDatastore._updateObjectIfPinned(object);\n\n                case 17:\n                  _i3++;\n                  _context3.next = 13;\n                  break;\n\n                case 20:\n                  return _context3.abrupt(\"return\", Promise.resolve(results));\n\n                case 21:\n                case \"end\":\n                  return _context3.stop();\n              }\n            }\n          }, _callee3);\n        }));\n\n        return function () {\n          return _ref.apply(this, arguments);\n        };\n      }());\n    } else {\n      var RESTController = _CoreManager.default.getRESTController();\n\n      var params = {};\n\n      if (options && options.include) {\n        params.include = options.include.join();\n      }\n\n      return RESTController.request('GET', 'classes/' + target.className + '/' + target._getId(), params, options).then(\n      /*#__PURE__*/\n      function () {\n        var _ref2 = (0, _asyncToGenerator2.default)(\n        /*#__PURE__*/\n        _regenerator.default.mark(function _callee4(response) {\n          return _regenerator.default.wrap(function (_context4) {\n            while (1) {\n              switch (_context4.prev = _context4.next) {\n                case 0:\n                  if (target instanceof ParseObject) {\n                    target._clearPendingOps();\n\n                    target._clearServerData();\n\n                    target._finishFetch(response);\n                  }\n\n                  _context4.next = 3;\n                  return localDatastore._updateObjectIfPinned(target);\n\n                case 3:\n                  return _context4.abrupt(\"return\", target);\n\n                case 4:\n                case \"end\":\n                  return _context4.stop();\n              }\n            }\n          }, _callee4);\n        }));\n\n        return function () {\n          return _ref2.apply(this, arguments);\n        };\n      }());\n    }\n  },\n  destroy: function () {\n    var _destroy = (0, _asyncToGenerator2.default)(\n    /*#__PURE__*/\n    _regenerator.default.mark(function _callee7(target\n    /*: ParseObject | Array<ParseObject>*/\n    , options\n    /*: RequestOptions*/\n    ) {\n      var batchSize, localDatastore, RESTController, batches, deleteCompleted, errors;\n      return _regenerator.default.wrap(function (_context7) {\n        while (1) {\n          switch (_context7.prev = _context7.next) {\n            case 0:\n              batchSize = options && options.batchSize ? options.batchSize : DEFAULT_BATCH_SIZE;\n              localDatastore = _CoreManager.default.getLocalDatastore();\n              RESTController = _CoreManager.default.getRESTController();\n\n              if (!Array.isArray(target)) {\n                _context7.next = 15;\n                break;\n              }\n\n              if (!(target.length < 1)) {\n                _context7.next = 6;\n                break;\n              }\n\n              return _context7.abrupt(\"return\", Promise.resolve([]));\n\n            case 6:\n              batches = [[]];\n              target.forEach(function (obj) {\n                if (!obj.id) {\n                  return;\n                }\n\n                batches[batches.length - 1].push(obj);\n\n                if (batches[batches.length - 1].length >= batchSize) {\n                  batches.push([]);\n                }\n              });\n\n              if (batches[batches.length - 1].length === 0) {\n                // If the last batch is empty, remove it\n                batches.pop();\n              }\n\n              deleteCompleted = Promise.resolve();\n              errors = [];\n              batches.forEach(function (batch) {\n                deleteCompleted = deleteCompleted.then(function () {\n                  return RESTController.request('POST', 'batch', {\n                    requests: batch.map(function (obj) {\n                      return {\n                        method: 'DELETE',\n                        path: getServerUrlPath() + 'classes/' + obj.className + '/' + obj._getId(),\n                        body: {}\n                      };\n                    })\n                  }, options).then(function (results) {\n                    for (var i = 0; i < results.length; i++) {\n                      if (results[i] && results[i].hasOwnProperty('error')) {\n                        var err = new _ParseError.default(results[i].error.code, results[i].error.error);\n                        err.object = batch[i];\n                        errors.push(err);\n                      }\n                    }\n                  });\n                });\n              });\n              return _context7.abrupt(\"return\", deleteCompleted.then(\n              /*#__PURE__*/\n              (0, _asyncToGenerator2.default)(\n              /*#__PURE__*/\n              _regenerator.default.mark(function _callee5() {\n                var aggregate, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, object;\n\n                return _regenerator.default.wrap(function (_context5) {\n                  while (1) {\n                    switch (_context5.prev = _context5.next) {\n                      case 0:\n                        if (!errors.length) {\n                          _context5.next = 4;\n                          break;\n                        }\n\n                        aggregate = new _ParseError.default(_ParseError.default.AGGREGATE_ERROR);\n                        aggregate.errors = errors;\n                        return _context5.abrupt(\"return\", Promise.reject(aggregate));\n\n                      case 4:\n                        _iteratorNormalCompletion = true;\n                        _didIteratorError = false;\n                        _iteratorError = undefined;\n                        _context5.prev = 7;\n                        _iterator = target[Symbol.iterator]();\n\n                      case 9:\n                        if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n                          _context5.next = 16;\n                          break;\n                        }\n\n                        object = _step.value;\n                        _context5.next = 13;\n                        return localDatastore._destroyObjectIfPinned(object);\n\n                      case 13:\n                        _iteratorNormalCompletion = true;\n                        _context5.next = 9;\n                        break;\n\n                      case 16:\n                        _context5.next = 22;\n                        break;\n\n                      case 18:\n                        _context5.prev = 18;\n                        _context5.t0 = _context5[\"catch\"](7);\n                        _didIteratorError = true;\n                        _iteratorError = _context5.t0;\n\n                      case 22:\n                        _context5.prev = 22;\n                        _context5.prev = 23;\n\n                        if (!_iteratorNormalCompletion && _iterator.return != null) {\n                          _iterator.return();\n                        }\n\n                      case 25:\n                        _context5.prev = 25;\n\n                        if (!_didIteratorError) {\n                          _context5.next = 28;\n                          break;\n                        }\n\n                        throw _iteratorError;\n\n                      case 28:\n                        return _context5.finish(25);\n\n                      case 29:\n                        return _context5.finish(22);\n\n                      case 30:\n                        return _context5.abrupt(\"return\", Promise.resolve(target));\n\n                      case 31:\n                      case \"end\":\n                        return _context5.stop();\n                    }\n                  }\n                }, _callee5, null, [[7, 18, 22, 30], [23,, 25, 29]]);\n              }))));\n\n            case 15:\n              if (!(target instanceof ParseObject)) {\n                _context7.next = 17;\n                break;\n              }\n\n              return _context7.abrupt(\"return\", RESTController.request('DELETE', 'classes/' + target.className + '/' + target._getId(), {}, options).then(\n              /*#__PURE__*/\n              (0, _asyncToGenerator2.default)(\n              /*#__PURE__*/\n              _regenerator.default.mark(function _callee6() {\n                return _regenerator.default.wrap(function (_context6) {\n                  while (1) {\n                    switch (_context6.prev = _context6.next) {\n                      case 0:\n                        _context6.next = 2;\n                        return localDatastore._destroyObjectIfPinned(target);\n\n                      case 2:\n                        return _context6.abrupt(\"return\", Promise.resolve(target));\n\n                      case 3:\n                      case \"end\":\n                        return _context6.stop();\n                    }\n                  }\n                }, _callee6);\n              }))));\n\n            case 17:\n              _context7.next = 19;\n              return localDatastore._destroyObjectIfPinned(target);\n\n            case 19:\n              return _context7.abrupt(\"return\", Promise.resolve(target));\n\n            case 20:\n            case \"end\":\n              return _context7.stop();\n          }\n        }\n      }, _callee7);\n    }));\n\n    return function () {\n      return _destroy.apply(this, arguments);\n    };\n  }(),\n  save: function (target\n  /*: ParseObject | Array<ParseObject | ParseFile>*/\n  , options\n  /*: RequestOptions*/\n  ) {\n    var batchSize = options && options.batchSize ? options.batchSize : DEFAULT_BATCH_SIZE;\n\n    var localDatastore = _CoreManager.default.getLocalDatastore();\n\n    var mapIdForPin = {};\n\n    var RESTController = _CoreManager.default.getRESTController();\n\n    var stateController = _CoreManager.default.getObjectStateController();\n\n    if (Array.isArray(target)) {\n      if (target.length < 1) {\n        return Promise.resolve([]);\n      }\n\n      var unsaved = target.concat();\n\n      for (var i = 0; i < target.length; i++) {\n        if (target[i] instanceof ParseObject) {\n          unsaved = unsaved.concat((0, _unsavedChildren.default)(target[i], true));\n        }\n      }\n\n      unsaved = (0, _unique.default)(unsaved);\n      var filesSaved = Promise.resolve();\n      var pending\n      /*: Array<ParseObject>*/\n      = [];\n      unsaved.forEach(function (el) {\n        if (el instanceof _ParseFile.default) {\n          filesSaved = filesSaved.then(function () {\n            return el.save();\n          });\n        } else if (el instanceof ParseObject) {\n          pending.push(el);\n        }\n      });\n      return filesSaved.then(function () {\n        var objectError = null;\n        return (0, _promiseUtils.continueWhile)(function () {\n          return pending.length > 0;\n        }, function () {\n          var batch = [];\n          var nextPending = [];\n          pending.forEach(function (el) {\n            if (batch.length < batchSize && (0, _canBeSerialized.default)(el)) {\n              batch.push(el);\n            } else {\n              nextPending.push(el);\n            }\n          });\n          pending = nextPending;\n\n          if (batch.length < 1) {\n            return Promise.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Tried to save a batch with a cycle.'));\n          } // Queue up tasks for each object in the batch.\n          // When every task is ready, the API request will execute\n\n\n          var res, rej;\n          var batchReturned = new Promise(function (resolve, reject) {\n            res = resolve;\n            rej = reject;\n          });\n          batchReturned.resolve = res;\n          batchReturned.reject = rej;\n          var batchReady = [];\n          var batchTasks = [];\n          batch.forEach(function (obj, index) {\n            var res, rej;\n            var ready = new Promise(function (resolve, reject) {\n              res = resolve;\n              rej = reject;\n            });\n            ready.resolve = res;\n            ready.reject = rej;\n            batchReady.push(ready);\n            stateController.pushPendingState(obj._getStateIdentifier());\n            batchTasks.push(stateController.enqueueTask(obj._getStateIdentifier(), function () {\n              ready.resolve();\n              return batchReturned.then(function (responses, status) {\n                if (responses[index].hasOwnProperty('success')) {\n                  var objectId = responses[index].success.objectId;\n                  mapIdForPin[objectId] = obj._localId;\n\n                  obj._handleSaveResponse(responses[index].success, status);\n                } else {\n                  if (!objectError && responses[index].hasOwnProperty('error')) {\n                    var serverError = responses[index].error;\n                    objectError = new _ParseError.default(serverError.code, serverError.error); // Cancel the rest of the save\n\n                    pending = [];\n                  }\n\n                  obj._handleSaveError();\n                }\n              });\n            }));\n          });\n          (0, _promiseUtils.when)(batchReady).then(function () {\n            // Kick off the batch request\n            return RESTController.request('POST', 'batch', {\n              requests: batch.map(function (obj) {\n                var params = obj._getSaveParams();\n\n                params.path = getServerUrlPath() + params.path;\n                return params;\n              })\n            }, options);\n          }).then(function (response, status) {\n            batchReturned.resolve(response, status);\n          }, function (error) {\n            batchReturned.reject(new _ParseError.default(_ParseError.default.INCORRECT_TYPE, error.message));\n          });\n          return (0, _promiseUtils.when)(batchTasks);\n        }).then(\n        /*#__PURE__*/\n        (0, _asyncToGenerator2.default)(\n        /*#__PURE__*/\n        _regenerator.default.mark(function _callee8() {\n          var _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, object;\n\n          return _regenerator.default.wrap(function (_context8) {\n            while (1) {\n              switch (_context8.prev = _context8.next) {\n                case 0:\n                  if (!objectError) {\n                    _context8.next = 2;\n                    break;\n                  }\n\n                  return _context8.abrupt(\"return\", Promise.reject(objectError));\n\n                case 2:\n                  _iteratorNormalCompletion2 = true;\n                  _didIteratorError2 = false;\n                  _iteratorError2 = undefined;\n                  _context8.prev = 5;\n                  _iterator2 = target[Symbol.iterator]();\n\n                case 7:\n                  if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {\n                    _context8.next = 16;\n                    break;\n                  }\n\n                  object = _step2.value;\n                  _context8.next = 11;\n                  return localDatastore._updateLocalIdForObject(mapIdForPin[object.id], object);\n\n                case 11:\n                  _context8.next = 13;\n                  return localDatastore._updateObjectIfPinned(object);\n\n                case 13:\n                  _iteratorNormalCompletion2 = true;\n                  _context8.next = 7;\n                  break;\n\n                case 16:\n                  _context8.next = 22;\n                  break;\n\n                case 18:\n                  _context8.prev = 18;\n                  _context8.t0 = _context8[\"catch\"](5);\n                  _didIteratorError2 = true;\n                  _iteratorError2 = _context8.t0;\n\n                case 22:\n                  _context8.prev = 22;\n                  _context8.prev = 23;\n\n                  if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                    _iterator2.return();\n                  }\n\n                case 25:\n                  _context8.prev = 25;\n\n                  if (!_didIteratorError2) {\n                    _context8.next = 28;\n                    break;\n                  }\n\n                  throw _iteratorError2;\n\n                case 28:\n                  return _context8.finish(25);\n\n                case 29:\n                  return _context8.finish(22);\n\n                case 30:\n                  return _context8.abrupt(\"return\", Promise.resolve(target));\n\n                case 31:\n                case \"end\":\n                  return _context8.stop();\n              }\n            }\n          }, _callee8, null, [[5, 18, 22, 30], [23,, 25, 29]]);\n        })));\n      });\n    } else if (target instanceof ParseObject) {\n      // copying target lets Flow guarantee the pointer isn't modified elsewhere\n      var localId = target._localId;\n      var targetCopy = target;\n\n      var task = function () {\n        var params = targetCopy._getSaveParams();\n\n        return RESTController.request(params.method, params.path, params.body, options).then(function (response, status) {\n          targetCopy._handleSaveResponse(response, status);\n        }, function (error) {\n          targetCopy._handleSaveError();\n\n          return Promise.reject(error);\n        });\n      };\n\n      stateController.pushPendingState(target._getStateIdentifier());\n      return stateController.enqueueTask(target._getStateIdentifier(), task).then(\n      /*#__PURE__*/\n      (0, _asyncToGenerator2.default)(\n      /*#__PURE__*/\n      _regenerator.default.mark(function _callee9() {\n        return _regenerator.default.wrap(function (_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _context9.next = 2;\n                return localDatastore._updateLocalIdForObject(localId, target);\n\n              case 2:\n                _context9.next = 4;\n                return localDatastore._updateObjectIfPinned(target);\n\n              case 4:\n                return _context9.abrupt(\"return\", target);\n\n              case 5:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9);\n      })), function (error) {\n        return Promise.reject(error);\n      });\n    }\n\n    return Promise.resolve();\n  }\n};\n\n_CoreManager.default.setObjectController(DefaultController);\n\nvar _default = ParseObject;\nexports.default = _default;","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.opFromJSON = opFromJSON;\nexports.RelationOp = exports.RemoveOp = exports.AddUniqueOp = exports.AddOp = exports.IncrementOp = exports.UnsetOp = exports.SetOp = exports.Op = void 0;\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _arrayContainsObject = _interopRequireDefault(require(\"./arrayContainsObject\"));\n\nvar _decode = _interopRequireDefault(require(\"./decode\"));\n\nvar _encode = _interopRequireDefault(require(\"./encode\"));\n\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\n\nvar _ParseRelation = _interopRequireDefault(require(\"./ParseRelation\"));\n\nvar _unique = _interopRequireDefault(require(\"./unique\"));\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n\nfunction opFromJSON(json\n/*: { [key: string]: any }*/\n)\n/*: ?Op*/\n{\n  if (!json || !json.__op) {\n    return null;\n  }\n\n  switch (json.__op) {\n    case 'Delete':\n      return new UnsetOp();\n\n    case 'Increment':\n      return new IncrementOp(json.amount);\n\n    case 'Add':\n      return new AddOp((0, _decode.default)(json.objects));\n\n    case 'AddUnique':\n      return new AddUniqueOp((0, _decode.default)(json.objects));\n\n    case 'Remove':\n      return new RemoveOp((0, _decode.default)(json.objects));\n\n    case 'AddRelation':\n      {\n        var toAdd = (0, _decode.default)(json.objects);\n\n        if (!Array.isArray(toAdd)) {\n          return new RelationOp([], []);\n        }\n\n        return new RelationOp(toAdd, []);\n      }\n\n    case 'RemoveRelation':\n      {\n        var toRemove = (0, _decode.default)(json.objects);\n\n        if (!Array.isArray(toRemove)) {\n          return new RelationOp([], []);\n        }\n\n        return new RelationOp([], toRemove);\n      }\n\n    case 'Batch':\n      {\n        var _toAdd = [];\n        var _toRemove = [];\n\n        for (var i = 0; i < json.ops.length; i++) {\n          if (json.ops[i].__op === 'AddRelation') {\n            _toAdd = _toAdd.concat((0, _decode.default)(json.ops[i].objects));\n          } else if (json.ops[i].__op === 'RemoveRelation') {\n            _toRemove = _toRemove.concat((0, _decode.default)(json.ops[i].objects));\n          }\n        }\n\n        return new RelationOp(_toAdd, _toRemove);\n      }\n  }\n\n  return null;\n}\n\nvar Op =\n/*#__PURE__*/\nfunction () {\n  function Op() {\n    (0, _classCallCheck2.default)(this, Op);\n  }\n\n  (0, _createClass2.default)(Op, [{\n    key: \"applyTo\",\n    // Empty parent class\n    value: function ()\n    /*: mixed*/\n\n    /*: mixed*/\n    {}\n    /* eslint-disable-line no-unused-vars */\n\n  }, {\n    key: \"mergeWith\",\n    value: function ()\n    /*: Op*/\n\n    /*: ?Op*/\n    {}\n    /* eslint-disable-line no-unused-vars */\n\n  }, {\n    key: \"toJSON\",\n    value: function ()\n    /*: mixed*/\n    {}\n  }]);\n  return Op;\n}();\n\nexports.Op = Op;\n\nvar SetOp =\n/*#__PURE__*/\nfunction (_Op) {\n  (0, _inherits2.default)(SetOp, _Op);\n\n  function SetOp(value\n  /*: mixed*/\n  ) {\n    var _this;\n\n    (0, _classCallCheck2.default)(this, SetOp);\n    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(SetOp).call(this));\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), \"_value\", void 0);\n    _this._value = value;\n    return _this;\n  }\n\n  (0, _createClass2.default)(SetOp, [{\n    key: \"applyTo\",\n    value: function ()\n    /*: mixed*/\n    {\n      return this._value;\n    }\n  }, {\n    key: \"mergeWith\",\n    value: function ()\n    /*: SetOp*/\n    {\n      return new SetOp(this._value);\n    }\n  }, {\n    key: \"toJSON\",\n    value: function () {\n      return (0, _encode.default)(this._value, false, true);\n    }\n  }]);\n  return SetOp;\n}(Op);\n\nexports.SetOp = SetOp;\n\nvar UnsetOp =\n/*#__PURE__*/\nfunction (_Op2) {\n  (0, _inherits2.default)(UnsetOp, _Op2);\n\n  function UnsetOp() {\n    (0, _classCallCheck2.default)(this, UnsetOp);\n    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(UnsetOp).apply(this, arguments));\n  }\n\n  (0, _createClass2.default)(UnsetOp, [{\n    key: \"applyTo\",\n    value: function () {\n      return undefined;\n    }\n  }, {\n    key: \"mergeWith\",\n    value: function ()\n    /*: UnsetOp*/\n    {\n      return new UnsetOp();\n    }\n  }, {\n    key: \"toJSON\",\n    value: function ()\n    /*: { __op: string }*/\n    {\n      return {\n        __op: 'Delete'\n      };\n    }\n  }]);\n  return UnsetOp;\n}(Op);\n\nexports.UnsetOp = UnsetOp;\n\nvar IncrementOp =\n/*#__PURE__*/\nfunction (_Op3) {\n  (0, _inherits2.default)(IncrementOp, _Op3);\n\n  function IncrementOp(amount\n  /*: number*/\n  ) {\n    var _this2;\n\n    (0, _classCallCheck2.default)(this, IncrementOp);\n    _this2 = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(IncrementOp).call(this));\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this2), \"_amount\", void 0);\n\n    if (typeof amount !== 'number') {\n      throw new TypeError('Increment Op must be initialized with a numeric amount.');\n    }\n\n    _this2._amount = amount;\n    return _this2;\n  }\n\n  (0, _createClass2.default)(IncrementOp, [{\n    key: \"applyTo\",\n    value: function (value\n    /*: ?mixed*/\n    )\n    /*: number*/\n    {\n      if (typeof value === 'undefined') {\n        return this._amount;\n      }\n\n      if (typeof value !== 'number') {\n        throw new TypeError('Cannot increment a non-numeric value.');\n      }\n\n      return this._amount + value;\n    }\n  }, {\n    key: \"mergeWith\",\n    value: function (previous\n    /*: Op*/\n    )\n    /*: Op*/\n    {\n      if (!previous) {\n        return this;\n      }\n\n      if (previous instanceof SetOp) {\n        return new SetOp(this.applyTo(previous._value));\n      }\n\n      if (previous instanceof UnsetOp) {\n        return new SetOp(this._amount);\n      }\n\n      if (previous instanceof IncrementOp) {\n        return new IncrementOp(this.applyTo(previous._amount));\n      }\n\n      throw new Error('Cannot merge Increment Op with the previous Op');\n    }\n  }, {\n    key: \"toJSON\",\n    value: function ()\n    /*: { __op: string; amount: number }*/\n    {\n      return {\n        __op: 'Increment',\n        amount: this._amount\n      };\n    }\n  }]);\n  return IncrementOp;\n}(Op);\n\nexports.IncrementOp = IncrementOp;\n\nvar AddOp =\n/*#__PURE__*/\nfunction (_Op4) {\n  (0, _inherits2.default)(AddOp, _Op4);\n\n  function AddOp(value\n  /*: mixed | Array<mixed>*/\n  ) {\n    var _this3;\n\n    (0, _classCallCheck2.default)(this, AddOp);\n    _this3 = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(AddOp).call(this));\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this3), \"_value\", void 0);\n    _this3._value = Array.isArray(value) ? value : [value];\n    return _this3;\n  }\n\n  (0, _createClass2.default)(AddOp, [{\n    key: \"applyTo\",\n    value: function (value\n    /*: mixed*/\n    )\n    /*: Array<mixed>*/\n    {\n      if (value == null) {\n        return this._value;\n      }\n\n      if (Array.isArray(value)) {\n        return value.concat(this._value);\n      }\n\n      throw new Error('Cannot add elements to a non-array value');\n    }\n  }, {\n    key: \"mergeWith\",\n    value: function (previous\n    /*: Op*/\n    )\n    /*: Op*/\n    {\n      if (!previous) {\n        return this;\n      }\n\n      if (previous instanceof SetOp) {\n        return new SetOp(this.applyTo(previous._value));\n      }\n\n      if (previous instanceof UnsetOp) {\n        return new SetOp(this._value);\n      }\n\n      if (previous instanceof AddOp) {\n        return new AddOp(this.applyTo(previous._value));\n      }\n\n      throw new Error('Cannot merge Add Op with the previous Op');\n    }\n  }, {\n    key: \"toJSON\",\n    value: function ()\n    /*: { __op: string; objects: mixed }*/\n    {\n      return {\n        __op: 'Add',\n        objects: (0, _encode.default)(this._value, false, true)\n      };\n    }\n  }]);\n  return AddOp;\n}(Op);\n\nexports.AddOp = AddOp;\n\nvar AddUniqueOp =\n/*#__PURE__*/\nfunction (_Op5) {\n  (0, _inherits2.default)(AddUniqueOp, _Op5);\n\n  function AddUniqueOp(value\n  /*: mixed | Array<mixed>*/\n  ) {\n    var _this4;\n\n    (0, _classCallCheck2.default)(this, AddUniqueOp);\n    _this4 = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(AddUniqueOp).call(this));\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this4), \"_value\", void 0);\n    _this4._value = (0, _unique.default)(Array.isArray(value) ? value : [value]);\n    return _this4;\n  }\n\n  (0, _createClass2.default)(AddUniqueOp, [{\n    key: \"applyTo\",\n    value: function (value\n    /*: mixed | Array<mixed>*/\n    )\n    /*: Array<mixed>*/\n    {\n      if (value == null) {\n        return this._value || [];\n      }\n\n      if (Array.isArray(value)) {\n        // copying value lets Flow guarantee the pointer isn't modified elsewhere\n        var valueCopy = value;\n        var toAdd = [];\n\n        this._value.forEach(function (v) {\n          if (v instanceof _ParseObject.default) {\n            if (!(0, _arrayContainsObject.default)(valueCopy, v)) {\n              toAdd.push(v);\n            }\n          } else {\n            if (valueCopy.indexOf(v) < 0) {\n              toAdd.push(v);\n            }\n          }\n        });\n\n        return value.concat(toAdd);\n      }\n\n      throw new Error('Cannot add elements to a non-array value');\n    }\n  }, {\n    key: \"mergeWith\",\n    value: function (previous\n    /*: Op*/\n    )\n    /*: Op*/\n    {\n      if (!previous) {\n        return this;\n      }\n\n      if (previous instanceof SetOp) {\n        return new SetOp(this.applyTo(previous._value));\n      }\n\n      if (previous instanceof UnsetOp) {\n        return new SetOp(this._value);\n      }\n\n      if (previous instanceof AddUniqueOp) {\n        return new AddUniqueOp(this.applyTo(previous._value));\n      }\n\n      throw new Error('Cannot merge AddUnique Op with the previous Op');\n    }\n  }, {\n    key: \"toJSON\",\n    value: function ()\n    /*: { __op: string; objects: mixed }*/\n    {\n      return {\n        __op: 'AddUnique',\n        objects: (0, _encode.default)(this._value, false, true)\n      };\n    }\n  }]);\n  return AddUniqueOp;\n}(Op);\n\nexports.AddUniqueOp = AddUniqueOp;\n\nvar RemoveOp =\n/*#__PURE__*/\nfunction (_Op6) {\n  (0, _inherits2.default)(RemoveOp, _Op6);\n\n  function RemoveOp(value\n  /*: mixed | Array<mixed>*/\n  ) {\n    var _this5;\n\n    (0, _classCallCheck2.default)(this, RemoveOp);\n    _this5 = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(RemoveOp).call(this));\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this5), \"_value\", void 0);\n    _this5._value = (0, _unique.default)(Array.isArray(value) ? value : [value]);\n    return _this5;\n  }\n\n  (0, _createClass2.default)(RemoveOp, [{\n    key: \"applyTo\",\n    value: function (value\n    /*: mixed | Array<mixed>*/\n    )\n    /*: Array<mixed>*/\n    {\n      if (value == null) {\n        return [];\n      }\n\n      if (Array.isArray(value)) {\n        // var i = value.indexOf(this._value);\n        var removed = value.concat([]);\n\n        for (var i = 0; i < this._value.length; i++) {\n          var index = removed.indexOf(this._value[i]);\n\n          while (index > -1) {\n            removed.splice(index, 1);\n            index = removed.indexOf(this._value[i]);\n          }\n\n          if (this._value[i] instanceof _ParseObject.default && this._value[i].id) {\n            for (var j = 0; j < removed.length; j++) {\n              if (removed[j] instanceof _ParseObject.default && this._value[i].id === removed[j].id) {\n                removed.splice(j, 1);\n                j--;\n              }\n            }\n          }\n        }\n\n        return removed;\n      }\n\n      throw new Error('Cannot remove elements from a non-array value');\n    }\n  }, {\n    key: \"mergeWith\",\n    value: function (previous\n    /*: Op*/\n    )\n    /*: Op*/\n    {\n      if (!previous) {\n        return this;\n      }\n\n      if (previous instanceof SetOp) {\n        return new SetOp(this.applyTo(previous._value));\n      }\n\n      if (previous instanceof UnsetOp) {\n        return new UnsetOp();\n      }\n\n      if (previous instanceof RemoveOp) {\n        var uniques = previous._value.concat([]);\n\n        for (var i = 0; i < this._value.length; i++) {\n          if (this._value[i] instanceof _ParseObject.default) {\n            if (!(0, _arrayContainsObject.default)(uniques, this._value[i])) {\n              uniques.push(this._value[i]);\n            }\n          } else {\n            if (uniques.indexOf(this._value[i]) < 0) {\n              uniques.push(this._value[i]);\n            }\n          }\n        }\n\n        return new RemoveOp(uniques);\n      }\n\n      throw new Error('Cannot merge Remove Op with the previous Op');\n    }\n  }, {\n    key: \"toJSON\",\n    value: function ()\n    /*: { __op: string; objects: mixed }*/\n    {\n      return {\n        __op: 'Remove',\n        objects: (0, _encode.default)(this._value, false, true)\n      };\n    }\n  }]);\n  return RemoveOp;\n}(Op);\n\nexports.RemoveOp = RemoveOp;\n\nvar RelationOp =\n/*#__PURE__*/\nfunction (_Op7) {\n  (0, _inherits2.default)(RelationOp, _Op7);\n\n  function RelationOp(adds\n  /*: Array<ParseObject | string>*/\n  , removes\n  /*: Array<ParseObject | string>*/\n  ) {\n    var _this6;\n\n    (0, _classCallCheck2.default)(this, RelationOp);\n    _this6 = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(RelationOp).call(this));\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this6), \"_targetClassName\", void 0);\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this6), \"relationsToAdd\", void 0);\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this6), \"relationsToRemove\", void 0);\n    _this6._targetClassName = null;\n\n    if (Array.isArray(adds)) {\n      _this6.relationsToAdd = (0, _unique.default)(adds.map(_this6._extractId, (0, _assertThisInitialized2.default)(_this6)));\n    }\n\n    if (Array.isArray(removes)) {\n      _this6.relationsToRemove = (0, _unique.default)(removes.map(_this6._extractId, (0, _assertThisInitialized2.default)(_this6)));\n    }\n\n    return _this6;\n  }\n\n  (0, _createClass2.default)(RelationOp, [{\n    key: \"_extractId\",\n    value: function (obj\n    /*: string | ParseObject*/\n    )\n    /*: string*/\n    {\n      if (typeof obj === 'string') {\n        return obj;\n      }\n\n      if (!obj.id) {\n        throw new Error('You cannot add or remove an unsaved Parse Object from a relation');\n      }\n\n      if (!this._targetClassName) {\n        this._targetClassName = obj.className;\n      }\n\n      if (this._targetClassName !== obj.className) {\n        throw new Error('Tried to create a Relation with 2 different object types: ' + this._targetClassName + ' and ' + obj.className + '.');\n      }\n\n      return obj.id;\n    }\n  }, {\n    key: \"applyTo\",\n    value: function (value\n    /*: mixed*/\n    , object\n    /*:: ?: { className: string, id: ?string }*/\n    , key\n    /*:: ?: string*/\n    )\n    /*: ?ParseRelation*/\n    {\n      if (!value) {\n        if (!object || !key) {\n          throw new Error('Cannot apply a RelationOp without either a previous value, or an object and a key');\n        }\n\n        var parent = new _ParseObject.default(object.className);\n\n        if (object.id && object.id.indexOf('local') === 0) {\n          parent._localId = object.id;\n        } else if (object.id) {\n          parent.id = object.id;\n        }\n\n        var relation = new _ParseRelation.default(parent, key);\n        relation.targetClassName = this._targetClassName;\n        return relation;\n      }\n\n      if (value instanceof _ParseRelation.default) {\n        if (this._targetClassName) {\n          if (value.targetClassName) {\n            if (this._targetClassName !== value.targetClassName) {\n              throw new Error('Related object must be a ' + value.targetClassName + ', but a ' + this._targetClassName + ' was passed in.');\n            }\n          } else {\n            value.targetClassName = this._targetClassName;\n          }\n        }\n\n        return value;\n      } else {\n        throw new Error('Relation cannot be applied to a non-relation field');\n      }\n    }\n  }, {\n    key: \"mergeWith\",\n    value: function (previous\n    /*: Op*/\n    )\n    /*: Op*/\n    {\n      if (!previous) {\n        return this;\n      } else if (previous instanceof UnsetOp) {\n        throw new Error('You cannot modify a relation after deleting it.');\n      } else if (previous instanceof SetOp && previous._value instanceof _ParseRelation.default) {\n        return this;\n      } else if (previous instanceof RelationOp) {\n        if (previous._targetClassName && previous._targetClassName !== this._targetClassName) {\n          throw new Error('Related object must be of class ' + previous._targetClassName + ', but ' + (this._targetClassName || 'null') + ' was passed in.');\n        }\n\n        var newAdd = previous.relationsToAdd.concat([]);\n        this.relationsToRemove.forEach(function (r) {\n          var index = newAdd.indexOf(r);\n\n          if (index > -1) {\n            newAdd.splice(index, 1);\n          }\n        });\n        this.relationsToAdd.forEach(function (r) {\n          var index = newAdd.indexOf(r);\n\n          if (index < 0) {\n            newAdd.push(r);\n          }\n        });\n        var newRemove = previous.relationsToRemove.concat([]);\n        this.relationsToAdd.forEach(function (r) {\n          var index = newRemove.indexOf(r);\n\n          if (index > -1) {\n            newRemove.splice(index, 1);\n          }\n        });\n        this.relationsToRemove.forEach(function (r) {\n          var index = newRemove.indexOf(r);\n\n          if (index < 0) {\n            newRemove.push(r);\n          }\n        });\n        var newRelation = new RelationOp(newAdd, newRemove);\n        newRelation._targetClassName = this._targetClassName;\n        return newRelation;\n      }\n\n      throw new Error('Cannot merge Relation Op with the previous Op');\n    }\n  }, {\n    key: \"toJSON\",\n    value: function ()\n    /*: { __op?: string; objects?: mixed; ops?: mixed }*/\n    {\n      var _this7 = this;\n\n      var idToPointer = function (id) {\n        return {\n          __type: 'Pointer',\n          className: _this7._targetClassName,\n          objectId: id\n        };\n      };\n\n      var adds = null;\n      var removes = null;\n      var pointers = null;\n\n      if (this.relationsToAdd.length > 0) {\n        pointers = this.relationsToAdd.map(idToPointer);\n        adds = {\n          __op: 'AddRelation',\n          objects: pointers\n        };\n      }\n\n      if (this.relationsToRemove.length > 0) {\n        pointers = this.relationsToRemove.map(idToPointer);\n        removes = {\n          __op: 'RemoveRelation',\n          objects: pointers\n        };\n      }\n\n      if (adds && removes) {\n        return {\n          __op: 'Batch',\n          ops: [adds, removes]\n        };\n      }\n\n      return adds || removes || {};\n    }\n  }]);\n  return RelationOp;\n}(Op);\n\nexports.RelationOp = RelationOp;","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _ParseGeoPoint = _interopRequireDefault(require(\"./ParseGeoPoint\"));\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n/**\n * Creates a new Polygon with any of the following forms:<br>\n *   <pre>\n *   new Polygon([[0,0],[0,1],[1,1],[1,0]])\n *   new Polygon([GeoPoint, GeoPoint, GeoPoint])\n *   </pre>\n *\n * <p>Represents a coordinates that may be associated\n * with a key in a ParseObject or used as a reference point for geo queries.\n * This allows proximity-based queries on the key.</p>\n *\n * <p>Example:<pre>\n *   var polygon = new Parse.Polygon([[0,0],[0,1],[1,1],[1,0]]);\n *   var object = new Parse.Object(\"PlaceObject\");\n *   object.set(\"area\", polygon);\n *   object.save();</pre></p>\n * @alias Parse.Polygon\n */\n\n\nvar ParsePolygon =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param {(Number[][]|Parse.GeoPoint[])} coordinates An Array of coordinate pairs\n   */\n  function ParsePolygon(arg1\n  /*: Array<Array<number>> | Array<ParseGeoPoint>*/\n  ) {\n    (0, _classCallCheck2.default)(this, ParsePolygon);\n    (0, _defineProperty2.default)(this, \"_coordinates\", void 0);\n    this._coordinates = ParsePolygon._validate(arg1);\n  }\n  /**\n   * Coordinates value for this Polygon.\n   * Throws an exception if not valid type.\n   * @property coordinates\n   * @type Array\n   */\n\n\n  (0, _createClass2.default)(ParsePolygon, [{\n    key: \"toJSON\",\n\n    /**\n     * Returns a JSON representation of the Polygon, suitable for Parse.\n     * @return {Object}\n     */\n    value: function ()\n    /*: { __type: string; coordinates: Array<Array<number>>;}*/\n    {\n      ParsePolygon._validate(this._coordinates);\n\n      return {\n        __type: 'Polygon',\n        coordinates: this._coordinates\n      };\n    }\n    /**\n     * Checks if two polygons are equal\n     * @param {(Parse.Polygon|Object)} other\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"equals\",\n    value: function (other\n    /*: mixed*/\n    )\n    /*: boolean*/\n    {\n      if (!(other instanceof ParsePolygon) || this.coordinates.length !== other.coordinates.length) {\n        return false;\n      }\n\n      var isEqual = true;\n\n      for (var i = 1; i < this._coordinates.length; i += 1) {\n        if (this._coordinates[i][0] != other.coordinates[i][0] || this._coordinates[i][1] != other.coordinates[i][1]) {\n          isEqual = false;\n          break;\n        }\n      }\n\n      return isEqual;\n    }\n    /**\n     *\n     * @param {Parse.GeoPoint} point\n     * @returns {Boolean} Returns if the point is contained in the polygon\n     */\n\n  }, {\n    key: \"containsPoint\",\n    value: function (point\n    /*: ParseGeoPoint*/\n    )\n    /*: boolean*/\n    {\n      var minX = this._coordinates[0][0];\n      var maxX = this._coordinates[0][0];\n      var minY = this._coordinates[0][1];\n      var maxY = this._coordinates[0][1];\n\n      for (var i = 1; i < this._coordinates.length; i += 1) {\n        var p = this._coordinates[i];\n        minX = Math.min(p[0], minX);\n        maxX = Math.max(p[0], maxX);\n        minY = Math.min(p[1], minY);\n        maxY = Math.max(p[1], maxY);\n      }\n\n      var outside = point.latitude < minX || point.latitude > maxX || point.longitude < minY || point.longitude > maxY;\n\n      if (outside) {\n        return false;\n      }\n\n      var inside = false;\n\n      for (var _i = 0, j = this._coordinates.length - 1; _i < this._coordinates.length; j = _i++) {\n        var startX = this._coordinates[_i][0];\n        var startY = this._coordinates[_i][1];\n        var endX = this._coordinates[j][0];\n        var endY = this._coordinates[j][1];\n        var intersect = startY > point.longitude != endY > point.longitude && point.latitude < (endX - startX) * (point.longitude - startY) / (endY - startY) + startX;\n\n        if (intersect) {\n          inside = !inside;\n        }\n      }\n\n      return inside;\n    }\n    /**\n     * Validates that the list of coordinates can form a valid polygon\n     * @param {Array} coords the list of coordinated to validate as a polygon\n     * @throws {TypeError}\n     */\n\n  }, {\n    key: \"coordinates\",\n    get: function ()\n    /*: Array<Array<number>>*/\n    {\n      return this._coordinates;\n    },\n    set: function (coords\n    /*: Array<Array<number>> | Array<ParseGeoPoint>*/\n    ) {\n      this._coordinates = ParsePolygon._validate(coords);\n    }\n  }], [{\n    key: \"_validate\",\n    value: function (coords\n    /*: Array<Array<number>> | Array<ParseGeoPoint>*/\n    )\n    /*: Array<Array<number>>*/\n    {\n      if (!Array.isArray(coords)) {\n        throw new TypeError('Coordinates must be an Array');\n      }\n\n      if (coords.length < 3) {\n        throw new TypeError('Polygon must have at least 3 GeoPoints or Points');\n      }\n\n      var points = [];\n\n      for (var i = 0; i < coords.length; i += 1) {\n        var coord = coords[i];\n        var geoPoint = void 0;\n\n        if (coord instanceof _ParseGeoPoint.default) {\n          geoPoint = coord;\n        } else if (Array.isArray(coord) && coord.length === 2) {\n          geoPoint = new _ParseGeoPoint.default(coord[0], coord[1]);\n        } else {\n          throw new TypeError('Coordinates must be an Array of GeoPoints or Points');\n        }\n\n        points.push([geoPoint.latitude, geoPoint.longitude]);\n      }\n\n      return points;\n    }\n  }]);\n  return ParsePolygon;\n}();\n\nvar _default = ParsePolygon;\nexports.default = _default;","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\n\nvar _encode = _interopRequireDefault(require(\"./encode\"));\n\nvar _promiseUtils = require(\"./promiseUtils\");\n\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\n\nvar _ParseGeoPoint = _interopRequireDefault(require(\"./ParseGeoPoint\"));\n\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\n\nvar _OfflineQuery = _interopRequireDefault(require(\"./OfflineQuery\"));\n\nvar _LocalDatastoreUtils = require(\"./LocalDatastoreUtils\");\n/*\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n/**\n * Converts a string into a regex that matches it.\n * Surrounding with \\Q .. \\E does this, we just need to escape any \\E's in\n * the text separately.\n * @private\n */\n\n\nfunction quote(s\n/*: string*/\n) {\n  return '\\\\Q' + s.replace('\\\\E', '\\\\E\\\\\\\\E\\\\Q') + '\\\\E';\n}\n/**\n * Extracts the class name from queries. If not all queries have the same\n * class name an error will be thrown.\n */\n\n\nfunction _getClassNameFromQueries(queries\n/*: Array<ParseQuery>*/\n)\n/*: ?string*/\n{\n  var className = null;\n  queries.forEach(function (q) {\n    if (!className) {\n      className = q.className;\n    }\n\n    if (className !== q.className) {\n      throw new Error('All queries must be for the same class.');\n    }\n  });\n  return className;\n}\n/*\n * Handles pre-populating the result data of a query with select fields,\n * making sure that the data object contains keys for all objects that have\n * been requested with a select, so that our cached state updates correctly.\n */\n\n\nfunction handleSelectResult(data\n/*: any*/\n, select\n/*: Array<string>*/\n) {\n  var serverDataMask = {};\n  select.forEach(function (field) {\n    var hasSubObjectSelect = field.indexOf(\".\") !== -1;\n\n    if (!hasSubObjectSelect && !data.hasOwnProperty(field)) {\n      // this field was selected, but is missing from the retrieved data\n      data[field] = undefined;\n    } else if (hasSubObjectSelect) {\n      // this field references a sub-object,\n      // so we need to walk down the path components\n      var pathComponents = field.split(\".\");\n      var _obj = data;\n      var serverMask = serverDataMask;\n      pathComponents.forEach(function (component, index, arr) {\n        // add keys if the expected data is missing\n        if (_obj && !_obj.hasOwnProperty(component)) {\n          _obj[component] = undefined;\n        }\n\n        if (_obj !== undefined) {\n          _obj = _obj[component];\n        } //add this path component to the server mask so we can fill it in later if needed\n\n\n        if (index < arr.length - 1) {\n          if (!serverMask[component]) {\n            serverMask[component] = {};\n          }\n\n          serverMask = serverMask[component];\n        }\n      });\n    }\n  });\n\n  if (Object.keys(serverDataMask).length > 0) {\n    // When selecting from sub-objects, we don't want to blow away the missing\n    // information that we may have retrieved before. We've already added any\n    // missing selected keys to sub-objects, but we still need to add in the\n    // data for any previously retrieved sub-objects that were not selected.\n    var serverData = _CoreManager.default.getObjectStateController().getServerData({\n      id: data.objectId,\n      className: data.className\n    });\n\n    copyMissingDataWithMask(serverData, data, serverDataMask, false);\n  }\n}\n\nfunction copyMissingDataWithMask(src, dest, mask, copyThisLevel) {\n  //copy missing elements at this level\n  if (copyThisLevel) {\n    for (var _key in src) {\n      if (src.hasOwnProperty(_key) && !dest.hasOwnProperty(_key)) {\n        dest[_key] = src[_key];\n      }\n    }\n  }\n\n  for (var _key2 in mask) {\n    if (dest[_key2] !== undefined && dest[_key2] !== null && src !== undefined && src !== null) {\n      //traverse into objects as needed\n      copyMissingDataWithMask(src[_key2], dest[_key2], mask[_key2], true);\n    }\n  }\n}\n\nfunction handleOfflineSort(a, b, sorts) {\n  var order = sorts[0];\n  var operator = order.slice(0, 1);\n  var isDescending = operator === '-';\n\n  if (isDescending) {\n    order = order.substring(1);\n  }\n\n  if (order === '_created_at') {\n    order = 'createdAt';\n  }\n\n  if (order === '_updated_at') {\n    order = 'updatedAt';\n  }\n\n  if (!/^[A-Za-z][0-9A-Za-z_]*$/.test(order) || order === 'password') {\n    throw new _ParseError.default(_ParseError.default.INVALID_KEY_NAME, \"Invalid Key: \".concat(order));\n  }\n\n  var field1 = a.get(order);\n  var field2 = b.get(order);\n\n  if (field1 < field2) {\n    return isDescending ? 1 : -1;\n  }\n\n  if (field1 > field2) {\n    return isDescending ? -1 : 1;\n  }\n\n  if (sorts.length > 1) {\n    var remainingSorts = sorts.slice(1);\n    return handleOfflineSort(a, b, remainingSorts);\n  }\n\n  return 0;\n}\n/**\n * Creates a new parse Parse.Query for the given Parse.Object subclass.\n *\n * <p>Parse.Query defines a query that is used to fetch Parse.Objects. The\n * most common use case is finding all objects that match a query through the\n * <code>find</code> method. for example, this sample code fetches all objects\n * of class <code>myclass</code>. it calls a different function depending on\n * whether the fetch succeeded or not.\n *\n * <pre>\n * var query = new Parse.Query(myclass);\n * query.find().then((results) => {\n *   // results is an array of parse.object.\n * }).catch((error) =>  {\n *  // error is an instance of parse.error.\n * });</pre></p>\n *\n * <p>a Parse.Query can also be used to retrieve a single object whose id is\n * known, through the get method. for example, this sample code fetches an\n * object of class <code>myclass</code> and id <code>myid</code>. it calls a\n * different function depending on whether the fetch succeeded or not.\n *\n * <pre>\n * var query = new Parse.Query(myclass);\n * query.get(myid).then((object) => {\n *     // object is an instance of parse.object.\n * }).catch((error) =>  {\n *  // error is an instance of parse.error.\n * });</pre></p>\n *\n * <p>a Parse.Query can also be used to count the number of objects that match\n * the query without retrieving all of those objects. for example, this\n * sample code counts the number of objects of the class <code>myclass</code>\n * <pre>\n * var query = new Parse.Query(myclass);\n * query.count().then((number) => {\n *     // there are number instances of myclass.\n * }).catch((error) => {\n *     // error is an instance of Parse.Error.\n * });</pre></p>\n * @alias Parse.Query\n */\n\n\nvar ParseQuery =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @property className\n   * @type String\n   */\n\n  /**\n   * @param {(String|Parse.Object)} objectClass An instance of a subclass of Parse.Object, or a Parse className string.\n   */\n  function ParseQuery(objectClass\n  /*: string | ParseObject*/\n  ) {\n    (0, _classCallCheck2.default)(this, ParseQuery);\n    (0, _defineProperty2.default)(this, \"className\", void 0);\n    (0, _defineProperty2.default)(this, \"_where\", void 0);\n    (0, _defineProperty2.default)(this, \"_include\", void 0);\n    (0, _defineProperty2.default)(this, \"_select\", void 0);\n    (0, _defineProperty2.default)(this, \"_limit\", void 0);\n    (0, _defineProperty2.default)(this, \"_skip\", void 0);\n    (0, _defineProperty2.default)(this, \"_order\", void 0);\n    (0, _defineProperty2.default)(this, \"_queriesLocalDatastore\", void 0);\n    (0, _defineProperty2.default)(this, \"_localDatastorePinName\", void 0);\n    (0, _defineProperty2.default)(this, \"_extraOptions\", void 0);\n\n    if (typeof objectClass === 'string') {\n      if (objectClass === 'User' && _CoreManager.default.get('PERFORM_USER_REWRITE')) {\n        this.className = '_User';\n      } else {\n        this.className = objectClass;\n      }\n    } else if (objectClass instanceof _ParseObject.default) {\n      this.className = objectClass.className;\n    } else if (typeof objectClass === 'function') {\n      if (typeof objectClass.className === 'string') {\n        this.className = objectClass.className;\n      } else {\n        var _obj2 = new objectClass();\n\n        this.className = _obj2.className;\n      }\n    } else {\n      throw new TypeError('A ParseQuery must be constructed with a ParseObject or class name.');\n    }\n\n    this._where = {};\n    this._include = [];\n    this._limit = -1; // negative limit is not sent in the server request\n\n    this._skip = 0;\n    this._queriesLocalDatastore = false;\n    this._localDatastorePinName = null;\n    this._extraOptions = {};\n  }\n  /**\n   * Adds constraint that at least one of the passed in queries matches.\n   * @param {Array} queries\n   * @return {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  (0, _createClass2.default)(ParseQuery, [{\n    key: \"_orQuery\",\n    value: function (queries\n    /*: Array<ParseQuery>*/\n    )\n    /*: ParseQuery*/\n    {\n      var queryJSON = queries.map(function (q) {\n        return q.toJSON().where;\n      });\n      this._where.$or = queryJSON;\n      return this;\n    }\n    /**\n     * Adds constraint that all of the passed in queries match.\n     * @param {Array} queries\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n\n  }, {\n    key: \"_andQuery\",\n    value: function (queries\n    /*: Array<ParseQuery>*/\n    )\n    /*: ParseQuery*/\n    {\n      var queryJSON = queries.map(function (q) {\n        return q.toJSON().where;\n      });\n      this._where.$and = queryJSON;\n      return this;\n    }\n    /**\n     * Adds constraint that none of the passed in queries match.\n     * @param {Array} queries\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n\n  }, {\n    key: \"_norQuery\",\n    value: function (queries\n    /*: Array<ParseQuery>*/\n    )\n    /*: ParseQuery*/\n    {\n      var queryJSON = queries.map(function (q) {\n        return q.toJSON().where;\n      });\n      this._where.$nor = queryJSON;\n      return this;\n    }\n    /**\n     * Helper for condition queries\n     */\n\n  }, {\n    key: \"_addCondition\",\n    value: function (key\n    /*: string*/\n    , condition\n    /*: string*/\n    , value\n    /*: mixed*/\n    )\n    /*: ParseQuery*/\n    {\n      if (!this._where[key] || typeof this._where[key] === 'string') {\n        this._where[key] = {};\n      }\n\n      this._where[key][condition] = (0, _encode.default)(value, false, true);\n      return this;\n    }\n    /**\n     * Converts string for regular expression at the beginning\n     */\n\n  }, {\n    key: \"_regexStartWith\",\n    value: function (string\n    /*: string*/\n    )\n    /*: string*/\n    {\n      return '^' + quote(string);\n    }\n  }, {\n    key: \"_handleOfflineQuery\",\n    value: function () {\n      var _handleOfflineQuery2 = (0, _asyncToGenerator2.default)(\n      /*#__PURE__*/\n      _regenerator.default.mark(function _callee(params\n      /*: any*/\n      ) {\n        var _this2 = this;\n\n        var localDatastore, objects, results, keys, alwaysSelectedKeys, sorts, limit;\n        return _regenerator.default.wrap(function (_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _OfflineQuery.default.validateQuery(this);\n\n                localDatastore = _CoreManager.default.getLocalDatastore();\n                _context.next = 4;\n                return localDatastore._serializeObjectsFromPinName(this._localDatastorePinName);\n\n              case 4:\n                objects = _context.sent;\n                results = objects.map(function (json, index, arr) {\n                  var object = _ParseObject.default.fromJSON(json, false);\n\n                  if (json._localId && !json.objectId) {\n                    object._localId = json._localId;\n                  }\n\n                  if (!_OfflineQuery.default.matchesQuery(_this2.className, object, arr, _this2)) {\n                    return null;\n                  }\n\n                  return object;\n                }).filter(function (object) {\n                  return object !== null;\n                });\n\n                if (params.keys) {\n                  keys = params.keys.split(',');\n                  alwaysSelectedKeys = ['className', 'objectId', 'createdAt', 'updatedAt', 'ACL'];\n                  keys = keys.concat(alwaysSelectedKeys);\n                  results = results.map(function (object) {\n                    var json = object._toFullJSON();\n\n                    Object.keys(json).forEach(function (key) {\n                      if (!keys.includes(key)) {\n                        delete json[key];\n                      }\n                    });\n                    return _ParseObject.default.fromJSON(json, false);\n                  });\n                }\n\n                if (params.order) {\n                  sorts = params.order.split(',');\n                  results.sort(function (a, b) {\n                    return handleOfflineSort(a, b, sorts);\n                  });\n                }\n\n                if (params.skip) {\n                  if (params.skip >= results.length) {\n                    results = [];\n                  } else {\n                    results = results.splice(params.skip, results.length);\n                  }\n                }\n\n                limit = results.length;\n\n                if (params.limit !== 0 && params.limit < results.length) {\n                  limit = params.limit;\n                }\n\n                results = results.splice(0, limit);\n                return _context.abrupt(\"return\", results);\n\n              case 13:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      return function () {\n        return _handleOfflineQuery2.apply(this, arguments);\n      };\n    }()\n    /**\n     * Returns a JSON representation of this query.\n     * @return {Object} The JSON representation of the query.\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function ()\n    /*: QueryJSON*/\n    {\n      var params\n      /*: QueryJSON*/\n      = {\n        where: this._where\n      };\n\n      if (this._include.length) {\n        params.include = this._include.join(',');\n      }\n\n      if (this._select) {\n        params.keys = this._select.join(',');\n      }\n\n      if (this._limit >= 0) {\n        params.limit = this._limit;\n      }\n\n      if (this._skip > 0) {\n        params.skip = this._skip;\n      }\n\n      if (this._order) {\n        params.order = this._order.join(',');\n      }\n\n      for (var _key3 in this._extraOptions) {\n        params[_key3] = this._extraOptions[_key3];\n      }\n\n      return params;\n    }\n    /**\n     * Return a query with conditions from json, can be useful to send query from server side to client\n     * Not static, all query conditions was set before calling this method will be deleted.\n     * For example on the server side we have\n     * var query = new Parse.Query(\"className\");\n     * query.equalTo(key: value);\n     * query.limit(100);\n     * ... (others queries)\n     * Create JSON representation of Query Object\n     * var jsonFromServer = query.fromJSON();\n     *\n     * On client side getting query:\n     * var query = new Parse.Query(\"className\");\n     * query.fromJSON(jsonFromServer);\n     *\n     * and continue to query...\n     * query.skip(100).find().then(...);\n     * @param {QueryJSON} json from Parse.Query.toJSON() method\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n\n  }, {\n    key: \"withJSON\",\n    value: function (json\n    /*: QueryJSON*/\n    )\n    /*: ParseQuery*/\n    {\n      if (json.where) {\n        this._where = json.where;\n      }\n\n      if (json.include) {\n        this._include = json.include.split(\",\");\n      }\n\n      if (json.keys) {\n        this._select = json.keys.split(\",\");\n      }\n\n      if (json.limit) {\n        this._limit = json.limit;\n      }\n\n      if (json.skip) {\n        this._skip = json.skip;\n      }\n\n      if (json.order) {\n        this._order = json.order.split(\",\");\n      }\n\n      for (var _key4 in json) {\n        if (json.hasOwnProperty(_key4)) {\n          if ([\"where\", \"include\", \"keys\", \"limit\", \"skip\", \"order\"].indexOf(_key4) === -1) {\n            this._extraOptions[_key4] = json[_key4];\n          }\n        }\n      }\n\n      return this;\n    }\n    /**\n       * Static method to restore Parse.Query by json representation\n       * Internally calling Parse.Query.withJSON\n       * @param {String} className\n       * @param {QueryJSON} json from Parse.Query.toJSON() method\n       * @returns {Parse.Query} new created query\n       */\n\n  }, {\n    key: \"get\",\n\n    /**\n     * Constructs a Parse.Object whose id is already known by fetching data from\n     * the server.  Either options.success or options.error is called when the\n     * find completes. Unlike the <code>first</code> method, it never returns undefined.\n     *\n     * @param {String} objectId The id of the object to be fetched.\n     * @param {Object} options\n     * Valid options are:<ul>\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n     *     be used for this request.\n     *   <li>sessionToken: A valid session token, used for making a request on\n     *       behalf of a specific user.\n     * </ul>\n     *\n     * @return {Promise} A promise that is resolved with the result when\n     * the query completes.\n     */\n    value: function (objectId\n    /*: string*/\n    , options\n    /*:: ?: FullOptions*/\n    )\n    /*: Promise<ParseObject>*/\n    {\n      this.equalTo('objectId', objectId);\n      var firstOptions = {};\n\n      if (options && options.hasOwnProperty('useMasterKey')) {\n        firstOptions.useMasterKey = options.useMasterKey;\n      }\n\n      if (options && options.hasOwnProperty('sessionToken')) {\n        firstOptions.sessionToken = options.sessionToken;\n      }\n\n      return this.first(firstOptions).then(function (response) {\n        if (response) {\n          return response;\n        }\n\n        var errorObject = new _ParseError.default(_ParseError.default.OBJECT_NOT_FOUND, 'Object not found.');\n        return Promise.reject(errorObject);\n      });\n    }\n    /**\n     * Retrieves a list of ParseObjects that satisfy this query.\n     * Either options.success or options.error is called when the find\n     * completes.\n     *\n     * @param {Object} options Valid options\n     * are:<ul>\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n     *     be used for this request.\n     *   <li>sessionToken: A valid session token, used for making a request on\n     *       behalf of a specific user.\n     * </ul>\n     *\n     * @return {Promise} A promise that is resolved with the results when\n     * the query completes.\n     */\n\n  }, {\n    key: \"find\",\n    value: function (options\n    /*:: ?: FullOptions*/\n    )\n    /*: Promise<Array<ParseObject>>*/\n    {\n      var _this3 = this;\n\n      options = options || {};\n      var findOptions = {};\n\n      if (options.hasOwnProperty('useMasterKey')) {\n        findOptions.useMasterKey = options.useMasterKey;\n      }\n\n      if (options.hasOwnProperty('sessionToken')) {\n        findOptions.sessionToken = options.sessionToken;\n      }\n\n      var controller = _CoreManager.default.getQueryController();\n\n      var select = this._select;\n\n      if (this._queriesLocalDatastore) {\n        return this._handleOfflineQuery(this.toJSON());\n      }\n\n      return controller.find(this.className, this.toJSON(), findOptions).then(function (response) {\n        return response.results.map(function (data) {\n          // In cases of relations, the server may send back a className\n          // on the top level of the payload\n          var override = response.className || _this3.className;\n\n          if (!data.className) {\n            data.className = override;\n          } // Make sure the data object contains keys for all objects that\n          // have been requested with a select, so that our cached state\n          // updates correctly.\n\n\n          if (select) {\n            handleSelectResult(data, select);\n          }\n\n          return _ParseObject.default.fromJSON(data, !select);\n        });\n      });\n    }\n    /**\n     * Counts the number of objects that match this query.\n     * Either options.success or options.error is called when the count\n     * completes.\n     *\n     * @param {Object} options\n     * Valid options are:<ul>\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n     *     be used for this request.\n     *   <li>sessionToken: A valid session token, used for making a request on\n     *       behalf of a specific user.\n     * </ul>\n     *\n     * @return {Promise} A promise that is resolved with the count when\n     * the query completes.\n     */\n\n  }, {\n    key: \"count\",\n    value: function (options\n    /*:: ?: FullOptions*/\n    )\n    /*: Promise<number>*/\n    {\n      options = options || {};\n      var findOptions = {};\n\n      if (options.hasOwnProperty('useMasterKey')) {\n        findOptions.useMasterKey = options.useMasterKey;\n      }\n\n      if (options.hasOwnProperty('sessionToken')) {\n        findOptions.sessionToken = options.sessionToken;\n      }\n\n      var controller = _CoreManager.default.getQueryController();\n\n      var params = this.toJSON();\n      params.limit = 0;\n      params.count = 1;\n      return controller.find(this.className, params, findOptions).then(function (result) {\n        return result.count;\n      });\n    }\n    /**\n     * Executes a distinct query and returns unique values\n     *\n     * @param {String} key A field to find distinct values\n     * @param {Object} options\n     * Valid options are:<ul>\n     *   <li>sessionToken: A valid session token, used for making a request on\n     *       behalf of a specific user.\n     * </ul>\n     *\n     * @return {Promise} A promise that is resolved with the query completes.\n     */\n\n  }, {\n    key: \"distinct\",\n    value: function (key\n    /*: string*/\n    , options\n    /*:: ?: FullOptions*/\n    )\n    /*: Promise<Array<mixed>>*/\n    {\n      options = options || {};\n      var distinctOptions = {};\n      distinctOptions.useMasterKey = true;\n\n      if (options.hasOwnProperty('sessionToken')) {\n        distinctOptions.sessionToken = options.sessionToken;\n      }\n\n      var controller = _CoreManager.default.getQueryController();\n\n      var params = {\n        distinct: key,\n        where: this._where\n      };\n      return controller.aggregate(this.className, params, distinctOptions).then(function (results) {\n        return results.results;\n      });\n    }\n    /**\n     * Executes an aggregate query and returns aggregate results\n     *\n     * @param {Mixed} pipeline Array or Object of stages to process query\n     * @param {Object} options Valid options are:<ul>\n     *   <li>sessionToken: A valid session token, used for making a request on\n     *       behalf of a specific user.\n     * </ul>\n     *\n     * @return {Promise} A promise that is resolved with the query completes.\n     */\n\n  }, {\n    key: \"aggregate\",\n    value: function (pipeline\n    /*: mixed*/\n    , options\n    /*:: ?: FullOptions*/\n    )\n    /*: Promise<Array<mixed>>*/\n    {\n      options = options || {};\n      var aggregateOptions = {};\n      aggregateOptions.useMasterKey = true;\n\n      if (options.hasOwnProperty('sessionToken')) {\n        aggregateOptions.sessionToken = options.sessionToken;\n      }\n\n      var controller = _CoreManager.default.getQueryController();\n\n      if (!Array.isArray(pipeline) && (0, _typeof2.default)(pipeline) !== 'object') {\n        throw new Error('Invalid pipeline must be Array or Object');\n      }\n\n      return controller.aggregate(this.className, {\n        pipeline: pipeline\n      }, aggregateOptions).then(function (results) {\n        return results.results;\n      });\n    }\n    /**\n     * Retrieves at most one Parse.Object that satisfies this query.\n     *\n     * Either options.success or options.error is called when it completes.\n     * success is passed the object if there is one. otherwise, undefined.\n     *\n     * @param {Object} options Valid options are:<ul>\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n     *     be used for this request.\n     *   <li>sessionToken: A valid session token, used for making a request on\n     *       behalf of a specific user.\n     * </ul>\n     *\n     * @return {Promise} A promise that is resolved with the object when\n     * the query completes.\n     */\n\n  }, {\n    key: \"first\",\n    value: function (options\n    /*:: ?: FullOptions*/\n    )\n    /*: Promise<ParseObject | void>*/\n    {\n      var _this4 = this;\n\n      options = options || {};\n      var findOptions = {};\n\n      if (options.hasOwnProperty('useMasterKey')) {\n        findOptions.useMasterKey = options.useMasterKey;\n      }\n\n      if (options.hasOwnProperty('sessionToken')) {\n        findOptions.sessionToken = options.sessionToken;\n      }\n\n      var controller = _CoreManager.default.getQueryController();\n\n      var params = this.toJSON();\n      params.limit = 1;\n      var select = this._select;\n\n      if (this._queriesLocalDatastore) {\n        return this._handleOfflineQuery(params).then(function (objects) {\n          if (!objects[0]) {\n            return undefined;\n          }\n\n          return objects[0];\n        });\n      }\n\n      return controller.find(this.className, params, findOptions).then(function (response) {\n        var objects = response.results;\n\n        if (!objects[0]) {\n          return undefined;\n        }\n\n        if (!objects[0].className) {\n          objects[0].className = _this4.className;\n        } // Make sure the data object contains keys for all objects that\n        // have been requested with a select, so that our cached state\n        // updates correctly.\n\n\n        if (select) {\n          handleSelectResult(objects[0], select);\n        }\n\n        return _ParseObject.default.fromJSON(objects[0], !select);\n      });\n    }\n    /**\n     * Iterates over each result of a query, calling a callback for each one. If\n     * the callback returns a promise, the iteration will not continue until\n     * that promise has been fulfilled. If the callback returns a rejected\n     * promise, then iteration will stop with that error. The items are\n     * processed in an unspecified order. The query may not have any sort order,\n     * and may not use limit or skip.\n     * @param {Function} callback Callback that will be called with each result\n     *     of the query.\n     * @param {Object} options Valid options are:<ul>\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n     *     be used for this request.\n     *   <li>sessionToken: A valid session token, used for making a request on\n     *       behalf of a specific user.\n     * </ul>\n     * @return {Promise} A promise that will be fulfilled once the\n     *     iteration has completed.\n     */\n\n  }, {\n    key: \"each\",\n    value: function (callback\n    /*: (obj: ParseObject) => any*/\n    , options\n    /*:: ?: BatchOptions*/\n    )\n    /*: Promise<Array<ParseObject>>*/\n    {\n      options = options || {};\n\n      if (this._order || this._skip || this._limit >= 0) {\n        return Promise.reject('Cannot iterate on a query with sort, skip, or limit.');\n      }\n\n      var query = new ParseQuery(this.className); // We can override the batch size from the options.\n      // This is undocumented, but useful for testing.\n\n      query._limit = options.batchSize || 100;\n      query._include = this._include.map(function (i) {\n        return i;\n      });\n\n      if (this._select) {\n        query._select = this._select.map(function (s) {\n          return s;\n        });\n      }\n\n      query._where = {};\n\n      for (var _attr in this._where) {\n        var val = this._where[_attr];\n\n        if (Array.isArray(val)) {\n          query._where[_attr] = val.map(function (v) {\n            return v;\n          });\n        } else if (val && (0, _typeof2.default)(val) === 'object') {\n          var conditionMap = {};\n          query._where[_attr] = conditionMap;\n\n          for (var cond in val) {\n            conditionMap[cond] = val[cond];\n          }\n        } else {\n          query._where[_attr] = val;\n        }\n      }\n\n      query.ascending('objectId');\n      var findOptions = {};\n\n      if (options.hasOwnProperty('useMasterKey')) {\n        findOptions.useMasterKey = options.useMasterKey;\n      }\n\n      if (options.hasOwnProperty('sessionToken')) {\n        findOptions.sessionToken = options.sessionToken;\n      }\n\n      var finished = false;\n      return (0, _promiseUtils.continueWhile)(function () {\n        return !finished;\n      }, function () {\n        return query.find(findOptions).then(function (results) {\n          var callbacksDone = Promise.resolve();\n          results.forEach(function (result) {\n            callbacksDone = callbacksDone.then(function () {\n              return callback(result);\n            });\n          });\n          return callbacksDone.then(function () {\n            if (results.length >= query._limit) {\n              query.greaterThan('objectId', results[results.length - 1].id);\n            } else {\n              finished = true;\n            }\n          });\n        });\n      });\n    }\n    /** Query Conditions **/\n\n    /**\n     * Adds a constraint to the query that requires a particular key's value to\n     * be equal to the provided value.\n     * @param {String} key The key to check.\n     * @param value The value that the Parse.Object must contain.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n\n  }, {\n    key: \"equalTo\",\n    value: function (key\n    /*: string*/\n    , value\n    /*: mixed*/\n    )\n    /*: ParseQuery*/\n    {\n      if (typeof value === 'undefined') {\n        return this.doesNotExist(key);\n      }\n\n      this._where[key] = (0, _encode.default)(value, false, true);\n      return this;\n    }\n    /**\n     * Adds a constraint to the query that requires a particular key's value to\n     * be not equal to the provided value.\n     * @param {String} key The key to check.\n     * @param value The value that must not be equalled.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n\n  }, {\n    key: \"notEqualTo\",\n    value: function (key\n    /*: string*/\n    , value\n    /*: mixed*/\n    )\n    /*: ParseQuery*/\n    {\n      return this._addCondition(key, '$ne', value);\n    }\n    /**\n     * Adds a constraint to the query that requires a particular key's value to\n     * be less than the provided value.\n     * @param {String} key The key to check.\n     * @param value The value that provides an upper bound.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n\n  }, {\n    key: \"lessThan\",\n    value: function (key\n    /*: string*/\n    , value\n    /*: mixed*/\n    )\n    /*: ParseQuery*/\n    {\n      return this._addCondition(key, '$lt', value);\n    }\n    /**\n     * Adds a constraint to the query that requires a particular key's value to\n     * be greater than the provided value.\n     * @param {String} key The key to check.\n     * @param value The value that provides an lower bound.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n\n  }, {\n    key: \"greaterThan\",\n    value: function (key\n    /*: string*/\n    , value\n    /*: mixed*/\n    )\n    /*: ParseQuery*/\n    {\n      return this._addCondition(key, '$gt', value);\n    }\n    /**\n     * Adds a constraint to the query that requires a particular key's value to\n     * be less than or equal to the provided value.\n     * @param {String} key The key to check.\n     * @param value The value that provides an upper bound.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n\n  }, {\n    key: \"lessThanOrEqualTo\",\n    value: function (key\n    /*: string*/\n    , value\n    /*: mixed*/\n    )\n    /*: ParseQuery*/\n    {\n      return this._addCondition(key, '$lte', value);\n    }\n    /**\n     * Adds a constraint to the query that requires a particular key's value to\n     * be greater than or equal to the provided value.\n     * @param {String} key The key to check.\n     * @param value The value that provides an lower bound.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n\n  }, {\n    key: \"greaterThanOrEqualTo\",\n    value: function (key\n    /*: string*/\n    , value\n    /*: mixed*/\n    )\n    /*: ParseQuery*/\n    {\n      return this._addCondition(key, '$gte', value);\n    }\n    /**\n     * Adds a constraint to the query that requires a particular key's value to\n     * be contained in the provided list of values.\n     * @param {String} key The key to check.\n     * @param {Array} values The values that will match.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n\n  }, {\n    key: \"containedIn\",\n    value: function (key\n    /*: string*/\n    , value\n    /*: mixed*/\n    )\n    /*: ParseQuery*/\n    {\n      return this._addCondition(key, '$in', value);\n    }\n    /**\n     * Adds a constraint to the query that requires a particular key's value to\n     * not be contained in the provided list of values.\n     * @param {String} key The key to check.\n     * @param {Array} values The values that will not match.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n\n  }, {\n    key: \"notContainedIn\",\n    value: function (key\n    /*: string*/\n    , value\n    /*: mixed*/\n    )\n    /*: ParseQuery*/\n    {\n      return this._addCondition(key, '$nin', value);\n    }\n    /**\n     * Adds a constraint to the query that requires a particular key's value to\n     * be contained by the provided list of values. Get objects where all array elements match.\n     * @param {String} key The key to check.\n     * @param {Array} values The values that will match.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n\n  }, {\n    key: \"containedBy\",\n    value: function (key\n    /*: string*/\n    , value\n    /*: Array<mixed>*/\n    )\n    /*: ParseQuery*/\n    {\n      return this._addCondition(key, '$containedBy', value);\n    }\n    /**\n     * Adds a constraint to the query that requires a particular key's value to\n     * contain each one of the provided list of values.\n     * @param {String} key The key to check.  This key's value must be an array.\n     * @param {Array} values The values that will match.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n\n  }, {\n    key: \"containsAll\",\n    value: function (key\n    /*: string*/\n    , values\n    /*: Array<mixed>*/\n    )\n    /*: ParseQuery*/\n    {\n      return this._addCondition(key, '$all', values);\n    }\n    /**\n     * Adds a constraint to the query that requires a particular key's value to\n     * contain each one of the provided list of values starting with given strings.\n     * @param {String} key The key to check.  This key's value must be an array.\n     * @param {Array<String>} values The string values that will match as starting string.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n\n  }, {\n    key: \"containsAllStartingWith\",\n    value: function (key\n    /*: string*/\n    , values\n    /*: Array<string>*/\n    )\n    /*: ParseQuery*/\n    {\n      var _this = this;\n\n      if (!Array.isArray(values)) {\n        values = [values];\n      }\n\n      var regexObject = values.map(function (value) {\n        return {\n          '$regex': _this._regexStartWith(value)\n        };\n      });\n      return this.containsAll(key, regexObject);\n    }\n    /**\n     * Adds a constraint for finding objects that contain the given key.\n     * @param {String} key The key that should exist.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n\n  }, {\n    key: \"exists\",\n    value: function (key\n    /*: string*/\n    )\n    /*: ParseQuery*/\n    {\n      return this._addCondition(key, '$exists', true);\n    }\n    /**\n     * Adds a constraint for finding objects that do not contain a given key.\n     * @param {String} key The key that should not exist\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n\n  }, {\n    key: \"doesNotExist\",\n    value: function (key\n    /*: string*/\n    )\n    /*: ParseQuery*/\n    {\n      return this._addCondition(key, '$exists', false);\n    }\n    /**\n     * Adds a regular expression constraint for finding string values that match\n     * the provided regular expression.\n     * This may be slow for large datasets.\n     * @param {String} key The key that the string to match is stored in.\n     * @param {RegExp} regex The regular expression pattern to match.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n\n  }, {\n    key: \"matches\",\n    value: function (key\n    /*: string*/\n    , regex\n    /*: RegExp*/\n    , modifiers\n    /*: string*/\n    )\n    /*: ParseQuery*/\n    {\n      this._addCondition(key, '$regex', regex);\n\n      if (!modifiers) {\n        modifiers = '';\n      }\n\n      if (regex.ignoreCase) {\n        modifiers += 'i';\n      }\n\n      if (regex.multiline) {\n        modifiers += 'm';\n      }\n\n      if (modifiers.length) {\n        this._addCondition(key, '$options', modifiers);\n      }\n\n      return this;\n    }\n    /**\n     * Adds a constraint that requires that a key's value matches a Parse.Query\n     * constraint.\n     * @param {String} key The key that the contains the object to match the\n     *                     query.\n     * @param {Parse.Query} query The query that should match.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n\n  }, {\n    key: \"matchesQuery\",\n    value: function (key\n    /*: string*/\n    , query\n    /*: ParseQuery*/\n    )\n    /*: ParseQuery*/\n    {\n      var queryJSON = query.toJSON();\n      queryJSON.className = query.className;\n      return this._addCondition(key, '$inQuery', queryJSON);\n    }\n    /**\n     * Adds a constraint that requires that a key's value not matches a\n     * Parse.Query constraint.\n     * @param {String} key The key that the contains the object to match the\n     *                     query.\n     * @param {Parse.Query} query The query that should not match.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n\n  }, {\n    key: \"doesNotMatchQuery\",\n    value: function (key\n    /*: string*/\n    , query\n    /*: ParseQuery*/\n    )\n    /*: ParseQuery*/\n    {\n      var queryJSON = query.toJSON();\n      queryJSON.className = query.className;\n      return this._addCondition(key, '$notInQuery', queryJSON);\n    }\n    /**\n     * Adds a constraint that requires that a key's value matches a value in\n     * an object returned by a different Parse.Query.\n     * @param {String} key The key that contains the value that is being\n     *                     matched.\n     * @param {String} queryKey The key in the objects returned by the query to\n     *                          match against.\n     * @param {Parse.Query} query The query to run.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n\n  }, {\n    key: \"matchesKeyInQuery\",\n    value: function (key\n    /*: string*/\n    , queryKey\n    /*: string*/\n    , query\n    /*: ParseQuery*/\n    )\n    /*: ParseQuery*/\n    {\n      var queryJSON = query.toJSON();\n      queryJSON.className = query.className;\n      return this._addCondition(key, '$select', {\n        key: queryKey,\n        query: queryJSON\n      });\n    }\n    /**\n     * Adds a constraint that requires that a key's value not match a value in\n     * an object returned by a different Parse.Query.\n     * @param {String} key The key that contains the value that is being\n     *                     excluded.\n     * @param {String} queryKey The key in the objects returned by the query to\n     *                          match against.\n     * @param {Parse.Query} query The query to run.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n\n  }, {\n    key: \"doesNotMatchKeyInQuery\",\n    value: function (key\n    /*: string*/\n    , queryKey\n    /*: string*/\n    , query\n    /*: ParseQuery*/\n    )\n    /*: ParseQuery*/\n    {\n      var queryJSON = query.toJSON();\n      queryJSON.className = query.className;\n      return this._addCondition(key, '$dontSelect', {\n        key: queryKey,\n        query: queryJSON\n      });\n    }\n    /**\n     * Adds a constraint for finding string values that contain a provided\n     * string.  This may be slow for large datasets.\n     * @param {String} key The key that the string to match is stored in.\n     * @param {String} substring The substring that the value must contain.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n\n  }, {\n    key: \"contains\",\n    value: function (key\n    /*: string*/\n    , value\n    /*: string*/\n    )\n    /*: ParseQuery*/\n    {\n      if (typeof value !== 'string') {\n        throw new Error('The value being searched for must be a string.');\n      }\n\n      return this._addCondition(key, '$regex', quote(value));\n    }\n    /**\n    * Adds a constraint for finding string values that contain a provided\n    * string. This may be slow for large datasets. Requires Parse-Server > 2.5.0\n    *\n    * In order to sort you must use select and ascending ($score is required)\n    *  <pre>\n    *   query.fullText('field', 'term');\n    *   query.ascending('$score');\n    *   query.select('$score');\n    *  </pre>\n    *\n    * To retrieve the weight / rank\n    *  <pre>\n    *   object->get('score');\n    *  </pre>\n    *\n    * You can define optionals by providing an object as a third parameter\n    *  <pre>\n    *   query.fullText('field', 'term', { language: 'es', diacriticSensitive: true });\n    *  </pre>\n    *\n    * @param {String} key The key that the string to match is stored in.\n    * @param {String} value The string to search\n    * @param {Object} options (Optional)\n    * @param {String} options.language The language that determines the list of stop words for the search and the rules for the stemmer and tokenizer.\n    * @param {Boolean} options.caseSensitive A boolean flag to enable or disable case sensitive search.\n    * @param {Boolean} options.diacriticSensitive A boolean flag to enable or disable diacritic sensitive search.\n    * @return {Parse.Query} Returns the query, so you can chain this call.\n    */\n\n  }, {\n    key: \"fullText\",\n    value: function (key\n    /*: string*/\n    , value\n    /*: string*/\n    , options\n    /*: ?Object*/\n    )\n    /*: ParseQuery*/\n    {\n      options = options || {};\n\n      if (!key) {\n        throw new Error('A key is required.');\n      }\n\n      if (!value) {\n        throw new Error('A search term is required');\n      }\n\n      if (typeof value !== 'string') {\n        throw new Error('The value being searched for must be a string.');\n      }\n\n      var fullOptions = {};\n      fullOptions.$term = value;\n\n      for (var option in options) {\n        switch (option) {\n          case 'language':\n            fullOptions.$language = options[option];\n            break;\n\n          case 'caseSensitive':\n            fullOptions.$caseSensitive = options[option];\n            break;\n\n          case 'diacriticSensitive':\n            fullOptions.$diacriticSensitive = options[option];\n            break;\n\n          default:\n            throw new Error(\"Unknown option: \".concat(option));\n        }\n      }\n\n      return this._addCondition(key, '$text', {\n        $search: fullOptions\n      });\n    }\n    /**\n     * Method to sort the full text search by text score\n     *\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n\n  }, {\n    key: \"sortByTextScore\",\n    value: function () {\n      this.ascending('$score');\n      this.select(['$score']);\n      return this;\n    }\n    /**\n     * Adds a constraint for finding string values that start with a provided\n     * string.  This query will use the backend index, so it will be fast even\n     * for large datasets.\n     * @param {String} key The key that the string to match is stored in.\n     * @param {String} prefix The substring that the value must start with.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n\n  }, {\n    key: \"startsWith\",\n    value: function (key\n    /*: string*/\n    , value\n    /*: string*/\n    )\n    /*: ParseQuery*/\n    {\n      if (typeof value !== 'string') {\n        throw new Error('The value being searched for must be a string.');\n      }\n\n      return this._addCondition(key, '$regex', this._regexStartWith(value));\n    }\n    /**\n     * Adds a constraint for finding string values that end with a provided\n     * string.  This will be slow for large datasets.\n     * @param {String} key The key that the string to match is stored in.\n     * @param {String} suffix The substring that the value must end with.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n\n  }, {\n    key: \"endsWith\",\n    value: function (key\n    /*: string*/\n    , value\n    /*: string*/\n    )\n    /*: ParseQuery*/\n    {\n      if (typeof value !== 'string') {\n        throw new Error('The value being searched for must be a string.');\n      }\n\n      return this._addCondition(key, '$regex', quote(value) + '$');\n    }\n    /**\n     * Adds a proximity based constraint for finding objects with key point\n     * values near the point given.\n     * @param {String} key The key that the Parse.GeoPoint is stored in.\n     * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n\n  }, {\n    key: \"near\",\n    value: function (key\n    /*: string*/\n    , point\n    /*: ParseGeoPoint*/\n    )\n    /*: ParseQuery*/\n    {\n      if (!(point instanceof _ParseGeoPoint.default)) {\n        // Try to cast it as a GeoPoint\n        point = new _ParseGeoPoint.default(point);\n      }\n\n      return this._addCondition(key, '$nearSphere', point);\n    }\n    /**\n     * Adds a proximity based constraint for finding objects with key point\n     * values near the point given and within the maximum distance given.\n     * @param {String} key The key that the Parse.GeoPoint is stored in.\n     * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\n     * @param {Number} maxDistance Maximum distance (in radians) of results to\n     *   return.\n     * @param {Boolean} sorted A Bool value that is true if results should be\n     *   sorted by distance ascending, false is no sorting is required,\n     *   defaults to true.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n\n  }, {\n    key: \"withinRadians\",\n    value: function (key\n    /*: string*/\n    , point\n    /*: ParseGeoPoint*/\n    , distance\n    /*: number*/\n    , sorted\n    /*: boolean*/\n    )\n    /*: ParseQuery*/\n    {\n      if (sorted || sorted === undefined) {\n        this.near(key, point);\n        return this._addCondition(key, '$maxDistance', distance);\n      } else {\n        return this._addCondition(key, '$geoWithin', {\n          '$centerSphere': [[point.longitude, point.latitude], distance]\n        });\n      }\n    }\n    /**\n     * Adds a proximity based constraint for finding objects with key point\n     * values near the point given and within the maximum distance given.\n     * Radius of earth used is 3958.8 miles.\n     * @param {String} key The key that the Parse.GeoPoint is stored in.\n     * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\n     * @param {Number} maxDistance Maximum distance (in miles) of results to\n     *   return.\n     * @param {Boolean} sorted A Bool value that is true if results should be\n     *   sorted by distance ascending, false is no sorting is required,\n     *   defaults to true.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n\n  }, {\n    key: \"withinMiles\",\n    value: function (key\n    /*: string*/\n    , point\n    /*: ParseGeoPoint*/\n    , distance\n    /*: number*/\n    , sorted\n    /*: boolean*/\n    )\n    /*: ParseQuery*/\n    {\n      return this.withinRadians(key, point, distance / 3958.8, sorted);\n    }\n    /**\n     * Adds a proximity based constraint for finding objects with key point\n     * values near the point given and within the maximum distance given.\n     * Radius of earth used is 6371.0 kilometers.\n     * @param {String} key The key that the Parse.GeoPoint is stored in.\n     * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\n     * @param {Number} maxDistance Maximum distance (in kilometers) of results\n     *   to return.\n     * @param {Boolean} sorted A Bool value that is true if results should be\n     *   sorted by distance ascending, false is no sorting is required,\n     *   defaults to true.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n\n  }, {\n    key: \"withinKilometers\",\n    value: function (key\n    /*: string*/\n    , point\n    /*: ParseGeoPoint*/\n    , distance\n    /*: number*/\n    , sorted\n    /*: boolean*/\n    )\n    /*: ParseQuery*/\n    {\n      return this.withinRadians(key, point, distance / 6371.0, sorted);\n    }\n    /**\n     * Adds a constraint to the query that requires a particular key's\n     * coordinates be contained within a given rectangular geographic bounding\n     * box.\n     * @param {String} key The key to be constrained.\n     * @param {Parse.GeoPoint} southwest\n     *     The lower-left inclusive corner of the box.\n     * @param {Parse.GeoPoint} northeast\n     *     The upper-right inclusive corner of the box.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n\n  }, {\n    key: \"withinGeoBox\",\n    value: function (key\n    /*: string*/\n    , southwest\n    /*: ParseGeoPoint*/\n    , northeast\n    /*: ParseGeoPoint*/\n    )\n    /*: ParseQuery*/\n    {\n      if (!(southwest instanceof _ParseGeoPoint.default)) {\n        southwest = new _ParseGeoPoint.default(southwest);\n      }\n\n      if (!(northeast instanceof _ParseGeoPoint.default)) {\n        northeast = new _ParseGeoPoint.default(northeast);\n      }\n\n      this._addCondition(key, '$within', {\n        '$box': [southwest, northeast]\n      });\n\n      return this;\n    }\n    /**\n     * Adds a constraint to the query that requires a particular key's\n     * coordinates be contained within and on the bounds of a given polygon.\n     * Supports closed and open (last point is connected to first) paths\n     *\n     * Polygon must have at least 3 points\n     *\n     * @param {String} key The key to be constrained.\n     * @param {Array} array of geopoints\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n\n  }, {\n    key: \"withinPolygon\",\n    value: function (key\n    /*: string*/\n    , points\n    /*: Array<Array<number>>*/\n    )\n    /*: ParseQuery*/\n    {\n      return this._addCondition(key, '$geoWithin', {\n        '$polygon': points\n      });\n    }\n    /**\n     * Add a constraint to the query that requires a particular key's\n     * coordinates that contains a ParseGeoPoint\n     *\n     * @param {String} key The key to be constrained.\n     * @param {Parse.GeoPoint} GeoPoint\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n\n  }, {\n    key: \"polygonContains\",\n    value: function (key\n    /*: string*/\n    , point\n    /*: ParseGeoPoint*/\n    )\n    /*: ParseQuery*/\n    {\n      return this._addCondition(key, '$geoIntersects', {\n        '$point': point\n      });\n    }\n    /** Query Orderings **/\n\n    /**\n     * Sorts the results in ascending order by the given key.\n     *\n     * @param {(String|String[]|...String)} key The key to order by, which is a\n     * string of comma separated values, or an Array of keys, or multiple keys.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n\n  }, {\n    key: \"ascending\",\n    value: function ()\n    /*: ParseQuery*/\n    {\n      this._order = [];\n\n      for (var _len = arguments.length, keys = new Array(_len), _key5 = 0; _key5 < _len; _key5++) {\n        keys[_key5] = arguments[_key5];\n      }\n\n      return this.addAscending.apply(this, keys);\n    }\n    /**\n     * Sorts the results in ascending order by the given key,\n     * but can also add secondary sort descriptors without overwriting _order.\n     *\n     * @param {(String|String[]|...String)} key The key to order by, which is a\n     * string of comma separated values, or an Array of keys, or multiple keys.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n\n  }, {\n    key: \"addAscending\",\n    value: function ()\n    /*: ParseQuery*/\n    {\n      var _this5 = this;\n\n      if (!this._order) {\n        this._order = [];\n      }\n\n      for (var _len2 = arguments.length, keys = new Array(_len2), _key6 = 0; _key6 < _len2; _key6++) {\n        keys[_key6] = arguments[_key6];\n      }\n\n      keys.forEach(function (key) {\n        if (Array.isArray(key)) {\n          key = key.join();\n        }\n\n        _this5._order = _this5._order.concat(key.replace(/\\s/g, '').split(','));\n      });\n      return this;\n    }\n    /**\n     * Sorts the results in descending order by the given key.\n     *\n     * @param {(String|String[]|...String)} key The key to order by, which is a\n     * string of comma separated values, or an Array of keys, or multiple keys.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n\n  }, {\n    key: \"descending\",\n    value: function ()\n    /*: ParseQuery*/\n    {\n      this._order = [];\n\n      for (var _len3 = arguments.length, keys = new Array(_len3), _key7 = 0; _key7 < _len3; _key7++) {\n        keys[_key7] = arguments[_key7];\n      }\n\n      return this.addDescending.apply(this, keys);\n    }\n    /**\n     * Sorts the results in descending order by the given key,\n     * but can also add secondary sort descriptors without overwriting _order.\n     *\n     * @param {(String|String[]|...String)} key The key to order by, which is a\n     * string of comma separated values, or an Array of keys, or multiple keys.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n\n  }, {\n    key: \"addDescending\",\n    value: function ()\n    /*: ParseQuery*/\n    {\n      var _this6 = this;\n\n      if (!this._order) {\n        this._order = [];\n      }\n\n      for (var _len4 = arguments.length, keys = new Array(_len4), _key8 = 0; _key8 < _len4; _key8++) {\n        keys[_key8] = arguments[_key8];\n      }\n\n      keys.forEach(function (key) {\n        if (Array.isArray(key)) {\n          key = key.join();\n        }\n\n        _this6._order = _this6._order.concat(key.replace(/\\s/g, '').split(',').map(function (k) {\n          return '-' + k;\n        }));\n      });\n      return this;\n    }\n    /** Query Options **/\n\n    /**\n     * Sets the number of results to skip before returning any results.\n     * This is useful for pagination.\n     * Default is to skip zero results.\n     * @param {Number} n the number of results to skip.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n\n  }, {\n    key: \"skip\",\n    value: function (n\n    /*: number*/\n    )\n    /*: ParseQuery*/\n    {\n      if (typeof n !== 'number' || n < 0) {\n        throw new Error('You can only skip by a positive number');\n      }\n\n      this._skip = n;\n      return this;\n    }\n    /**\n     * Sets the limit of the number of results to return. The default limit is\n     * 100, with a maximum of 1000 results being returned at a time.\n     * @param {Number} n the number of results to limit to.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n\n  }, {\n    key: \"limit\",\n    value: function (n\n    /*: number*/\n    )\n    /*: ParseQuery*/\n    {\n      if (typeof n !== 'number') {\n        throw new Error('You can only set the limit to a numeric value');\n      }\n\n      this._limit = n;\n      return this;\n    }\n    /**\n     * Includes nested Parse.Objects for the provided key.  You can use dot\n     * notation to specify which fields in the included object are also fetched.\n     *\n     * You can include all nested Parse.Objects by passing in '*'.\n     * Requires Parse Server 3.0.0+\n     * <pre>query.include('*');</pre>\n     *\n     * @param {...String|Array<String>} key The name(s) of the key(s) to include.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n\n  }, {\n    key: \"include\",\n    value: function ()\n    /*: ParseQuery*/\n    {\n      var _this7 = this;\n\n      for (var _len5 = arguments.length, keys = new Array(_len5), _key9 = 0; _key9 < _len5; _key9++) {\n        keys[_key9] = arguments[_key9];\n      }\n\n      keys.forEach(function (key) {\n        if (Array.isArray(key)) {\n          _this7._include = _this7._include.concat(key);\n        } else {\n          _this7._include.push(key);\n        }\n      });\n      return this;\n    }\n    /**\n     * Includes all nested Parse.Objects.\n     *\n     * Requires Parse Server 3.0.0+\n     *\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n\n  }, {\n    key: \"includeAll\",\n    value: function ()\n    /*: ParseQuery*/\n    {\n      return this.include('*');\n    }\n    /**\n     * Restricts the fields of the returned Parse.Objects to include only the\n     * provided keys.  If this is called multiple times, then all of the keys\n     * specified in each of the calls will be included.\n     * @param {...String|Array<String>} keys The name(s) of the key(s) to include.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n\n  }, {\n    key: \"select\",\n    value: function ()\n    /*: ParseQuery*/\n    {\n      var _this8 = this;\n\n      if (!this._select) {\n        this._select = [];\n      }\n\n      for (var _len6 = arguments.length, keys = new Array(_len6), _key10 = 0; _key10 < _len6; _key10++) {\n        keys[_key10] = arguments[_key10];\n      }\n\n      keys.forEach(function (key) {\n        if (Array.isArray(key)) {\n          _this8._select = _this8._select.concat(key);\n        } else {\n          _this8._select.push(key);\n        }\n      });\n      return this;\n    }\n    /**\n     * Subscribe this query to get liveQuery updates\n     *\n     * @param {String} sessionToken (optional) Defaults to the currentUser\n     * @return {Promise<LiveQuerySubscription>} Returns the liveQuerySubscription, it's an event emitter\n     * which can be used to get liveQuery updates.\n     */\n\n  }, {\n    key: \"subscribe\",\n    value: function () {\n      var _subscribe = (0, _asyncToGenerator2.default)(\n      /*#__PURE__*/\n      _regenerator.default.mark(function _callee2(sessionToken\n      /*:: ?: string*/\n      ) {\n        var currentUser, liveQueryClient, subscription;\n        return _regenerator.default.wrap(function (_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return _CoreManager.default.getUserController().currentUserAsync();\n\n              case 2:\n                currentUser = _context2.sent;\n\n                if (!sessionToken) {\n                  sessionToken = currentUser ? currentUser.getSessionToken() : undefined;\n                }\n\n                _context2.next = 6;\n                return _CoreManager.default.getLiveQueryController().getDefaultLiveQueryClient();\n\n              case 6:\n                liveQueryClient = _context2.sent;\n\n                if (liveQueryClient.shouldOpen()) {\n                  liveQueryClient.open();\n                }\n\n                subscription = liveQueryClient.subscribe(this, sessionToken);\n                return _context2.abrupt(\"return\", subscription);\n\n              case 10:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      return function () {\n        return _subscribe.apply(this, arguments);\n      };\n    }()\n    /**\n     * Constructs a Parse.Query that is the OR of the passed in queries.  For\n     * example:\n     * <pre>var compoundQuery = Parse.Query.or(query1, query2, query3);</pre>\n     *\n     * will create a compoundQuery that is an or of the query1, query2, and\n     * query3.\n     * @param {...Parse.Query} var_args The list of queries to OR.\n     * @static\n     * @return {Parse.Query} The query that is the OR of the passed in queries.\n     */\n\n  }, {\n    key: \"fromLocalDatastore\",\n\n    /**\n     * Changes the source of this query to all pinned objects.\n     *\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    value: function ()\n    /*: ParseQuery*/\n    {\n      return this.fromPinWithName(null);\n    }\n    /**\n     * Changes the source of this query to the default group of pinned objects.\n     *\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n\n  }, {\n    key: \"fromPin\",\n    value: function ()\n    /*: ParseQuery*/\n    {\n      return this.fromPinWithName(_LocalDatastoreUtils.DEFAULT_PIN);\n    }\n    /**\n     * Changes the source of this query to a specific group of pinned objects.\n     *\n     * @param {String} name The name of query source.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n\n  }, {\n    key: \"fromPinWithName\",\n    value: function (name\n    /*:: ?: string*/\n    )\n    /*: ParseQuery*/\n    {\n      var localDatastore = _CoreManager.default.getLocalDatastore();\n\n      if (localDatastore.checkIfEnabled()) {\n        this._queriesLocalDatastore = true;\n        this._localDatastorePinName = name;\n      }\n\n      return this;\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function (className\n    /*: string*/\n    , json\n    /*: QueryJSON*/\n    )\n    /*: ParseQuery*/\n    {\n      var query = new ParseQuery(className);\n      return query.withJSON(json);\n    }\n  }, {\n    key: \"or\",\n    value: function ()\n    /*: ParseQuery*/\n    {\n      for (var _len7 = arguments.length, queries = new Array(_len7), _key11 = 0; _key11 < _len7; _key11++) {\n        queries[_key11] = arguments[_key11];\n      }\n\n      var className = _getClassNameFromQueries(queries);\n\n      var query = new ParseQuery(className);\n\n      query._orQuery(queries);\n\n      return query;\n    }\n    /**\n     * Constructs a Parse.Query that is the AND of the passed in queries.  For\n     * example:\n     * <pre>var compoundQuery = Parse.Query.and(query1, query2, query3);</pre>\n     *\n     * will create a compoundQuery that is an and of the query1, query2, and\n     * query3.\n     * @param {...Parse.Query} var_args The list of queries to AND.\n     * @static\n     * @return {Parse.Query} The query that is the AND of the passed in queries.\n     */\n\n  }, {\n    key: \"and\",\n    value: function ()\n    /*: ParseQuery*/\n    {\n      for (var _len8 = arguments.length, queries = new Array(_len8), _key12 = 0; _key12 < _len8; _key12++) {\n        queries[_key12] = arguments[_key12];\n      }\n\n      var className = _getClassNameFromQueries(queries);\n\n      var query = new ParseQuery(className);\n\n      query._andQuery(queries);\n\n      return query;\n    }\n    /**\n     * Constructs a Parse.Query that is the NOR of the passed in queries.  For\n     * example:\n     * <pre>const compoundQuery = Parse.Query.nor(query1, query2, query3);</pre>\n     *\n     * will create a compoundQuery that is a nor of the query1, query2, and\n     * query3.\n     * @param {...Parse.Query} var_args The list of queries to NOR.\n     * @static\n     * @return {Parse.Query} The query that is the NOR of the passed in queries.\n     */\n\n  }, {\n    key: \"nor\",\n    value: function ()\n    /*: ParseQuery*/\n    {\n      for (var _len9 = arguments.length, queries = new Array(_len9), _key13 = 0; _key13 < _len9; _key13++) {\n        queries[_key13] = arguments[_key13];\n      }\n\n      var className = _getClassNameFromQueries(queries);\n\n      var query = new ParseQuery(className);\n\n      query._norQuery(queries);\n\n      return query;\n    }\n  }]);\n  return ParseQuery;\n}();\n\nvar DefaultController = {\n  find: function (className\n  /*: string*/\n  , params\n  /*: QueryJSON*/\n  , options\n  /*: RequestOptions*/\n  )\n  /*: Promise<Array<ParseObject>>*/\n  {\n    var RESTController = _CoreManager.default.getRESTController();\n\n    return RESTController.request('GET', 'classes/' + className, params, options);\n  },\n  aggregate: function (className\n  /*: string*/\n  , params\n  /*: any*/\n  , options\n  /*: RequestOptions*/\n  )\n  /*: Promise<Array<mixed>>*/\n  {\n    var RESTController = _CoreManager.default.getRESTController();\n\n    return RESTController.request('GET', 'aggregate/' + className, params, options);\n  }\n};\n\n_CoreManager.default.setQueryController(DefaultController);\n\nvar _default = ParseQuery;\nexports.default = _default;","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _ParseOp = require(\"./ParseOp\");\n\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\n\nvar _ParseQuery = _interopRequireDefault(require(\"./ParseQuery\"));\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n/**\n * Creates a new Relation for the given parent object and key. This\n * constructor should rarely be used directly, but rather created by\n * Parse.Object.relation.\n *\n * <p>\n * A class that is used to access all of the children of a many-to-many\n * relationship.  Each instance of Parse.Relation is associated with a\n * particular parent object and key.\n * </p>\n * @alias Parse.Relation\n */\n\n\nvar ParseRelation =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param {Parse.Object} parent The parent of this relation.\n   * @param {String} key The key for this relation on the parent.\n   */\n  function ParseRelation(parent\n  /*: ?ParseObject*/\n  , key\n  /*: ?string*/\n  ) {\n    (0, _classCallCheck2.default)(this, ParseRelation);\n    (0, _defineProperty2.default)(this, \"parent\", void 0);\n    (0, _defineProperty2.default)(this, \"key\", void 0);\n    (0, _defineProperty2.default)(this, \"targetClassName\", void 0);\n    this.parent = parent;\n    this.key = key;\n    this.targetClassName = null;\n  }\n  /*\n   * Makes sure that this relation has the right parent and key.\n   */\n\n\n  (0, _createClass2.default)(ParseRelation, [{\n    key: \"_ensureParentAndKey\",\n    value: function (parent\n    /*: ParseObject*/\n    , key\n    /*: string*/\n    ) {\n      this.key = this.key || key;\n\n      if (this.key !== key) {\n        throw new Error('Internal Error. Relation retrieved from two different keys.');\n      }\n\n      if (this.parent) {\n        if (this.parent.className !== parent.className) {\n          throw new Error('Internal Error. Relation retrieved from two different Objects.');\n        }\n\n        if (this.parent.id) {\n          if (this.parent.id !== parent.id) {\n            throw new Error('Internal Error. Relation retrieved from two different Objects.');\n          }\n        } else if (parent.id) {\n          this.parent = parent;\n        }\n      } else {\n        this.parent = parent;\n      }\n    }\n    /**\n     * Adds a Parse.Object or an array of Parse.Objects to the relation.\n      * @param {} objects The item or items to add.\n     */\n\n  }, {\n    key: \"add\",\n    value: function (objects\n    /*: ParseObject | Array<ParseObject | string>*/\n    )\n    /*: ParseObject*/\n    {\n      if (!Array.isArray(objects)) {\n        objects = [objects];\n      }\n\n      var change = new _ParseOp.RelationOp(objects, []);\n      var parent = this.parent;\n\n      if (!parent) {\n        throw new Error('Cannot add to a Relation without a parent');\n      }\n\n      parent.set(this.key, change);\n      this.targetClassName = change._targetClassName;\n      return parent;\n    }\n    /**\n     * Removes a Parse.Object or an array of Parse.Objects from this relation.\n      * @param {} objects The item or items to remove.\n     */\n\n  }, {\n    key: \"remove\",\n    value: function (objects\n    /*: ParseObject | Array<ParseObject | string>*/\n    ) {\n      if (!Array.isArray(objects)) {\n        objects = [objects];\n      }\n\n      var change = new _ParseOp.RelationOp([], objects);\n\n      if (!this.parent) {\n        throw new Error('Cannot remove from a Relation without a parent');\n      }\n\n      this.parent.set(this.key, change);\n      this.targetClassName = change._targetClassName;\n    }\n    /**\n     * Returns a JSON version of the object suitable for saving to disk.\n      * @return {Object}\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function ()\n    /*: { __type: 'Relation', className: ?string }*/\n    {\n      return {\n        __type: 'Relation',\n        className: this.targetClassName\n      };\n    }\n    /**\n     * Returns a Parse.Query that is limited to objects in this\n     * relation.\n      * @return {Parse.Query}\n     */\n\n  }, {\n    key: \"query\",\n    value: function query()\n    /*: ParseQuery*/\n    {\n      var query;\n      var parent = this.parent;\n\n      if (!parent) {\n        throw new Error('Cannot construct a query for a Relation without a parent');\n      }\n\n      if (!this.targetClassName) {\n        query = new _ParseQuery.default(parent.className);\n        query._extraOptions.redirectClassNameForKey = this.key;\n      } else {\n        query = new _ParseQuery.default(this.targetClassName);\n      }\n\n      query._addCondition('$relatedTo', 'object', {\n        __type: 'Pointer',\n        className: parent.className,\n        objectId: parent.id\n      });\n\n      query._addCondition('$relatedTo', 'key', this.key);\n\n      return query;\n    }\n  }]);\n  return ParseRelation;\n}();\n\nvar _default = ParseRelation;\nexports.default = _default;","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _get2 = _interopRequireDefault(require(\"@babel/runtime/helpers/get\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _ParseACL = _interopRequireDefault(require(\"./ParseACL\"));\n\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\n\nvar _ParseObject2 = _interopRequireDefault(require(\"./ParseObject\"));\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n/**\n * Represents a Role on the Parse server. Roles represent groupings of\n * Users for the purposes of granting permissions (e.g. specifying an ACL\n * for an Object). Roles are specified by their sets of child users and\n * child roles, all of which are granted any permissions that the parent\n * role has.\n *\n * <p>Roles must have a name (which cannot be changed after creation of the\n * role), and must specify an ACL.</p>\n * @alias Parse.Role\n * @extends Parse.Object\n */\n\n\nvar ParseRole =\n/*#__PURE__*/\nfunction (_ParseObject) {\n  (0, _inherits2.default)(ParseRole, _ParseObject);\n  /**\n   * @param {String} name The name of the Role to create.\n   * @param {Parse.ACL} acl The ACL for this role. Roles must have an ACL.\n   * A Parse.Role is a local representation of a role persisted to the Parse\n   * cloud.\n   */\n\n  function ParseRole(name\n  /*: string*/\n  , acl\n  /*: ParseACL*/\n  ) {\n    var _this;\n\n    (0, _classCallCheck2.default)(this, ParseRole);\n    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(ParseRole).call(this, '_Role'));\n\n    if (typeof name === 'string' && acl instanceof _ParseACL.default) {\n      _this.setName(name);\n\n      _this.setACL(acl);\n    }\n\n    return _this;\n  }\n  /**\n   * Gets the name of the role.  You can alternatively call role.get(\"name\")\n   *\n    * @return {String} the name of the role.\n   */\n\n\n  (0, _createClass2.default)(ParseRole, [{\n    key: \"getName\",\n    value: function ()\n    /*: ?string*/\n    {\n      var name = this.get('name');\n\n      if (name == null || typeof name === 'string') {\n        return name;\n      }\n\n      return '';\n    }\n    /**\n     * Sets the name for a role. This value must be set before the role has\n     * been saved to the server, and cannot be set once the role has been\n     * saved.\n     *\n     * <p>\n     *   A role's name can only contain alphanumeric characters, _, -, and\n     *   spaces.\n     * </p>\n     *\n     * <p>This is equivalent to calling role.set(\"name\", name)</p>\n     *\n      * @param {String} name The name of the role.\n     * @param {Object} options Standard options object with success and error\n     *     callbacks.\n     */\n\n  }, {\n    key: \"setName\",\n    value: function (name\n    /*: string*/\n    , options\n    /*:: ?: mixed*/\n    )\n    /*: ParseObject | boolean*/\n    {\n      return this.set('name', name, options);\n    }\n    /**\n     * Gets the Parse.Relation for the Parse.Users that are direct\n     * children of this role. These users are granted any privileges that this\n     * role has been granted (e.g. read or write access through ACLs). You can\n     * add or remove users from the role through this relation.\n     *\n     * <p>This is equivalent to calling role.relation(\"users\")</p>\n     *\n      * @return {Parse.Relation} the relation for the users belonging to this\n     *     role.\n     */\n\n  }, {\n    key: \"getUsers\",\n    value: function ()\n    /*: ParseRelation*/\n    {\n      return this.relation('users');\n    }\n    /**\n     * Gets the Parse.Relation for the Parse.Roles that are direct\n     * children of this role. These roles' users are granted any privileges that\n     * this role has been granted (e.g. read or write access through ACLs). You\n     * can add or remove child roles from this role through this relation.\n     *\n     * <p>This is equivalent to calling role.relation(\"roles\")</p>\n     *\n      * @return {Parse.Relation} the relation for the roles belonging to this\n     *     role.\n     */\n\n  }, {\n    key: \"getRoles\",\n    value: function ()\n    /*: ParseRelation*/\n    {\n      return this.relation('roles');\n    }\n  }, {\n    key: \"validate\",\n    value: function (attrs\n    /*: AttributeMap*/\n    , options\n    /*:: ?: mixed*/\n    )\n    /*: ParseError | boolean*/\n    {\n      var isInvalid = (0, _get2.default)((0, _getPrototypeOf2.default)(ParseRole.prototype), \"validate\", this).call(this, attrs, options);\n\n      if (isInvalid) {\n        return isInvalid;\n      }\n\n      if ('name' in attrs && attrs.name !== this.getName()) {\n        var newName = attrs.name;\n\n        if (this.id && this.id !== attrs.objectId) {\n          // Check to see if the objectId being set matches this.id\n          // This happens during a fetch -- the id is set before calling fetch\n          // Let the name be set in this case\n          return new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'A role\\'s name can only be set before it has been saved.');\n        }\n\n        if (typeof newName !== 'string') {\n          return new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'A role\\'s name must be a String.');\n        }\n\n        if (!/^[0-9a-zA-Z\\-_ ]+$/.test(newName)) {\n          return new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'A role\\'s name can be only contain alphanumeric characters, _, ' + '-, and spaces.');\n        }\n      }\n\n      return false;\n    }\n  }]);\n  return ParseRole;\n}(_ParseObject2.default);\n\n_ParseObject2.default.registerSubclass('_Role', ParseRole);\n\nvar _default = ParseRole;\nexports.default = _default;","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n\nvar FIELD_TYPES = ['String', 'Number', 'Boolean', 'Date', 'File', 'GeoPoint', 'Polygon', 'Array', 'Object', 'Pointer', 'Relation'];\n/**\n * A Parse.Schema object is for handling schema data from Parse.\n * <p>All the schemas methods require MasterKey.\n *\n * <pre>\n * const schema = new Parse.Schema('MyClass');\n * schema.addString('field');\n * schema.addIndex('index_name', {'field', 1});\n * schema.save();\n * </pre>\n * </p>\n * @alias Parse.Schema\n */\n\nvar ParseSchema =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param {String} className Parse Class string.\n   */\n  function ParseSchema(className\n  /*: string*/\n  ) {\n    (0, _classCallCheck2.default)(this, ParseSchema);\n    (0, _defineProperty2.default)(this, \"className\", void 0);\n    (0, _defineProperty2.default)(this, \"_fields\", void 0);\n    (0, _defineProperty2.default)(this, \"_indexes\", void 0);\n\n    if (typeof className === 'string') {\n      if (className === 'User' && _CoreManager.default.get('PERFORM_USER_REWRITE')) {\n        this.className = '_User';\n      } else {\n        this.className = className;\n      }\n    }\n\n    this._fields = {};\n    this._indexes = {};\n  }\n  /**\n   * Static method to get all schemas\n   *\n   * @param {Object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   *\n   * @return {Promise} A promise that is resolved with the result when\n   * the query completes.\n   */\n\n\n  (0, _createClass2.default)(ParseSchema, [{\n    key: \"get\",\n\n    /**\n     * Get the Schema from Parse\n     *\n     * @param {Object} options\n     * Valid options are:<ul>\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n     *     be used for this request.\n     *   <li>sessionToken: A valid session token, used for making a request on\n     *       behalf of a specific user.\n     * </ul>\n     *\n     * @return {Promise} A promise that is resolved with the result when\n     * the query completes.\n     */\n    value: function (options\n    /*: FullOptions*/\n    ) {\n      this.assertClassName();\n      options = options || {};\n\n      var controller = _CoreManager.default.getSchemaController();\n\n      return controller.get(this.className, options).then(function (response) {\n        if (!response) {\n          throw new Error('Schema not found.');\n        }\n\n        return response;\n      });\n    }\n    /**\n     * Create a new Schema on Parse\n     *\n     * @param {Object} options\n     * Valid options are:<ul>\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n     *     be used for this request.\n     *   <li>sessionToken: A valid session token, used for making a request on\n     *       behalf of a specific user.\n     * </ul>\n     *\n     * @return {Promise} A promise that is resolved with the result when\n     * the query completes.\n     */\n\n  }, {\n    key: \"save\",\n    value: function (options\n    /*: FullOptions*/\n    ) {\n      this.assertClassName();\n      options = options || {};\n\n      var controller = _CoreManager.default.getSchemaController();\n\n      var params = {\n        className: this.className,\n        fields: this._fields,\n        indexes: this._indexes\n      };\n      return controller.create(this.className, params, options).then(function (response) {\n        return response;\n      });\n    }\n    /**\n     * Update a Schema on Parse\n     *\n     * @param {Object} options\n     * Valid options are:<ul>\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n     *     be used for this request.\n     *   <li>sessionToken: A valid session token, used for making a request on\n     *       behalf of a specific user.\n     * </ul>\n     *\n     * @return {Promise} A promise that is resolved with the result when\n     * the query completes.\n     */\n\n  }, {\n    key: \"update\",\n    value: function (options\n    /*: FullOptions*/\n    ) {\n      this.assertClassName();\n      options = options || {};\n\n      var controller = _CoreManager.default.getSchemaController();\n\n      var params = {\n        className: this.className,\n        fields: this._fields,\n        indexes: this._indexes\n      };\n      this._fields = {};\n      this._indexes = {};\n      return controller.update(this.className, params, options).then(function (response) {\n        return response;\n      });\n    }\n    /**\n     * Removing a Schema from Parse\n     * Can only be used on Schema without objects\n     *\n     * @param {Object} options\n     * Valid options are:<ul>\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n     *     be used for this request.\n     *   <li>sessionToken: A valid session token, used for making a request on\n     *       behalf of a specific user.\n     * </ul>\n     *\n     * @return {Promise} A promise that is resolved with the result when\n     * the query completes.\n     */\n\n  }, {\n    key: \"delete\",\n    value: function (options\n    /*: FullOptions*/\n    ) {\n      this.assertClassName();\n      options = options || {};\n\n      var controller = _CoreManager.default.getSchemaController();\n\n      return controller.delete(this.className, options).then(function (response) {\n        return response;\n      });\n    }\n    /**\n     * Removes all objects from a Schema (class) in Parse.\n     * EXERCISE CAUTION, running this will delete all objects for this schema and cannot be reversed\n     * @return {Promise} A promise that is resolved with the result when\n     * the query completes.\n     */\n\n  }, {\n    key: \"purge\",\n    value: function () {\n      this.assertClassName();\n\n      var controller = _CoreManager.default.getSchemaController();\n\n      return controller.purge(this.className).then(function (response) {\n        return response;\n      });\n    }\n    /**\n     * Assert if ClassName has been filled\n     * @private\n     */\n\n  }, {\n    key: \"assertClassName\",\n    value: function () {\n      if (!this.className) {\n        throw new Error('You must set a Class Name before making any request.');\n      }\n    }\n    /**\n     * Adding a Field to Create / Update a Schema\n     *\n     * @param {String} name Name of the field that will be created on Parse\n     * @param {String} type TheCan be a (String|Number|Boolean|Date|Parse.File|Parse.GeoPoint|Array|Object|Pointer|Parse.Relation)\n     * @return {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"addField\",\n    value: function (name\n    /*: string*/\n    , type\n    /*: string*/\n    ) {\n      type = type || 'String';\n\n      if (!name) {\n        throw new Error('field name may not be null.');\n      }\n\n      if (FIELD_TYPES.indexOf(type) === -1) {\n        throw new Error(\"\".concat(type, \" is not a valid type.\"));\n      }\n\n      this._fields[name] = {\n        type: type\n      };\n      return this;\n    }\n    /**\n     * Adding an Index to Create / Update a Schema\n     *\n     * @param {String} name Name of the field that will be created on Parse\n     * @param {String} type Can be a (String|Number|Boolean|Date|Parse.File|Parse.GeoPoint|Array|Object|Pointer|Parse.Relation)\n     * @return {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"addIndex\",\n    value: function (name\n    /*: string*/\n    , index\n    /*: any*/\n    ) {\n      if (!name) {\n        throw new Error('index name may not be null.');\n      }\n\n      if (!index) {\n        throw new Error('index may not be null.');\n      }\n\n      this._indexes[name] = index;\n      return this;\n    }\n    /**\n     * Adding String Field\n     *\n     * @param {String} name Name of the field that will be created on Parse\n     * @return {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"addString\",\n    value: function (name\n    /*: string*/\n    ) {\n      return this.addField(name, 'String');\n    }\n    /**\n     * Adding Number Field\n     *\n     * @param {String} name Name of the field that will be created on Parse\n     * @return {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"addNumber\",\n    value: function (name\n    /*: string*/\n    ) {\n      return this.addField(name, 'Number');\n    }\n    /**\n     * Adding Boolean Field\n     *\n     * @param {String} name Name of the field that will be created on Parse\n     * @return {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"addBoolean\",\n    value: function (name\n    /*: string*/\n    ) {\n      return this.addField(name, 'Boolean');\n    }\n    /**\n     * Adding Date Field\n     *\n     * @param {String} name Name of the field that will be created on Parse\n     * @return {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"addDate\",\n    value: function (name\n    /*: string*/\n    ) {\n      return this.addField(name, 'Date');\n    }\n    /**\n     * Adding File Field\n     *\n     * @param {String} name Name of the field that will be created on Parse\n     * @return {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"addFile\",\n    value: function (name\n    /*: string*/\n    ) {\n      return this.addField(name, 'File');\n    }\n    /**\n     * Adding GeoPoint Field\n     *\n     * @param {String} name Name of the field that will be created on Parse\n     * @return {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"addGeoPoint\",\n    value: function (name\n    /*: string*/\n    ) {\n      return this.addField(name, 'GeoPoint');\n    }\n    /**\n     * Adding Polygon Field\n     *\n     * @param {String} name Name of the field that will be created on Parse\n     * @return {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"addPolygon\",\n    value: function (name\n    /*: string*/\n    ) {\n      return this.addField(name, 'Polygon');\n    }\n    /**\n     * Adding Array Field\n     *\n     * @param {String} name Name of the field that will be created on Parse\n     * @return {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"addArray\",\n    value: function (name\n    /*: string*/\n    ) {\n      return this.addField(name, 'Array');\n    }\n    /**\n     * Adding Object Field\n     *\n     * @param {String} name Name of the field that will be created on Parse\n     * @return {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"addObject\",\n    value: function (name\n    /*: string*/\n    ) {\n      return this.addField(name, 'Object');\n    }\n    /**\n     * Adding Pointer Field\n     *\n     * @param {String} name Name of the field that will be created on Parse\n     * @param {String} targetClass Name of the target Pointer Class\n     * @return {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"addPointer\",\n    value: function (name\n    /*: string*/\n    , targetClass\n    /*: string*/\n    ) {\n      if (!name) {\n        throw new Error('field name may not be null.');\n      }\n\n      if (!targetClass) {\n        throw new Error('You need to set the targetClass of the Pointer.');\n      }\n\n      this._fields[name] = {\n        type: 'Pointer',\n        targetClass: targetClass\n      };\n      return this;\n    }\n    /**\n     * Adding Relation Field\n     *\n     * @param {String} name Name of the field that will be created on Parse\n     * @param {String} targetClass Name of the target Pointer Class\n     * @return {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"addRelation\",\n    value: function (name\n    /*: string*/\n    , targetClass\n    /*: string*/\n    ) {\n      if (!name) {\n        throw new Error('field name may not be null.');\n      }\n\n      if (!targetClass) {\n        throw new Error('You need to set the targetClass of the Relation.');\n      }\n\n      this._fields[name] = {\n        type: 'Relation',\n        targetClass: targetClass\n      };\n      return this;\n    }\n    /**\n     * Deleting a Field to Update on a Schema\n     *\n     * @param {String} name Name of the field that will be created on Parse\n     * @param {String} targetClass Name of the target Pointer Class\n     * @return {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"deleteField\",\n    value: function (name\n    /*: string*/\n    ) {\n      this._fields[name] = {\n        __op: 'Delete'\n      };\n    }\n    /**\n     * Deleting an Index to Update on a Schema\n     *\n     * @param {String} name Name of the field that will be created on Parse\n     * @param {String} targetClass Name of the target Pointer Class\n     * @return {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"deleteIndex\",\n    value: function (name\n    /*: string*/\n    ) {\n      this._indexes[name] = {\n        __op: 'Delete'\n      };\n    }\n  }], [{\n    key: \"all\",\n    value: function (options\n    /*: FullOptions*/\n    ) {\n      options = options || {};\n\n      var controller = _CoreManager.default.getSchemaController();\n\n      return controller.get('', options).then(function (response) {\n        if (response.results.length === 0) {\n          throw new Error('Schema not found.');\n        }\n\n        return response.results;\n      });\n    }\n  }]);\n  return ParseSchema;\n}();\n\nvar DefaultController = {\n  send: function (className\n  /*: string*/\n  , method\n  /*: string*/\n  , params\n  /*: any*/\n  , options\n  /*: RequestOptions*/\n  )\n  /*: Promise*/\n  {\n    var RESTController = _CoreManager.default.getRESTController();\n\n    var requestOptions = {\n      useMasterKey: true\n    };\n\n    if (options.hasOwnProperty('sessionToken')) {\n      requestOptions.sessionToken = options.sessionToken;\n    }\n\n    return RESTController.request(method, \"schemas/\".concat(className), params, requestOptions);\n  },\n  get: function (className\n  /*: string*/\n  , options\n  /*: RequestOptions*/\n  )\n  /*: Promise*/\n  {\n    return this.send(className, 'GET', {}, options);\n  },\n  create: function (className\n  /*: string*/\n  , params\n  /*: any*/\n  , options\n  /*: RequestOptions*/\n  )\n  /*: Promise*/\n  {\n    return this.send(className, 'POST', params, options);\n  },\n  update: function (className\n  /*: string*/\n  , params\n  /*: any*/\n  , options\n  /*: RequestOptions*/\n  )\n  /*: Promise*/\n  {\n    return this.send(className, 'PUT', params, options);\n  },\n  delete: function (className\n  /*: string*/\n  , options\n  /*: RequestOptions*/\n  )\n  /*: Promise*/\n  {\n    return this.send(className, 'DELETE', {}, options);\n  },\n  purge: function (className\n  /*: string*/\n  )\n  /*: Promise*/\n  {\n    var RESTController = _CoreManager.default.getRESTController();\n\n    return RESTController.request('DELETE', \"purge/\".concat(className), {}, {\n      useMasterKey: true\n    });\n  }\n};\n\n_CoreManager.default.setSchemaController(DefaultController);\n\nvar _default = ParseSchema;\nexports.default = _default;","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\n\nvar _isRevocableSession = _interopRequireDefault(require(\"./isRevocableSession\"));\n\nvar _ParseObject2 = _interopRequireDefault(require(\"./ParseObject\"));\n\nvar _ParseUser = _interopRequireDefault(require(\"./ParseUser\"));\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n/**\n * <p>A Parse.Session object is a local representation of a revocable session.\n * This class is a subclass of a Parse.Object, and retains the same\n * functionality of a Parse.Object.</p>\n * @alias Parse.Session\n * @extends Parse.Object\n */\n\n\nvar ParseSession =\n/*#__PURE__*/\nfunction (_ParseObject) {\n  (0, _inherits2.default)(ParseSession, _ParseObject);\n  /**\n   *\n   * @param {Object} attributes The initial set of data to store in the user.\n   */\n\n  function ParseSession(attributes\n  /*: ?AttributeMap*/\n  ) {\n    var _this;\n\n    (0, _classCallCheck2.default)(this, ParseSession);\n    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(ParseSession).call(this, '_Session'));\n\n    if (attributes && (0, _typeof2.default)(attributes) === 'object') {\n      if (!_this.set(attributes || {})) {\n        throw new Error('Can\\'t create an invalid Session');\n      }\n    }\n\n    return _this;\n  }\n  /**\n   * Returns the session token string.\n    * @return {String}\n   */\n\n\n  (0, _createClass2.default)(ParseSession, [{\n    key: \"getSessionToken\",\n    value: function ()\n    /*: string*/\n    {\n      var token = this.get('sessionToken');\n\n      if (typeof token === 'string') {\n        return token;\n      }\n\n      return '';\n    }\n  }], [{\n    key: \"readOnlyAttributes\",\n    value: function () {\n      return ['createdWith', 'expiresAt', 'installationId', 'restricted', 'sessionToken', 'user'];\n    }\n    /**\n     * Retrieves the Session object for the currently logged in session.\n      * @static\n     * @return {Promise} A promise that is resolved with the Parse.Session\n     *   object after it has been fetched. If there is no current user, the\n     *   promise will be rejected.\n     */\n\n  }, {\n    key: \"current\",\n    value: function (options\n    /*: FullOptions*/\n    ) {\n      options = options || {};\n\n      var controller = _CoreManager.default.getSessionController();\n\n      var sessionOptions = {};\n\n      if (options.hasOwnProperty('useMasterKey')) {\n        sessionOptions.useMasterKey = options.useMasterKey;\n      }\n\n      return _ParseUser.default.currentAsync().then(function (user) {\n        if (!user) {\n          return Promise.reject('There is no current user.');\n        }\n\n        sessionOptions.sessionToken = user.getSessionToken();\n        return controller.getSession(sessionOptions);\n      });\n    }\n    /**\n     * Determines whether the current session token is revocable.\n     * This method is useful for migrating Express.js or Node.js web apps to\n     * use revocable sessions. If you are migrating an app that uses the Parse\n     * SDK in the browser only, please use Parse.User.enableRevocableSession()\n     * instead, so that sessions can be automatically upgraded.\n      * @static\n     * @return {Boolean}\n     */\n\n  }, {\n    key: \"isCurrentSessionRevocable\",\n    value: function ()\n    /*: boolean*/\n    {\n      var currentUser = _ParseUser.default.current();\n\n      if (currentUser) {\n        return (0, _isRevocableSession.default)(currentUser.getSessionToken() || '');\n      }\n\n      return false;\n    }\n  }]);\n  return ParseSession;\n}(_ParseObject2.default);\n\n_ParseObject2.default.registerSubclass('_Session', ParseSession);\n\nvar DefaultController = {\n  getSession: function (options\n  /*: RequestOptions*/\n  )\n  /*: Promise<ParseSession>*/\n  {\n    var RESTController = _CoreManager.default.getRESTController();\n\n    var session = new ParseSession();\n    return RESTController.request('GET', 'sessions/me', {}, options).then(function (sessionData) {\n      session._finishFetch(sessionData);\n\n      session._setExisted(true);\n\n      return session;\n    });\n  }\n};\n\n_CoreManager.default.setSessionController(DefaultController);\n\nvar _default = ParseSession;\nexports.default = _default;","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _get2 = _interopRequireDefault(require(\"@babel/runtime/helpers/get\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _AnonymousUtils = _interopRequireDefault(require(\"./AnonymousUtils\"));\n\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\n\nvar _isRevocableSession = _interopRequireDefault(require(\"./isRevocableSession\"));\n\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\n\nvar _ParseObject2 = _interopRequireDefault(require(\"./ParseObject\"));\n\nvar _ParseSession = _interopRequireDefault(require(\"./ParseSession\"));\n\nvar _Storage = _interopRequireDefault(require(\"./Storage\"));\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n\nvar CURRENT_USER_KEY = 'currentUser';\nvar canUseCurrentUser = !_CoreManager.default.get('IS_NODE');\nvar currentUserCacheMatchesDisk = false;\nvar currentUserCache = null;\nvar authProviders = {};\n/**\n * <p>A Parse.User object is a local representation of a user persisted to the\n * Parse cloud. This class is a subclass of a Parse.Object, and retains the\n * same functionality of a Parse.Object, but also extends it with various\n * user specific methods, like authentication, signing up, and validation of\n * uniqueness.</p>\n * @alias Parse.User\n * @extends Parse.Object\n */\n\nvar ParseUser =\n/*#__PURE__*/\nfunction (_ParseObject) {\n  (0, _inherits2.default)(ParseUser, _ParseObject);\n  /**\n   * @param {Object} attributes The initial set of data to store in the user.\n   */\n\n  function ParseUser(attributes\n  /*: ?AttributeMap*/\n  ) {\n    var _this;\n\n    (0, _classCallCheck2.default)(this, ParseUser);\n    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(ParseUser).call(this, '_User'));\n\n    if (attributes && (0, _typeof2.default)(attributes) === 'object') {\n      if (!_this.set(attributes || {})) {\n        throw new Error('Can\\'t create an invalid Parse User');\n      }\n    }\n\n    return _this;\n  }\n  /**\n   * Request a revocable session token to replace the older style of token.\n    * @param {Object} options\n   * @return {Promise} A promise that is resolved when the replacement\n   *   token has been fetched.\n   */\n\n\n  (0, _createClass2.default)(ParseUser, [{\n    key: \"_upgradeToRevocableSession\",\n    value: function (options\n    /*: RequestOptions*/\n    )\n    /*: Promise<void>*/\n    {\n      options = options || {};\n      var upgradeOptions = {};\n\n      if (options.hasOwnProperty('useMasterKey')) {\n        upgradeOptions.useMasterKey = options.useMasterKey;\n      }\n\n      var controller = _CoreManager.default.getUserController();\n\n      return controller.upgradeToRevocableSession(this, upgradeOptions);\n    }\n    /**\n     * Unlike in the Android/iOS SDKs, logInWith is unnecessary, since you can\n     * call linkWith on the user (even if it doesn't exist yet on the server).\n     */\n\n  }, {\n    key: \"_linkWith\",\n    value: function (provider\n    /*: any*/\n    , options\n    /*: { authData?: AuthData }*/\n    , saveOpts\n    /*:: ?: FullOptions*/\n    )\n    /*: Promise<ParseUser>*/\n    {\n      var _this2 = this;\n\n      var authType;\n\n      if (typeof provider === 'string') {\n        authType = provider;\n        provider = authProviders[provider];\n      } else {\n        authType = provider.getAuthType();\n      }\n\n      if (options && options.hasOwnProperty('authData')) {\n        var authData = this.get('authData') || {};\n\n        if ((0, _typeof2.default)(authData) !== 'object') {\n          throw new Error('Invalid type: authData field should be an object');\n        }\n\n        authData[authType] = options.authData;\n\n        var controller = _CoreManager.default.getUserController();\n\n        return controller.linkWith(this, authData, saveOpts);\n      } else {\n        return new Promise(function (resolve, reject) {\n          provider.authenticate({\n            success: function (provider, result) {\n              var opts = {};\n              opts.authData = result;\n\n              _this2._linkWith(provider, opts, saveOpts).then(function () {\n                resolve(_this2);\n              }, function (error) {\n                reject(error);\n              });\n            },\n            error: function (provider, _error) {\n              reject(_error);\n            }\n          });\n        });\n      }\n    }\n    /**\n     * Synchronizes auth data for a provider (e.g. puts the access token in the\n     * right place to be used by the Facebook SDK).\n     */\n\n  }, {\n    key: \"_synchronizeAuthData\",\n    value: function (provider\n    /*: string*/\n    ) {\n      if (!this.isCurrent() || !provider) {\n        return;\n      }\n\n      var authType;\n\n      if (typeof provider === 'string') {\n        authType = provider;\n        provider = authProviders[authType];\n      } else {\n        authType = provider.getAuthType();\n      }\n\n      var authData = this.get('authData');\n\n      if (!provider || !authData || (0, _typeof2.default)(authData) !== 'object') {\n        return;\n      }\n\n      var success = provider.restoreAuthentication(authData[authType]);\n\n      if (!success) {\n        this._unlinkFrom(provider);\n      }\n    }\n    /**\n     * Synchronizes authData for all providers.\n      */\n\n  }, {\n    key: \"_synchronizeAllAuthData\",\n    value: function () {\n      var authData = this.get('authData');\n\n      if ((0, _typeof2.default)(authData) !== 'object') {\n        return;\n      }\n\n      for (var _key in authData) {\n        this._synchronizeAuthData(_key);\n      }\n    }\n    /**\n     * Removes null values from authData (which exist temporarily for\n     * unlinking)\n      */\n\n  }, {\n    key: \"_cleanupAuthData\",\n    value: function () {\n      if (!this.isCurrent()) {\n        return;\n      }\n\n      var authData = this.get('authData');\n\n      if ((0, _typeof2.default)(authData) !== 'object') {\n        return;\n      }\n\n      for (var _key2 in authData) {\n        if (!authData[_key2]) {\n          delete authData[_key2];\n        }\n      }\n    }\n    /**\n     * Unlinks a user from a service.\n     */\n\n  }, {\n    key: \"_unlinkFrom\",\n    value: function (provider\n    /*: any*/\n    , options\n    /*:: ?: FullOptions*/\n    ) {\n      var _this3 = this;\n\n      if (typeof provider === 'string') {\n        provider = authProviders[provider];\n      }\n\n      return this._linkWith(provider, {\n        authData: null\n      }, options).then(function () {\n        _this3._synchronizeAuthData(provider);\n\n        return Promise.resolve(_this3);\n      });\n    }\n    /**\n     * Checks whether a user is linked to a service.\n      */\n\n  }, {\n    key: \"_isLinked\",\n    value: function (provider\n    /*: any*/\n    )\n    /*: boolean*/\n    {\n      var authType;\n\n      if (typeof provider === 'string') {\n        authType = provider;\n      } else {\n        authType = provider.getAuthType();\n      }\n\n      var authData = this.get('authData') || {};\n\n      if ((0, _typeof2.default)(authData) !== 'object') {\n        return false;\n      }\n\n      return !!authData[authType];\n    }\n    /**\n     * Deauthenticates all providers.\n      */\n\n  }, {\n    key: \"_logOutWithAll\",\n    value: function () {\n      var authData = this.get('authData');\n\n      if ((0, _typeof2.default)(authData) !== 'object') {\n        return;\n      }\n\n      for (var _key3 in authData) {\n        this._logOutWith(_key3);\n      }\n    }\n    /**\n     * Deauthenticates a single provider (e.g. removing access tokens from the\n     * Facebook SDK).\n      */\n\n  }, {\n    key: \"_logOutWith\",\n    value: function (provider\n    /*: any*/\n    ) {\n      if (!this.isCurrent()) {\n        return;\n      }\n\n      if (typeof provider === 'string') {\n        provider = authProviders[provider];\n      }\n\n      if (provider && provider.deauthenticate) {\n        provider.deauthenticate();\n      }\n    }\n    /**\n     * Class instance method used to maintain specific keys when a fetch occurs.\n     * Used to ensure that the session token is not lost.\n     */\n\n  }, {\n    key: \"_preserveFieldsOnFetch\",\n    value: function ()\n    /*: AttributeMap*/\n    {\n      return {\n        sessionToken: this.get('sessionToken')\n      };\n    }\n    /**\n     * Returns true if <code>current</code> would return this user.\n      * @return {Boolean}\n     */\n\n  }, {\n    key: \"isCurrent\",\n    value: function ()\n    /*: boolean*/\n    {\n      var current = ParseUser.current();\n      return !!current && current.id === this.id;\n    }\n    /**\n     * Returns get(\"username\").\n      * @return {String}\n     */\n\n  }, {\n    key: \"getUsername\",\n    value: function ()\n    /*: ?string*/\n    {\n      var username = this.get('username');\n\n      if (username == null || typeof username === 'string') {\n        return username;\n      }\n\n      return '';\n    }\n    /**\n     * Calls set(\"username\", username, options) and returns the result.\n      * @param {String} username\n     * @param {Object} options\n     * @return {Boolean}\n     */\n\n  }, {\n    key: \"setUsername\",\n    value: function (username\n    /*: string*/\n    ) {\n      // Strip anonymity, even we do not support anonymous user in js SDK, we may\n      // encounter anonymous user created by android/iOS in cloud code.\n      var authData = this.get('authData');\n\n      if (authData && (0, _typeof2.default)(authData) === 'object' && authData.hasOwnProperty('anonymous')) {\n        // We need to set anonymous to null instead of deleting it in order to remove it from Parse.\n        authData.anonymous = null;\n      }\n\n      this.set('username', username);\n    }\n    /**\n     * Calls set(\"password\", password, options) and returns the result.\n      * @param {String} password\n     * @param {Object} options\n     * @return {Boolean}\n     */\n\n  }, {\n    key: \"setPassword\",\n    value: function (password\n    /*: string*/\n    ) {\n      this.set('password', password);\n    }\n    /**\n     * Returns get(\"email\").\n      * @return {String}\n     */\n\n  }, {\n    key: \"getEmail\",\n    value: function ()\n    /*: ?string*/\n    {\n      var email = this.get('email');\n\n      if (email == null || typeof email === 'string') {\n        return email;\n      }\n\n      return '';\n    }\n    /**\n     * Calls set(\"email\", email) and returns the result.\n      * @param {String} email\n     * @return {Boolean}\n     */\n\n  }, {\n    key: \"setEmail\",\n    value: function (email\n    /*: string*/\n    ) {\n      return this.set('email', email);\n    }\n    /**\n     * Returns the session token for this user, if the user has been logged in,\n     * or if it is the result of a query with the master key. Otherwise, returns\n     * undefined.\n      * @return {String} the session token, or undefined\n     */\n\n  }, {\n    key: \"getSessionToken\",\n    value: function ()\n    /*: ?string*/\n    {\n      var token = this.get('sessionToken');\n\n      if (token == null || typeof token === 'string') {\n        return token;\n      }\n\n      return '';\n    }\n    /**\n     * Checks whether this user is the current user and has been authenticated.\n      * @return (Boolean) whether this user is the current user and is logged in.\n     */\n\n  }, {\n    key: \"authenticated\",\n    value: function ()\n    /*: boolean*/\n    {\n      var current = ParseUser.current();\n      return !!this.get('sessionToken') && !!current && current.id === this.id;\n    }\n    /**\n     * Signs up a new user. You should call this instead of save for\n     * new Parse.Users. This will create a new Parse.User on the server, and\n     * also persist the session on disk so that you can access the user using\n     * <code>current</code>.\n     *\n     * <p>A username and password must be set before calling signUp.</p>\n     *\n     * <p>Calls options.success or options.error on completion.</p>\n     *\n      * @param {Object} attrs Extra fields to set on the new user, or null.\n     * @param {Object} options\n     * @return {Promise} A promise that is fulfilled when the signup\n     *     finishes.\n     */\n\n  }, {\n    key: \"signUp\",\n    value: function (attrs\n    /*: AttributeMap*/\n    , options\n    /*:: ?: FullOptions*/\n    )\n    /*: Promise<ParseUser>*/\n    {\n      options = options || {};\n      var signupOptions = {};\n\n      if (options.hasOwnProperty('useMasterKey')) {\n        signupOptions.useMasterKey = options.useMasterKey;\n      }\n\n      if (options.hasOwnProperty('installationId')) {\n        signupOptions.installationId = options.installationId;\n      }\n\n      var controller = _CoreManager.default.getUserController();\n\n      return controller.signUp(this, attrs, signupOptions);\n    }\n    /**\n     * Logs in a Parse.User. On success, this saves the session to disk,\n     * so you can retrieve the currently logged in user using\n     * <code>current</code>.\n     *\n     * <p>A username and password must be set before calling logIn.</p>\n     *\n     * <p>Calls options.success or options.error on completion.</p>\n     *\n      * @param {Object} options\n     * @return {Promise} A promise that is fulfilled with the user when\n     *     the login is complete.\n     */\n\n  }, {\n    key: \"logIn\",\n    value: function (options\n    /*:: ?: FullOptions*/\n    )\n    /*: Promise<ParseUser>*/\n    {\n      options = options || {};\n      var loginOptions = {};\n\n      if (options.hasOwnProperty('useMasterKey')) {\n        loginOptions.useMasterKey = options.useMasterKey;\n      }\n\n      if (options.hasOwnProperty('installationId')) {\n        loginOptions.installationId = options.installationId;\n      }\n\n      var controller = _CoreManager.default.getUserController();\n\n      return controller.logIn(this, loginOptions);\n    }\n    /**\n     * Wrap the default save behavior with functionality to save to local\n     * storage if this is current user.\n     */\n\n  }, {\n    key: \"save\",\n    value: function ()\n    /*: Promise<ParseUser>*/\n    {\n      var _this4 = this;\n\n      for (var _len = arguments.length, args = new Array(_len), _key4 = 0; _key4 < _len; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n\n      return (0, _get2.default)((0, _getPrototypeOf2.default)(ParseUser.prototype), \"save\", this).apply(this, args).then(function () {\n        if (_this4.isCurrent()) {\n          return _CoreManager.default.getUserController().updateUserOnDisk(_this4);\n        }\n\n        return _this4;\n      });\n    }\n    /**\n     * Wrap the default destroy behavior with functionality that logs out\n     * the current user when it is destroyed\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function ()\n    /*: Promise<ParseUser>*/\n    {\n      var _this5 = this;\n\n      for (var _len2 = arguments.length, args = new Array(_len2), _key5 = 0; _key5 < _len2; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n\n      return (0, _get2.default)((0, _getPrototypeOf2.default)(ParseUser.prototype), \"destroy\", this).apply(this, args).then(function () {\n        if (_this5.isCurrent()) {\n          return _CoreManager.default.getUserController().removeUserFromDisk();\n        }\n\n        return _this5;\n      });\n    }\n    /**\n     * Wrap the default fetch behavior with functionality to save to local\n     * storage if this is current user.\n     */\n\n  }, {\n    key: \"fetch\",\n    value: function ()\n    /*: Promise<ParseUser>*/\n    {\n      var _this6 = this;\n\n      for (var _len3 = arguments.length, args = new Array(_len3), _key6 = 0; _key6 < _len3; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n\n      return (0, _get2.default)((0, _getPrototypeOf2.default)(ParseUser.prototype), \"fetch\", this).apply(this, args).then(function () {\n        if (_this6.isCurrent()) {\n          return _CoreManager.default.getUserController().updateUserOnDisk(_this6);\n        }\n\n        return _this6;\n      });\n    }\n    /**\n     * Wrap the default fetchWithInclude behavior with functionality to save to local\n     * storage if this is current user.\n     */\n\n  }, {\n    key: \"fetchWithInclude\",\n    value: function ()\n    /*: Promise<ParseUser>*/\n    {\n      var _this7 = this;\n\n      for (var _len4 = arguments.length, args = new Array(_len4), _key7 = 0; _key7 < _len4; _key7++) {\n        args[_key7] = arguments[_key7];\n      }\n\n      return (0, _get2.default)((0, _getPrototypeOf2.default)(ParseUser.prototype), \"fetchWithInclude\", this).apply(this, args).then(function () {\n        if (_this7.isCurrent()) {\n          return _CoreManager.default.getUserController().updateUserOnDisk(_this7);\n        }\n\n        return _this7;\n      });\n    }\n  }], [{\n    key: \"readOnlyAttributes\",\n    value: function () {\n      return ['sessionToken'];\n    }\n    /**\n     * Adds functionality to the existing Parse.User class\n      * @param {Object} protoProps A set of properties to add to the prototype\n     * @param {Object} classProps A set of static properties to add to the class\n     * @static\n     * @return {Class} The newly extended Parse.User class\n     */\n\n  }, {\n    key: \"extend\",\n    value: function (protoProps\n    /*: {[prop: string]: any}*/\n    , classProps\n    /*: {[prop: string]: any}*/\n    ) {\n      if (protoProps) {\n        for (var _prop in protoProps) {\n          if (_prop !== 'className') {\n            Object.defineProperty(ParseUser.prototype, _prop, {\n              value: protoProps[_prop],\n              enumerable: false,\n              writable: true,\n              configurable: true\n            });\n          }\n        }\n      }\n\n      if (classProps) {\n        for (var _prop2 in classProps) {\n          if (_prop2 !== 'className') {\n            Object.defineProperty(ParseUser, _prop2, {\n              value: classProps[_prop2],\n              enumerable: false,\n              writable: true,\n              configurable: true\n            });\n          }\n        }\n      }\n\n      return ParseUser;\n    }\n    /**\n     * Retrieves the currently logged in ParseUser with a valid session,\n     * either from memory or localStorage, if necessary.\n      * @static\n     * @return {Parse.Object} The currently logged in Parse.User.\n     */\n\n  }, {\n    key: \"current\",\n    value: function ()\n    /*: ?ParseUser*/\n    {\n      if (!canUseCurrentUser) {\n        return null;\n      }\n\n      var controller = _CoreManager.default.getUserController();\n\n      return controller.currentUser();\n    }\n    /**\n     * Retrieves the currently logged in ParseUser from asynchronous Storage.\n      * @static\n     * @return {Promise} A Promise that is resolved with the currently\n     *   logged in Parse User\n     */\n\n  }, {\n    key: \"currentAsync\",\n    value: function ()\n    /*: Promise<?ParseUser>*/\n    {\n      if (!canUseCurrentUser) {\n        return Promise.resolve(null);\n      }\n\n      var controller = _CoreManager.default.getUserController();\n\n      return controller.currentUserAsync();\n    }\n    /**\n     * Signs up a new user with a username (or email) and password.\n     * This will create a new Parse.User on the server, and also persist the\n     * session in localStorage so that you can access the user using\n     * {@link #current}.\n     *\n     * <p>Calls options.success or options.error on completion.</p>\n     *\n      * @param {String} username The username (or email) to sign up with.\n     * @param {String} password The password to sign up with.\n     * @param {Object} attrs Extra fields to set on the new user.\n     * @param {Object} options\n     * @static\n     * @return {Promise} A promise that is fulfilled with the user when\n     *     the signup completes.\n     */\n\n  }, {\n    key: \"signUp\",\n    value: function (username\n    /*: string*/\n    , password\n    /*: string*/\n    , attrs\n    /*: AttributeMap*/\n    , options\n    /*:: ?: FullOptions*/\n    ) {\n      attrs = attrs || {};\n      attrs.username = username;\n      attrs.password = password;\n      var user = new this(attrs);\n      return user.signUp({}, options);\n    }\n    /**\n     * Logs in a user with a username (or email) and password. On success, this\n     * saves the session to disk, so you can retrieve the currently logged in\n     * user using <code>current</code>.\n     *\n     * <p>Calls options.success or options.error on completion.</p>\n     *\n      * @param {String} username The username (or email) to log in with.\n     * @param {String} password The password to log in with.\n     * @param {Object} options\n     * @static\n     * @return {Promise} A promise that is fulfilled with the user when\n     *     the login completes.\n     */\n\n  }, {\n    key: \"logIn\",\n    value: function (username\n    /*: string*/\n    , password\n    /*: string*/\n    , options\n    /*:: ?: FullOptions*/\n    ) {\n      if (typeof username !== 'string') {\n        return Promise.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Username must be a string.'));\n      } else if (typeof password !== 'string') {\n        return Promise.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Password must be a string.'));\n      }\n\n      var user = new this();\n\n      user._finishFetch({\n        username: username,\n        password: password\n      });\n\n      return user.logIn(options);\n    }\n    /**\n     * Logs in a user with a session token. On success, this saves the session\n     * to disk, so you can retrieve the currently logged in user using\n     * <code>current</code>.\n     *\n     * <p>Calls options.success or options.error on completion.</p>\n     *\n      * @param {String} sessionToken The sessionToken to log in with.\n     * @param {Object} options\n     * @static\n     * @return {Promise} A promise that is fulfilled with the user when\n     *     the login completes.\n     */\n\n  }, {\n    key: \"become\",\n    value: function (sessionToken\n    /*: string*/\n    , options\n    /*:: ?: RequestOptions*/\n    ) {\n      if (!canUseCurrentUser) {\n        throw new Error('It is not memory-safe to become a user in a server environment');\n      }\n\n      options = options || {};\n      var becomeOptions\n      /*: RequestOptions*/\n      = {\n        sessionToken: sessionToken\n      };\n\n      if (options.hasOwnProperty('useMasterKey')) {\n        becomeOptions.useMasterKey = options.useMasterKey;\n      }\n\n      var controller = _CoreManager.default.getUserController();\n\n      return controller.become(becomeOptions);\n    }\n    /**\n     * Logs in a user with a session token. On success, this saves the session\n     * to disk, so you can retrieve the currently logged in user using\n     * <code>current</code>. If there is no session token the user will not logged in.\n     *\n     * @param {Object} userJSON The JSON map of the User's data\n     * @static\n     * @return {Promise} A promise that is fulfilled with the user when\n     *     the login completes.\n     */\n\n  }, {\n    key: \"hydrate\",\n    value: function (userJSON\n    /*: AttributeMap*/\n    ) {\n      var controller = _CoreManager.default.getUserController();\n\n      return controller.hydrate(userJSON);\n    }\n  }, {\n    key: \"logInWith\",\n    value: function (provider\n    /*: any*/\n    , options\n    /*:: ?: RequestOptions*/\n    ) {\n      return ParseUser._logInWith(provider, options);\n    }\n    /**\n     * Logs out the currently logged in user session. This will remove the\n     * session from disk, log out of linked services, and future calls to\n     * <code>current</code> will return <code>null</code>.\n      * @static\n     * @return {Promise} A promise that is resolved when the session is\n     *   destroyed on the server.\n     */\n\n  }, {\n    key: \"logOut\",\n    value: function () {\n      if (!canUseCurrentUser) {\n        throw new Error('There is no current user on a node.js server environment.');\n      }\n\n      var controller = _CoreManager.default.getUserController();\n\n      return controller.logOut();\n    }\n    /**\n     * Requests a password reset email to be sent to the specified email address\n     * associated with the user account. This email allows the user to securely\n     * reset their password on the Parse site.\n     *\n     * <p>Calls options.success or options.error on completion.</p>\n     *\n      * @param {String} email The email address associated with the user that\n     *     forgot their password.\n     * @param {Object} options\n     * @static\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"requestPasswordReset\",\n    value: function (email\n    /*: string*/\n    , options\n    /*:: ?: RequestOptions*/\n    ) {\n      options = options || {};\n      var requestOptions = {};\n\n      if (options.hasOwnProperty('useMasterKey')) {\n        requestOptions.useMasterKey = options.useMasterKey;\n      }\n\n      var controller = _CoreManager.default.getUserController();\n\n      return controller.requestPasswordReset(email, requestOptions);\n    }\n    /**\n     * Allow someone to define a custom User class without className\n     * being rewritten to _User. The default behavior is to rewrite\n     * User to _User for legacy reasons. This allows developers to\n     * override that behavior.\n     *\n      * @param {Boolean} isAllowed Whether or not to allow custom User class\n     * @static\n     */\n\n  }, {\n    key: \"allowCustomUserClass\",\n    value: function (isAllowed\n    /*: boolean*/\n    ) {\n      _CoreManager.default.set('PERFORM_USER_REWRITE', !isAllowed);\n    }\n    /**\n     * Allows a legacy application to start using revocable sessions. If the\n     * current session token is not revocable, a request will be made for a new,\n     * revocable session.\n     * It is not necessary to call this method from cloud code unless you are\n     * handling user signup or login from the server side. In a cloud code call,\n     * this function will not attempt to upgrade the current token.\n      * @param {Object} options\n     * @static\n     * @return {Promise} A promise that is resolved when the process has\n     *   completed. If a replacement session token is requested, the promise\n     *   will be resolved after a new token has been fetched.\n     */\n\n  }, {\n    key: \"enableRevocableSession\",\n    value: function (options\n    /*:: ?: RequestOptions*/\n    ) {\n      options = options || {};\n\n      _CoreManager.default.set('FORCE_REVOCABLE_SESSION', true);\n\n      if (canUseCurrentUser) {\n        var current = ParseUser.current();\n\n        if (current) {\n          return current._upgradeToRevocableSession(options);\n        }\n      }\n\n      return Promise.resolve();\n    }\n    /**\n     * Enables the use of become or the current user in a server\n     * environment. These features are disabled by default, since they depend on\n     * global objects that are not memory-safe for most servers.\n      * @static\n     */\n\n  }, {\n    key: \"enableUnsafeCurrentUser\",\n    value: function () {\n      canUseCurrentUser = true;\n    }\n    /**\n     * Disables the use of become or the current user in any environment.\n     * These features are disabled on servers by default, since they depend on\n     * global objects that are not memory-safe for most servers.\n      * @static\n     */\n\n  }, {\n    key: \"disableUnsafeCurrentUser\",\n    value: function () {\n      canUseCurrentUser = false;\n    }\n  }, {\n    key: \"_registerAuthenticationProvider\",\n    value: function (provider\n    /*: any*/\n    ) {\n      authProviders[provider.getAuthType()] = provider; // Synchronize the current user with the auth provider.\n\n      ParseUser.currentAsync().then(function (current) {\n        if (current) {\n          current._synchronizeAuthData(provider.getAuthType());\n        }\n      });\n    }\n  }, {\n    key: \"_logInWith\",\n    value: function (provider\n    /*: any*/\n    , options\n    /*:: ?: RequestOptions*/\n    ) {\n      var user = new ParseUser();\n      return user._linkWith(provider, options);\n    }\n  }, {\n    key: \"_clearCache\",\n    value: function () {\n      currentUserCache = null;\n      currentUserCacheMatchesDisk = false;\n    }\n  }, {\n    key: \"_setCurrentUserCache\",\n    value: function (user\n    /*: ParseUser*/\n    ) {\n      currentUserCache = user;\n    }\n  }]);\n  return ParseUser;\n}(_ParseObject2.default);\n\n_ParseObject2.default.registerSubclass('_User', ParseUser);\n\nvar DefaultController = {\n  updateUserOnDisk: function (user) {\n    var path = _Storage.default.generatePath(CURRENT_USER_KEY);\n\n    var json = user.toJSON();\n    json.className = '_User';\n    return _Storage.default.setItemAsync(path, JSON.stringify(json)).then(function () {\n      return user;\n    });\n  },\n  removeUserFromDisk: function () {\n    var path = _Storage.default.generatePath(CURRENT_USER_KEY);\n\n    currentUserCacheMatchesDisk = true;\n    currentUserCache = null;\n    return _Storage.default.removeItemAsync(path);\n  },\n  setCurrentUser: function (user) {\n    var currentUser = this.currentUser();\n    var promise = Promise.resolve();\n\n    if (currentUser && !user.equals(currentUser) && _AnonymousUtils.default.isLinked(currentUser)) {\n      promise = currentUser.destroy({\n        sessionToken: currentUser.getSessionToken()\n      });\n    }\n\n    currentUserCache = user;\n\n    user._cleanupAuthData();\n\n    user._synchronizeAllAuthData();\n\n    return promise.then(function () {\n      return DefaultController.updateUserOnDisk(user);\n    });\n  },\n  currentUser: function ()\n  /*: ?ParseUser*/\n  {\n    if (currentUserCache) {\n      return currentUserCache;\n    }\n\n    if (currentUserCacheMatchesDisk) {\n      return null;\n    }\n\n    if (_Storage.default.async()) {\n      throw new Error('Cannot call currentUser() when using a platform with an async ' + 'storage system. Call currentUserAsync() instead.');\n    }\n\n    var path = _Storage.default.generatePath(CURRENT_USER_KEY);\n\n    var userData = _Storage.default.getItem(path);\n\n    currentUserCacheMatchesDisk = true;\n\n    if (!userData) {\n      currentUserCache = null;\n      return null;\n    }\n\n    userData = JSON.parse(userData);\n\n    if (!userData.className) {\n      userData.className = '_User';\n    }\n\n    if (userData._id) {\n      if (userData.objectId !== userData._id) {\n        userData.objectId = userData._id;\n      }\n\n      delete userData._id;\n    }\n\n    if (userData._sessionToken) {\n      userData.sessionToken = userData._sessionToken;\n      delete userData._sessionToken;\n    }\n\n    var current = _ParseObject2.default.fromJSON(userData);\n\n    currentUserCache = current;\n\n    current._synchronizeAllAuthData();\n\n    return current;\n  },\n  currentUserAsync: function ()\n  /*: Promise<?ParseUser>*/\n  {\n    if (currentUserCache) {\n      return Promise.resolve(currentUserCache);\n    }\n\n    if (currentUserCacheMatchesDisk) {\n      return Promise.resolve(null);\n    }\n\n    var path = _Storage.default.generatePath(CURRENT_USER_KEY);\n\n    return _Storage.default.getItemAsync(path).then(function (userData) {\n      currentUserCacheMatchesDisk = true;\n\n      if (!userData) {\n        currentUserCache = null;\n        return Promise.resolve(null);\n      }\n\n      userData = JSON.parse(userData);\n\n      if (!userData.className) {\n        userData.className = '_User';\n      }\n\n      if (userData._id) {\n        if (userData.objectId !== userData._id) {\n          userData.objectId = userData._id;\n        }\n\n        delete userData._id;\n      }\n\n      if (userData._sessionToken) {\n        userData.sessionToken = userData._sessionToken;\n        delete userData._sessionToken;\n      }\n\n      var current = _ParseObject2.default.fromJSON(userData);\n\n      currentUserCache = current;\n\n      current._synchronizeAllAuthData();\n\n      return Promise.resolve(current);\n    });\n  },\n  signUp: function (user\n  /*: ParseUser*/\n  , attrs\n  /*: AttributeMap*/\n  , options\n  /*: RequestOptions*/\n  )\n  /*: Promise<ParseUser>*/\n  {\n    var username = attrs && attrs.username || user.get('username');\n    var password = attrs && attrs.password || user.get('password');\n\n    if (!username || !username.length) {\n      return Promise.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Cannot sign up user with an empty name.'));\n    }\n\n    if (!password || !password.length) {\n      return Promise.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Cannot sign up user with an empty password.'));\n    }\n\n    return user.save(attrs, options).then(function () {\n      // Clear the password field\n      user._finishFetch({\n        password: undefined\n      });\n\n      if (canUseCurrentUser) {\n        return DefaultController.setCurrentUser(user);\n      }\n\n      return user;\n    });\n  },\n  logIn: function (user\n  /*: ParseUser*/\n  , options\n  /*: RequestOptions*/\n  )\n  /*: Promise<ParseUser>*/\n  {\n    var RESTController = _CoreManager.default.getRESTController();\n\n    var stateController = _CoreManager.default.getObjectStateController();\n\n    var auth = {\n      username: user.get('username'),\n      password: user.get('password')\n    };\n    return RESTController.request('GET', 'login', auth, options).then(function (response) {\n      user._migrateId(response.objectId);\n\n      user._setExisted(true);\n\n      stateController.setPendingOp(user._getStateIdentifier(), 'username', undefined);\n      stateController.setPendingOp(user._getStateIdentifier(), 'password', undefined);\n      response.password = undefined;\n\n      user._finishFetch(response);\n\n      if (!canUseCurrentUser) {\n        // We can't set the current user, so just return the one we logged in\n        return Promise.resolve(user);\n      }\n\n      return DefaultController.setCurrentUser(user);\n    });\n  },\n  become: function (options\n  /*: RequestOptions*/\n  )\n  /*: Promise<ParseUser>*/\n  {\n    var user = new ParseUser();\n\n    var RESTController = _CoreManager.default.getRESTController();\n\n    return RESTController.request('GET', 'users/me', {}, options).then(function (response) {\n      user._finishFetch(response);\n\n      user._setExisted(true);\n\n      return DefaultController.setCurrentUser(user);\n    });\n  },\n  hydrate: function (userJSON\n  /*: AttributeMap*/\n  )\n  /*: Promise<ParseUser>*/\n  {\n    var user = new ParseUser();\n\n    user._finishFetch(userJSON);\n\n    user._setExisted(true);\n\n    if (userJSON.sessionToken && canUseCurrentUser) {\n      return DefaultController.setCurrentUser(user);\n    } else {\n      return Promise.resolve(user);\n    }\n  },\n  logOut: function ()\n  /*: Promise<ParseUser>*/\n  {\n    return DefaultController.currentUserAsync().then(function (currentUser) {\n      var path = _Storage.default.generatePath(CURRENT_USER_KEY);\n\n      var promise = _Storage.default.removeItemAsync(path);\n\n      var RESTController = _CoreManager.default.getRESTController();\n\n      if (currentUser !== null) {\n        var isAnonymous = _AnonymousUtils.default.isLinked(currentUser);\n\n        var currentSession = currentUser.getSessionToken();\n\n        if (currentSession && (0, _isRevocableSession.default)(currentSession)) {\n          promise = promise.then(function () {\n            if (isAnonymous) {\n              return currentUser.destroy({\n                sessionToken: currentSession\n              });\n            }\n          }).then(function () {\n            return RESTController.request('POST', 'logout', {}, {\n              sessionToken: currentSession\n            });\n          });\n        }\n\n        currentUser._logOutWithAll();\n\n        currentUser._finishFetch({\n          sessionToken: undefined\n        });\n      }\n\n      currentUserCacheMatchesDisk = true;\n      currentUserCache = null;\n      return promise;\n    });\n  },\n  requestPasswordReset: function (email\n  /*: string*/\n  , options\n  /*: RequestOptions*/\n  ) {\n    var RESTController = _CoreManager.default.getRESTController();\n\n    return RESTController.request('POST', 'requestPasswordReset', {\n      email: email\n    }, options);\n  },\n  upgradeToRevocableSession: function (user\n  /*: ParseUser*/\n  , options\n  /*: RequestOptions*/\n  ) {\n    var token = user.getSessionToken();\n\n    if (!token) {\n      return Promise.reject(new _ParseError.default(_ParseError.default.SESSION_MISSING, 'Cannot upgrade a user with no session token'));\n    }\n\n    options.sessionToken = token;\n\n    var RESTController = _CoreManager.default.getRESTController();\n\n    return RESTController.request('POST', 'upgradeToRevocableSession', {}, options).then(function (result) {\n      var session = new _ParseSession.default();\n\n      session._finishFetch(result);\n\n      user._finishFetch({\n        sessionToken: session.getSessionToken()\n      });\n\n      if (user.isCurrent()) {\n        return DefaultController.setCurrentUser(user);\n      }\n\n      return Promise.resolve(user);\n    });\n  },\n  linkWith: function (user\n  /*: ParseUser*/\n  , authData\n  /*: AuthData*/\n  , options\n  /*: FullOptions*/\n  ) {\n    return user.save({\n      authData: authData\n    }, options).then(function () {\n      if (canUseCurrentUser) {\n        return DefaultController.setCurrentUser(user);\n      }\n\n      return user;\n    });\n  }\n};\n\n_CoreManager.default.setUserController(DefaultController);\n\nvar _default = ParseUser;\nexports.default = _default;","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.send = send;\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\n\nvar _ParseQuery = _interopRequireDefault(require(\"./ParseQuery\"));\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n/**\n * Contains functions to deal with Push in Parse.\n * @class Parse.Push\n * @static\n * @hideconstructor\n */\n\n/**\n  * Sends a push notification.\n  * @method send\n  * @name Parse.Push.send\n  * @param {Object} data -  The data of the push notification.  Valid fields\n  * are:\n  *   <ol>\n  *     <li>channels - An Array of channels to push to.</li>\n  *     <li>push_time - A Date object for when to send the push.</li>\n  *     <li>expiration_time -  A Date object for when to expire\n  *         the push.</li>\n  *     <li>expiration_interval - The seconds from now to expire the push.</li>\n  *     <li>where - A Parse.Query over Parse.Installation that is used to match\n  *         a set of installations to push to.</li>\n  *     <li>data - The data to send as part of the push</li>\n  *   <ol>\n  * @param {Object} options An object that has an optional success function,\n  * that takes no arguments and will be called on a successful push, and\n  * an error function that takes a Parse.Error and will be called if the push\n  * failed.\n  * @return {Promise} A promise that is fulfilled when the push request\n  *     completes.\n  */\n\n\nfunction send(data\n/*: PushData*/\n, options\n/*:: ?: { useMasterKey?: boolean, success?: any, error?: any }*/\n)\n/*: Promise*/\n{\n  options = options || {};\n\n  if (data.where && data.where instanceof _ParseQuery.default) {\n    data.where = data.where.toJSON().where;\n  }\n\n  if (data.push_time && (0, _typeof2.default)(data.push_time) === 'object') {\n    data.push_time = data.push_time.toJSON();\n  }\n\n  if (data.expiration_time && (0, _typeof2.default)(data.expiration_time) === 'object') {\n    data.expiration_time = data.expiration_time.toJSON();\n  }\n\n  if (data.expiration_time && data.expiration_interval) {\n    throw new Error('expiration_time and expiration_interval cannot both be set.');\n  }\n\n  return _CoreManager.default.getPushController().send(data, {\n    useMasterKey: options.useMasterKey\n  });\n}\n\nvar DefaultController = {\n  send: function (data\n  /*: PushData*/\n  , options\n  /*: RequestOptions*/\n  ) {\n    var RESTController = _CoreManager.default.getRESTController();\n\n    var request = RESTController.request('POST', 'push', data, {\n      useMasterKey: !!options.useMasterKey\n    });\n    return request;\n  }\n};\n\n_CoreManager.default.setPushController(DefaultController);","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\n\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n/* global XMLHttpRequest, XDomainRequest */\n\n\nvar XHR = null;\n\nif (typeof XMLHttpRequest !== 'undefined') {\n  XHR = XMLHttpRequest;\n}\n\nvar useXDomainRequest = false;\n\nif (typeof XDomainRequest !== 'undefined' && !('withCredentials' in new XMLHttpRequest())) {\n  useXDomainRequest = true;\n}\n\nfunction ajaxIE9(method\n/*: string*/\n, url\n/*: string*/\n, data\n/*: any*/\n, options\n/*:: ?: FullOptions*/\n) {\n  return new Promise(function (resolve, reject) {\n    var xdr = new XDomainRequest();\n\n    xdr.onload = function () {\n      var response;\n\n      try {\n        response = JSON.parse(xdr.responseText);\n      } catch (e) {\n        reject(e);\n      }\n\n      if (response) {\n        resolve({\n          response: response\n        });\n      }\n    };\n\n    xdr.onerror = xdr.ontimeout = function () {\n      // Let's fake a real error message.\n      var fakeResponse = {\n        responseText: JSON.stringify({\n          code: _ParseError.default.X_DOMAIN_REQUEST,\n          error: 'IE\\'s XDomainRequest does not supply error info.'\n        })\n      };\n      reject(fakeResponse);\n    };\n\n    xdr.onprogress = function () {\n      if (options && typeof options.progress === 'function') {\n        options.progress(xdr.responseText);\n      }\n    };\n\n    xdr.open(method, url);\n    xdr.send(data);\n  });\n}\n\nvar RESTController = {\n  ajax: function (method\n  /*: string*/\n  , url\n  /*: string*/\n  , data\n  /*: any*/\n  , headers\n  /*:: ?: any*/\n  , options\n  /*:: ?: FullOptions*/\n  ) {\n    if (useXDomainRequest) {\n      return ajaxIE9(method, url, data, headers, options);\n    }\n\n    var res, rej;\n    var promise = new Promise(function (resolve, reject) {\n      res = resolve;\n      rej = reject;\n    });\n    promise.resolve = res;\n    promise.reject = rej;\n    var attempts = 0;\n\n    var dispatch = function dispatch() {\n      if (XHR == null) {\n        throw new Error('Cannot make a request: No definition of XMLHttpRequest was found.');\n      }\n\n      var handled = false;\n      var xhr = new XHR();\n\n      xhr.onreadystatechange = function () {\n        if (xhr.readyState !== 4 || handled) {\n          return;\n        }\n\n        handled = true;\n\n        if (xhr.status >= 200 && xhr.status < 300) {\n          var response;\n\n          try {\n            response = JSON.parse(xhr.responseText);\n\n            if (typeof xhr.getResponseHeader === 'function') {\n              if ((xhr.getAllResponseHeaders() || '').includes('x-parse-job-status-id: ')) {\n                response = xhr.getResponseHeader('x-parse-job-status-id');\n              }\n            }\n          } catch (e) {\n            promise.reject(e.toString());\n          }\n\n          if (response) {\n            promise.resolve({\n              response: response,\n              status: xhr.status,\n              xhr: xhr\n            });\n          }\n        } else if (xhr.status >= 500 || xhr.status === 0) {\n          // retry on 5XX or node-xmlhttprequest error\n          if (++attempts < _CoreManager.default.get('REQUEST_ATTEMPT_LIMIT')) {\n            // Exponentially-growing random delay\n            var delay = Math.round(Math.random() * 125 * Math.pow(2, attempts));\n            setTimeout(dispatch, delay);\n          } else if (xhr.status === 0) {\n            promise.reject('Unable to connect to the Parse API');\n          } else {\n            // After the retry limit is reached, fail\n            promise.reject(xhr);\n          }\n        } else {\n          promise.reject(xhr);\n        }\n      };\n\n      headers = headers || {};\n\n      if (typeof headers['Content-Type'] !== 'string') {\n        headers['Content-Type'] = 'text/plain'; // Avoid pre-flight\n      }\n\n      if (_CoreManager.default.get('IS_NODE')) {\n        headers['User-Agent'] = 'Parse/' + _CoreManager.default.get('VERSION') + ' (NodeJS ' + process.versions.node + ')';\n      }\n\n      if (_CoreManager.default.get('SERVER_AUTH_TYPE') && _CoreManager.default.get('SERVER_AUTH_TOKEN')) {\n        headers['Authorization'] = _CoreManager.default.get('SERVER_AUTH_TYPE') + ' ' + _CoreManager.default.get('SERVER_AUTH_TOKEN');\n      }\n\n      if (options && typeof options.progress === 'function') {\n        if (xhr.upload) {\n          xhr.upload.addEventListener('progress', function (oEvent) {\n            if (oEvent.lengthComputable) {\n              options.progress(oEvent.loaded / oEvent.total);\n            } else {\n              options.progress(null);\n            }\n          });\n        } else if (xhr.addEventListener) {\n          xhr.addEventListener('progress', function (oEvent) {\n            if (oEvent.lengthComputable) {\n              options.progress(oEvent.loaded / oEvent.total);\n            } else {\n              options.progress(null);\n            }\n          });\n        }\n      }\n\n      xhr.open(method, url, true);\n\n      for (var h in headers) {\n        xhr.setRequestHeader(h, headers[h]);\n      }\n\n      xhr.send(data);\n    };\n\n    dispatch();\n    return promise;\n  },\n  request: function (method\n  /*: string*/\n  , path\n  /*: string*/\n  , data\n  /*: mixed*/\n  , options\n  /*:: ?: RequestOptions*/\n  ) {\n    options = options || {};\n\n    var url = _CoreManager.default.get('SERVER_URL');\n\n    if (url[url.length - 1] !== '/') {\n      url += '/';\n    }\n\n    url += path;\n    var payload = {};\n\n    if (data && (0, _typeof2.default)(data) === 'object') {\n      for (var k in data) {\n        payload[k] = data[k];\n      }\n    }\n\n    if (method !== 'POST') {\n      payload._method = method;\n      method = 'POST';\n    }\n\n    payload._ApplicationId = _CoreManager.default.get('APPLICATION_ID');\n\n    var jsKey = _CoreManager.default.get('JAVASCRIPT_KEY');\n\n    if (jsKey) {\n      payload._JavaScriptKey = jsKey;\n    }\n\n    payload._ClientVersion = _CoreManager.default.get('VERSION');\n    var useMasterKey = options.useMasterKey;\n\n    if (typeof useMasterKey === 'undefined') {\n      useMasterKey = _CoreManager.default.get('USE_MASTER_KEY');\n    }\n\n    if (useMasterKey) {\n      if (_CoreManager.default.get('MASTER_KEY')) {\n        delete payload._JavaScriptKey;\n        payload._MasterKey = _CoreManager.default.get('MASTER_KEY');\n      } else {\n        throw new Error('Cannot use the Master Key, it has not been provided.');\n      }\n    }\n\n    if (_CoreManager.default.get('FORCE_REVOCABLE_SESSION')) {\n      payload._RevocableSession = '1';\n    }\n\n    var installationId = options.installationId;\n    var installationIdPromise;\n\n    if (installationId && typeof installationId === 'string') {\n      installationIdPromise = Promise.resolve(installationId);\n    } else {\n      var installationController = _CoreManager.default.getInstallationController();\n\n      installationIdPromise = installationController.currentInstallationId();\n    }\n\n    return installationIdPromise.then(function (iid) {\n      payload._InstallationId = iid;\n\n      var userController = _CoreManager.default.getUserController();\n\n      if (options && typeof options.sessionToken === 'string') {\n        return Promise.resolve(options.sessionToken);\n      } else if (userController) {\n        return userController.currentUserAsync().then(function (user) {\n          if (user) {\n            return Promise.resolve(user.getSessionToken());\n          }\n\n          return Promise.resolve(null);\n        });\n      }\n\n      return Promise.resolve(null);\n    }).then(function (token) {\n      if (token) {\n        payload._SessionToken = token;\n      }\n\n      var payloadString = JSON.stringify(payload);\n      return RESTController.ajax(method, url, payloadString, {}, options).then(function (_ref) {\n        var response = _ref.response;\n        return response;\n      });\n    }).catch(function (response\n    /*: { responseText: string }*/\n    ) {\n      // Transform the error into an instance of ParseError by trying to parse\n      // the error string as JSON\n      var error;\n\n      if (response && response.responseText) {\n        try {\n          var errorJSON = JSON.parse(response.responseText);\n          error = new _ParseError.default(errorJSON.code, errorJSON.error);\n        } catch (e) {\n          // If we fail to parse the error text, that's okay.\n          error = new _ParseError.default(_ParseError.default.INVALID_JSON, 'Received an error with invalid JSON from Parse: ' + response.responseText);\n        }\n      } else {\n        error = new _ParseError.default(_ParseError.default.CONNECTION_FAILED, 'XMLHttpRequest failed: ' + JSON.stringify(response));\n      }\n\n      return Promise.reject(error);\n    });\n  },\n  _setXHR: function (xhr\n  /*: any*/\n  ) {\n    XHR = xhr;\n  }\n};\nmodule.exports = RESTController;","\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getState = getState;\nexports.initializeState = initializeState;\nexports.removeState = removeState;\nexports.getServerData = getServerData;\nexports.setServerData = setServerData;\nexports.getPendingOps = getPendingOps;\nexports.setPendingOp = setPendingOp;\nexports.pushPendingState = pushPendingState;\nexports.popPendingState = popPendingState;\nexports.mergeFirstPendingState = mergeFirstPendingState;\nexports.getObjectCache = getObjectCache;\nexports.estimateAttribute = estimateAttribute;\nexports.estimateAttributes = estimateAttributes;\nexports.commitServerChanges = commitServerChanges;\nexports.enqueueTask = enqueueTask;\nexports.clearAllState = clearAllState;\nexports.duplicateState = duplicateState;\n\nvar ObjectStateMutations = _interopRequireWildcard(require(\"./ObjectStateMutations\"));\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n\nvar objectState\n/*: {\n  [className: string]: {\n    [id: string]: State\n  }\n}*/\n= {};\n\nfunction getState(obj\n/*: ObjectIdentifier*/\n)\n/*: ?State*/\n{\n  var classData = objectState[obj.className];\n\n  if (classData) {\n    return classData[obj.id] || null;\n  }\n\n  return null;\n}\n\nfunction initializeState(obj\n/*: ObjectIdentifier*/\n, initial\n/*:: ?: State*/\n)\n/*: State*/\n{\n  var state = getState(obj);\n\n  if (state) {\n    return state;\n  }\n\n  if (!objectState[obj.className]) {\n    objectState[obj.className] = {};\n  }\n\n  if (!initial) {\n    initial = ObjectStateMutations.defaultState();\n  }\n\n  state = objectState[obj.className][obj.id] = initial;\n  return state;\n}\n\nfunction removeState(obj\n/*: ObjectIdentifier*/\n)\n/*: ?State*/\n{\n  var state = getState(obj);\n\n  if (state === null) {\n    return null;\n  }\n\n  delete objectState[obj.className][obj.id];\n  return state;\n}\n\nfunction getServerData(obj\n/*: ObjectIdentifier*/\n)\n/*: AttributeMap*/\n{\n  var state = getState(obj);\n\n  if (state) {\n    return state.serverData;\n  }\n\n  return {};\n}\n\nfunction setServerData(obj\n/*: ObjectIdentifier*/\n, attributes\n/*: AttributeMap*/\n) {\n  var serverData = initializeState(obj).serverData;\n  ObjectStateMutations.setServerData(serverData, attributes);\n}\n\nfunction getPendingOps(obj\n/*: ObjectIdentifier*/\n)\n/*: Array<OpsMap>*/\n{\n  var state = getState(obj);\n\n  if (state) {\n    return state.pendingOps;\n  }\n\n  return [{}];\n}\n\nfunction setPendingOp(obj\n/*: ObjectIdentifier*/\n, attr\n/*: string*/\n, op\n/*: ?Op*/\n) {\n  var pendingOps = initializeState(obj).pendingOps;\n  ObjectStateMutations.setPendingOp(pendingOps, attr, op);\n}\n\nfunction pushPendingState(obj\n/*: ObjectIdentifier*/\n) {\n  var pendingOps = initializeState(obj).pendingOps;\n  ObjectStateMutations.pushPendingState(pendingOps);\n}\n\nfunction popPendingState(obj\n/*: ObjectIdentifier*/\n)\n/*: OpsMap*/\n{\n  var pendingOps = initializeState(obj).pendingOps;\n  return ObjectStateMutations.popPendingState(pendingOps);\n}\n\nfunction mergeFirstPendingState(obj\n/*: ObjectIdentifier*/\n) {\n  var pendingOps = getPendingOps(obj);\n  ObjectStateMutations.mergeFirstPendingState(pendingOps);\n}\n\nfunction getObjectCache(obj\n/*: ObjectIdentifier*/\n)\n/*: ObjectCache*/\n{\n  var state = getState(obj);\n\n  if (state) {\n    return state.objectCache;\n  }\n\n  return {};\n}\n\nfunction estimateAttribute(obj\n/*: ObjectIdentifier*/\n, attr\n/*: string*/\n)\n/*: mixed*/\n{\n  var serverData = getServerData(obj);\n  var pendingOps = getPendingOps(obj);\n  return ObjectStateMutations.estimateAttribute(serverData, pendingOps, obj.className, obj.id, attr);\n}\n\nfunction estimateAttributes(obj\n/*: ObjectIdentifier*/\n)\n/*: AttributeMap*/\n{\n  var serverData = getServerData(obj);\n  var pendingOps = getPendingOps(obj);\n  return ObjectStateMutations.estimateAttributes(serverData, pendingOps, obj.className, obj.id);\n}\n\nfunction commitServerChanges(obj\n/*: ObjectIdentifier*/\n, changes\n/*: AttributeMap*/\n) {\n  var state = initializeState(obj);\n  ObjectStateMutations.commitServerChanges(state.serverData, state.objectCache, changes);\n}\n\nfunction enqueueTask(obj\n/*: ObjectIdentifier*/\n, task\n/*: () => Promise*/\n)\n/*: Promise*/\n{\n  var state = initializeState(obj);\n  return state.tasks.enqueue(task);\n}\n\nfunction clearAllState() {\n  objectState = {};\n}\n\nfunction duplicateState(source\n/*: {id: string}*/\n, dest\n/*: {id: string}*/\n) {\n  dest.id = source.id;\n}","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n\nvar Storage = {\n  async: function ()\n  /*: boolean*/\n  {\n    var controller = _CoreManager.default.getStorageController();\n\n    return !!controller.async;\n  },\n  getItem: function (path\n  /*: string*/\n  )\n  /*: ?string*/\n  {\n    var controller = _CoreManager.default.getStorageController();\n\n    if (controller.async === 1) {\n      throw new Error('Synchronous storage is not supported by the current storage controller');\n    }\n\n    return controller.getItem(path);\n  },\n  getItemAsync: function (path\n  /*: string*/\n  )\n  /*: Promise<string>*/\n  {\n    var controller = _CoreManager.default.getStorageController();\n\n    if (controller.async === 1) {\n      return controller.getItemAsync(path);\n    }\n\n    return Promise.resolve(controller.getItem(path));\n  },\n  setItem: function (path\n  /*: string*/\n  , value\n  /*: string*/\n  )\n  /*: void*/\n  {\n    var controller = _CoreManager.default.getStorageController();\n\n    if (controller.async === 1) {\n      throw new Error('Synchronous storage is not supported by the current storage controller');\n    }\n\n    return controller.setItem(path, value);\n  },\n  setItemAsync: function (path\n  /*: string*/\n  , value\n  /*: string*/\n  )\n  /*: Promise<void>*/\n  {\n    var controller = _CoreManager.default.getStorageController();\n\n    if (controller.async === 1) {\n      return controller.setItemAsync(path, value);\n    }\n\n    return Promise.resolve(controller.setItem(path, value));\n  },\n  removeItem: function (path\n  /*: string*/\n  )\n  /*: void*/\n  {\n    var controller = _CoreManager.default.getStorageController();\n\n    if (controller.async === 1) {\n      throw new Error('Synchronous storage is not supported by the current storage controller');\n    }\n\n    return controller.removeItem(path);\n  },\n  removeItemAsync: function (path\n  /*: string*/\n  )\n  /*: Promise<void>*/\n  {\n    var controller = _CoreManager.default.getStorageController();\n\n    if (controller.async === 1) {\n      return controller.removeItemAsync(path);\n    }\n\n    return Promise.resolve(controller.removeItem(path));\n  },\n  generatePath: function (path\n  /*: string*/\n  )\n  /*: string*/\n  {\n    if (!_CoreManager.default.get('APPLICATION_ID')) {\n      throw new Error('You need to call Parse.initialize before using Parse.');\n    }\n\n    if (typeof path !== 'string') {\n      throw new Error('Tried to get a Storage path that was not a String.');\n    }\n\n    if (path[0] === '/') {\n      path = path.substr(1);\n    }\n\n    return 'Parse/' + _CoreManager.default.get('APPLICATION_ID') + '/' + path;\n  },\n  _clear: function () {\n    var controller = _CoreManager.default.getStorageController();\n\n    if (controller.hasOwnProperty('clear')) {\n      controller.clear();\n    }\n  }\n};\nmodule.exports = Storage;\n\n_CoreManager.default.setStorageController(require('./StorageController.browser'));","\"use strict\";\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n/* global localStorage */\n\nvar StorageController = {\n  async: 0,\n  getItem: function (path\n  /*: string*/\n  )\n  /*: ?string*/\n  {\n    return localStorage.getItem(path);\n  },\n  setItem: function (path\n  /*: string*/\n  , value\n  /*: string*/\n  ) {\n    try {\n      localStorage.setItem(path, value);\n    } catch (e) {// Quota exceeded, possibly due to Safari Private Browsing mode\n    }\n  },\n  removeItem: function (path\n  /*: string*/\n  ) {\n    localStorage.removeItem(path);\n  },\n  clear: function () {\n    localStorage.clear();\n  }\n};\nmodule.exports = StorageController;","/*:: type Task = {\n  task: () => Promise;\n  _completion: Promise\n};*/\n\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n\nvar TaskQueue =\n/*#__PURE__*/\nfunction () {\n  function TaskQueue() {\n    (0, _classCallCheck2.default)(this, TaskQueue);\n    (0, _defineProperty2.default)(this, \"queue\", void 0);\n    this.queue = [];\n  }\n\n  (0, _createClass2.default)(TaskQueue, [{\n    key: \"enqueue\",\n    value: function (task\n    /*: () => Promise*/\n    )\n    /*: Promise*/\n    {\n      var _this = this;\n\n      var res;\n      var rej;\n      var taskComplete = new Promise(function (resolve, reject) {\n        res = resolve;\n        rej = reject;\n      });\n      taskComplete.resolve = res;\n      taskComplete.reject = rej;\n      this.queue.push({\n        task: task,\n        _completion: taskComplete\n      });\n\n      if (this.queue.length === 1) {\n        task().then(function () {\n          _this._dequeue();\n\n          taskComplete.resolve();\n        }, function (error) {\n          _this._dequeue();\n\n          taskComplete.reject(error);\n        });\n      }\n\n      return taskComplete;\n    }\n  }, {\n    key: \"_dequeue\",\n    value: function () {\n      var _this2 = this;\n\n      this.queue.shift();\n\n      if (this.queue.length) {\n        var next = this.queue[0];\n        next.task().then(function () {\n          _this2._dequeue();\n\n          next._completion.resolve();\n        }, function (error) {\n          _this2._dequeue();\n\n          next._completion.reject(error);\n        });\n      }\n    }\n  }]);\n  return TaskQueue;\n}();\n\nmodule.exports = TaskQueue;","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getState = getState;\nexports.initializeState = initializeState;\nexports.removeState = removeState;\nexports.getServerData = getServerData;\nexports.setServerData = setServerData;\nexports.getPendingOps = getPendingOps;\nexports.setPendingOp = setPendingOp;\nexports.pushPendingState = pushPendingState;\nexports.popPendingState = popPendingState;\nexports.mergeFirstPendingState = mergeFirstPendingState;\nexports.getObjectCache = getObjectCache;\nexports.estimateAttribute = estimateAttribute;\nexports.estimateAttributes = estimateAttributes;\nexports.commitServerChanges = commitServerChanges;\nexports.enqueueTask = enqueueTask;\nexports.duplicateState = duplicateState;\nexports.clearAllState = clearAllState;\n\nvar ObjectStateMutations = _interopRequireWildcard(require(\"./ObjectStateMutations\"));\n\nvar _TaskQueue = _interopRequireDefault(require(\"./TaskQueue\"));\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n\nvar objectState = new WeakMap();\n\nfunction getState(obj\n/*: ParseObject*/\n)\n/*: ?State*/\n{\n  var classData = objectState.get(obj);\n  return classData || null;\n}\n\nfunction initializeState(obj\n/*: ParseObject*/\n, initial\n/*:: ?: State*/\n)\n/*: State*/\n{\n  var state = getState(obj);\n\n  if (state) {\n    return state;\n  }\n\n  if (!initial) {\n    initial = {\n      serverData: {},\n      pendingOps: [{}],\n      objectCache: {},\n      tasks: new _TaskQueue.default(),\n      existed: false\n    };\n  }\n\n  state = initial;\n  objectState.set(obj, state);\n  return state;\n}\n\nfunction removeState(obj\n/*: ParseObject*/\n)\n/*: ?State*/\n{\n  var state = getState(obj);\n\n  if (state === null) {\n    return null;\n  }\n\n  objectState.delete(obj);\n  return state;\n}\n\nfunction getServerData(obj\n/*: ParseObject*/\n)\n/*: AttributeMap*/\n{\n  var state = getState(obj);\n\n  if (state) {\n    return state.serverData;\n  }\n\n  return {};\n}\n\nfunction setServerData(obj\n/*: ParseObject*/\n, attributes\n/*: AttributeMap*/\n) {\n  var serverData = initializeState(obj).serverData;\n  ObjectStateMutations.setServerData(serverData, attributes);\n}\n\nfunction getPendingOps(obj\n/*: ParseObject*/\n)\n/*: Array<OpsMap>*/\n{\n  var state = getState(obj);\n\n  if (state) {\n    return state.pendingOps;\n  }\n\n  return [{}];\n}\n\nfunction setPendingOp(obj\n/*: ParseObject*/\n, attr\n/*: string*/\n, op\n/*: ?Op*/\n) {\n  var pendingOps = initializeState(obj).pendingOps;\n  ObjectStateMutations.setPendingOp(pendingOps, attr, op);\n}\n\nfunction pushPendingState(obj\n/*: ParseObject*/\n) {\n  var pendingOps = initializeState(obj).pendingOps;\n  ObjectStateMutations.pushPendingState(pendingOps);\n}\n\nfunction popPendingState(obj\n/*: ParseObject*/\n)\n/*: OpsMap*/\n{\n  var pendingOps = initializeState(obj).pendingOps;\n  return ObjectStateMutations.popPendingState(pendingOps);\n}\n\nfunction mergeFirstPendingState(obj\n/*: ParseObject*/\n) {\n  var pendingOps = getPendingOps(obj);\n  ObjectStateMutations.mergeFirstPendingState(pendingOps);\n}\n\nfunction getObjectCache(obj\n/*: ParseObject*/\n)\n/*: ObjectCache*/\n{\n  var state = getState(obj);\n\n  if (state) {\n    return state.objectCache;\n  }\n\n  return {};\n}\n\nfunction estimateAttribute(obj\n/*: ParseObject*/\n, attr\n/*: string*/\n)\n/*: mixed*/\n{\n  var serverData = getServerData(obj);\n  var pendingOps = getPendingOps(obj);\n  return ObjectStateMutations.estimateAttribute(serverData, pendingOps, obj.className, obj.id, attr);\n}\n\nfunction estimateAttributes(obj\n/*: ParseObject*/\n)\n/*: AttributeMap*/\n{\n  var serverData = getServerData(obj);\n  var pendingOps = getPendingOps(obj);\n  return ObjectStateMutations.estimateAttributes(serverData, pendingOps, obj.className, obj.id);\n}\n\nfunction commitServerChanges(obj\n/*: ParseObject*/\n, changes\n/*: AttributeMap*/\n) {\n  var state = initializeState(obj);\n  ObjectStateMutations.commitServerChanges(state.serverData, state.objectCache, changes);\n}\n\nfunction enqueueTask(obj\n/*: ParseObject*/\n, task\n/*: () => Promise*/\n)\n/*: Promise*/\n{\n  var state = initializeState(obj);\n  return state.tasks.enqueue(task);\n}\n\nfunction duplicateState(source\n/*: ParseObject*/\n, dest\n/*: ParseObject*/\n)\n/*: void*/\n{\n  var oldState = initializeState(source);\n  var newState = initializeState(dest);\n\n  for (var key in oldState.serverData) {\n    newState.serverData[key] = oldState.serverData[key];\n  }\n\n  for (var index = 0; index < oldState.pendingOps.length; index++) {\n    for (var _key in oldState.pendingOps[index]) {\n      newState.pendingOps[index][_key] = oldState.pendingOps[index][_key];\n    }\n  }\n\n  for (var _key2 in oldState.objectCache) {\n    newState.objectCache[_key2] = oldState.objectCache[_key2];\n  }\n\n  newState.existed = oldState.existed;\n}\n\nfunction clearAllState() {\n  objectState = new WeakMap();\n}","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = arrayContainsObject;\n\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n\nfunction arrayContainsObject(array\n/*: Array<any>*/\n, object\n/*: ParseObject*/\n)\n/*: boolean*/\n{\n  if (array.indexOf(object) > -1) {\n    return true;\n  }\n\n  for (var i = 0; i < array.length; i++) {\n    if (array[i] instanceof _ParseObject.default && array[i].className === object.className && array[i]._getId() === object._getId()) {\n      return true;\n    }\n  }\n\n  return false;\n}","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = canBeSerialized;\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _ParseFile = _interopRequireDefault(require(\"./ParseFile\"));\n\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\n\nvar _ParseRelation = _interopRequireDefault(require(\"./ParseRelation\"));\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n\nfunction canBeSerialized(obj\n/*: ParseObject*/\n)\n/*: boolean*/\n{\n  if (!(obj instanceof _ParseObject.default)) {\n    return true;\n  }\n\n  var attributes = obj.attributes;\n\n  for (var attr in attributes) {\n    var val = attributes[attr];\n\n    if (!canBeSerializedHelper(val)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction canBeSerializedHelper(value\n/*: any*/\n)\n/*: boolean*/\n{\n  if ((0, _typeof2.default)(value) !== 'object') {\n    return true;\n  }\n\n  if (value instanceof _ParseRelation.default) {\n    return true;\n  }\n\n  if (value instanceof _ParseObject.default) {\n    return !!value.id;\n  }\n\n  if (value instanceof _ParseFile.default) {\n    if (value.url()) {\n      return true;\n    }\n\n    return false;\n  }\n\n  if (Array.isArray(value)) {\n    for (var i = 0; i < value.length; i++) {\n      if (!canBeSerializedHelper(value[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  for (var k in value) {\n    if (!canBeSerializedHelper(value[k])) {\n      return false;\n    }\n  }\n\n  return true;\n}","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = decode;\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _ParseACL = _interopRequireDefault(require(\"./ParseACL\"));\n\nvar _ParseFile = _interopRequireDefault(require(\"./ParseFile\"));\n\nvar _ParseGeoPoint = _interopRequireDefault(require(\"./ParseGeoPoint\"));\n\nvar _ParsePolygon = _interopRequireDefault(require(\"./ParsePolygon\"));\n\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\n\nvar _ParseOp = require(\"./ParseOp\");\n\nvar _ParseRelation = _interopRequireDefault(require(\"./ParseRelation\"));\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n// eslint-disable-line no-unused-vars\n\n\nfunction decode(value\n/*: any*/\n)\n/*: any*/\n{\n  if (value === null || (0, _typeof2.default)(value) !== 'object') {\n    return value;\n  }\n\n  if (Array.isArray(value)) {\n    var dup = [];\n    value.forEach(function (v, i) {\n      dup[i] = decode(v);\n    });\n    return dup;\n  }\n\n  if (typeof value.__op === 'string') {\n    return (0, _ParseOp.opFromJSON)(value);\n  }\n\n  if (value.__type === 'Pointer' && value.className) {\n    return _ParseObject.default.fromJSON(value);\n  }\n\n  if (value.__type === 'Object' && value.className) {\n    return _ParseObject.default.fromJSON(value);\n  }\n\n  if (value.__type === 'Relation') {\n    // The parent and key fields will be populated by the parent\n    var relation = new _ParseRelation.default(null, null);\n    relation.targetClassName = value.className;\n    return relation;\n  }\n\n  if (value.__type === 'Date') {\n    return new Date(value.iso);\n  }\n\n  if (value.__type === 'File') {\n    return _ParseFile.default.fromJSON(value);\n  }\n\n  if (value.__type === 'GeoPoint') {\n    return new _ParseGeoPoint.default({\n      latitude: value.latitude,\n      longitude: value.longitude\n    });\n  }\n\n  if (value.__type === 'Polygon') {\n    return new _ParsePolygon.default(value.coordinates);\n  }\n\n  var copy = {};\n\n  for (var k in value) {\n    copy[k] = decode(value[k]);\n  }\n\n  return copy;\n}","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _ParseACL = _interopRequireDefault(require(\"./ParseACL\"));\n\nvar _ParseFile = _interopRequireDefault(require(\"./ParseFile\"));\n\nvar _ParseGeoPoint = _interopRequireDefault(require(\"./ParseGeoPoint\"));\n\nvar _ParsePolygon = _interopRequireDefault(require(\"./ParsePolygon\"));\n\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\n\nvar _ParseOp = require(\"./ParseOp\");\n\nvar _ParseRelation = _interopRequireDefault(require(\"./ParseRelation\"));\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n\nvar toString = Object.prototype.toString;\n\nfunction encode(value\n/*: mixed*/\n, disallowObjects\n/*: boolean*/\n, forcePointers\n/*: boolean*/\n, seen\n/*: Array<mixed>*/\n)\n/*: any*/\n{\n  if (value instanceof _ParseObject.default) {\n    if (disallowObjects) {\n      throw new Error('Parse Objects not allowed here');\n    }\n\n    var seenEntry = value.id ? value.className + ':' + value.id : value;\n\n    if (forcePointers || !seen || seen.indexOf(seenEntry) > -1 || value.dirty() || Object.keys(value._getServerData()).length < 1) {\n      return value.toPointer();\n    }\n\n    seen = seen.concat(seenEntry);\n    return value._toFullJSON(seen);\n  }\n\n  if (value instanceof _ParseOp.Op || value instanceof _ParseACL.default || value instanceof _ParseGeoPoint.default || value instanceof _ParsePolygon.default || value instanceof _ParseRelation.default) {\n    return value.toJSON();\n  }\n\n  if (value instanceof _ParseFile.default) {\n    if (!value.url()) {\n      throw new Error('Tried to encode an unsaved file.');\n    }\n\n    return value.toJSON();\n  }\n\n  if (toString.call(value) === '[object Date]') {\n    if (isNaN(value)) {\n      throw new Error('Tried to encode an invalid date.');\n    }\n\n    return {\n      __type: 'Date',\n      iso: value\n      /*: any*/\n      .toJSON()\n    };\n  }\n\n  if (toString.call(value) === '[object RegExp]' && typeof value.source === 'string') {\n    return value.source;\n  }\n\n  if (Array.isArray(value)) {\n    return value.map(function (v) {\n      return encode(v, disallowObjects, forcePointers, seen);\n    });\n  }\n\n  if (value && (0, _typeof2.default)(value) === 'object') {\n    var output = {};\n\n    for (var k in value) {\n      output[k] = encode(value[k], disallowObjects, forcePointers, seen);\n    }\n\n    return output;\n  }\n\n  return value;\n}\n\nfunction _default(value\n/*: mixed*/\n, disallowObjects\n/*:: ?: boolean*/\n, forcePointers\n/*:: ?: boolean*/\n, seen\n/*:: ?: Array<mixed>*/\n)\n/*: any*/\n{\n  return encode(value, !!disallowObjects, !!forcePointers, seen || []);\n}","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = equals;\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _ParseACL = _interopRequireDefault(require(\"./ParseACL\"));\n\nvar _ParseFile = _interopRequireDefault(require(\"./ParseFile\"));\n\nvar _ParseGeoPoint = _interopRequireDefault(require(\"./ParseGeoPoint\"));\n\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n\nvar toString = Object.prototype.toString;\n\nfunction equals(a, b) {\n  if (toString.call(a) === '[object Date]' || toString.call(b) === '[object Date]') {\n    var dateA = new Date(a);\n    var dateB = new Date(b);\n    return +dateA === +dateB;\n  }\n\n  if ((0, _typeof2.default)(a) !== (0, _typeof2.default)(b)) {\n    return false;\n  }\n\n  if (!a || (0, _typeof2.default)(a) !== 'object') {\n    // a is a primitive\n    return a === b;\n  }\n\n  if (Array.isArray(a) || Array.isArray(b)) {\n    if (!Array.isArray(a) || !Array.isArray(b)) {\n      return false;\n    }\n\n    if (a.length !== b.length) {\n      return false;\n    }\n\n    for (var i = a.length; i--;) {\n      if (!equals(a[i], b[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  if (a instanceof _ParseACL.default || a instanceof _ParseFile.default || a instanceof _ParseGeoPoint.default || a instanceof _ParseObject.default) {\n    return a.equals(b);\n  }\n\n  if (b instanceof _ParseObject.default) {\n    if (a.__type === 'Object' || a.__type === 'Pointer') {\n      return a.objectId === b.id && a.className === b.className;\n    }\n  }\n\n  if (Object.keys(a).length !== Object.keys(b).length) {\n    return false;\n  }\n\n  for (var k in a) {\n    if (!equals(a[k], b[k])) {\n      return false;\n    }\n  }\n\n  return true;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = escape;\n/*\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\nvar encoded = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '/': '&#x2F;',\n  '\\'': '&#x27;',\n  '\"': '&quot;'\n};\n\nfunction escape(str\n/*: string*/\n)\n/*: string*/\n{\n  return str.replace(/[&<>\\/'\"]/g, function (char) {\n    return encoded[char];\n  });\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isRevocableSession;\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\nfunction isRevocableSession(token\n/*: string*/\n)\n/*: boolean*/\n{\n  return token.indexOf('r:') > -1;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = parseDate;\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\nfunction parseDate(iso8601\n/*: string*/\n)\n/*: ?Date*/\n{\n  var regexp = new RegExp('^([0-9]{1,4})-([0-9]{1,2})-([0-9]{1,2})' + 'T' + '([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2})' + '(.([0-9]+))?' + 'Z$');\n  var match = regexp.exec(iso8601);\n\n  if (!match) {\n    return null;\n  }\n\n  var year = parseInt(match[1]) || 0;\n  var month = (parseInt(match[2]) || 1) - 1;\n  var day = parseInt(match[3]) || 0;\n  var hour = parseInt(match[4]) || 0;\n  var minute = parseInt(match[5]) || 0;\n  var second = parseInt(match[6]) || 0;\n  var milli = parseInt(match[8]) || 0;\n  return new Date(Date.UTC(year, month, day, hour, minute, second, milli));\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolvingPromise = resolvingPromise;\nexports.when = when;\nexports.continueWhile = continueWhile;\n\nfunction resolvingPromise() {\n  var res;\n  var rej;\n  var promise = new Promise(function (resolve, reject) {\n    res = resolve;\n    rej = reject;\n  });\n  promise.resolve = res;\n  promise.reject = rej;\n  return promise;\n}\n\nfunction when(promises) {\n  var objects;\n  var arrayArgument = Array.isArray(promises);\n\n  if (arrayArgument) {\n    objects = promises;\n  } else {\n    objects = arguments;\n  }\n\n  var total = objects.length;\n  var hadError = false;\n  var results = [];\n  var returnValue = arrayArgument ? [results] : results;\n  var errors = [];\n  results.length = objects.length;\n  errors.length = objects.length;\n\n  if (total === 0) {\n    return Promise.resolve(returnValue);\n  }\n\n  var promise = new resolvingPromise();\n\n  var resolveOne = function () {\n    total--;\n\n    if (total <= 0) {\n      if (hadError) {\n        promise.reject(errors);\n      } else {\n        promise.resolve(returnValue);\n      }\n    }\n  };\n\n  var chain = function (object, index) {\n    if (object && typeof object.then === 'function') {\n      object.then(function (result) {\n        results[index] = result;\n        resolveOne();\n      }, function (error) {\n        errors[index] = error;\n        hadError = true;\n        resolveOne();\n      });\n    } else {\n      results[index] = object;\n      resolveOne();\n    }\n  };\n\n  for (var i = 0; i < objects.length; i++) {\n    chain(objects[i], i);\n  }\n\n  return promise;\n}\n\nfunction continueWhile(test, emitter) {\n  if (test()) {\n    return emitter().then(function () {\n      return continueWhile(test, emitter);\n    });\n  }\n\n  return Promise.resolve();\n}","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = unique;\n\nvar _arrayContainsObject = _interopRequireDefault(require(\"./arrayContainsObject\"));\n\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n\nfunction unique\n/*:: <T>*/\n(arr\n/*: Array<T>*/\n)\n/*: Array<T>*/\n{\n  var uniques = [];\n  arr.forEach(function (value) {\n    if (value instanceof _ParseObject.default) {\n      if (!(0, _arrayContainsObject.default)(uniques, value)) {\n        uniques.push(value);\n      }\n    } else {\n      if (uniques.indexOf(value) < 0) {\n        uniques.push(value);\n      }\n    }\n  });\n  return uniques;\n}","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = unsavedChildren;\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _ParseFile = _interopRequireDefault(require(\"./ParseFile\"));\n\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\n\nvar _ParseRelation = _interopRequireDefault(require(\"./ParseRelation\"));\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n/**\n * Return an array of unsaved children, which are either Parse Objects or Files.\n * If it encounters any dirty Objects without Ids, it will throw an exception.\n */\n\n\nfunction unsavedChildren(obj\n/*: ParseObject*/\n, allowDeepUnsaved\n/*:: ?: boolean*/\n)\n/*: Array<ParseFile | ParseObject>*/\n{\n  var encountered = {\n    objects: {},\n    files: []\n  };\n\n  var identifier = obj.className + ':' + obj._getId();\n\n  encountered.objects[identifier] = obj.dirty() ? obj : true;\n  var attributes = obj.attributes;\n\n  for (var attr in attributes) {\n    if ((0, _typeof2.default)(attributes[attr]) === 'object') {\n      traverse(attributes[attr], encountered, false, !!allowDeepUnsaved);\n    }\n  }\n\n  var unsaved = [];\n\n  for (var id in encountered.objects) {\n    if (id !== identifier && encountered.objects[id] !== true) {\n      unsaved.push(encountered.objects[id]);\n    }\n  }\n\n  return unsaved.concat(encountered.files);\n}\n\nfunction traverse(obj\n/*: ParseObject*/\n, encountered\n/*: EncounterMap*/\n, shouldThrow\n/*: boolean*/\n, allowDeepUnsaved\n/*: boolean*/\n) {\n  if (obj instanceof _ParseObject.default) {\n    if (!obj.id && shouldThrow) {\n      throw new Error('Cannot create a pointer to an unsaved Object.');\n    }\n\n    var _identifier = obj.className + ':' + obj._getId();\n\n    if (!encountered.objects[_identifier]) {\n      encountered.objects[_identifier] = obj.dirty() ? obj : true;\n      var attributes = obj.attributes;\n\n      for (var attr in attributes) {\n        if ((0, _typeof2.default)(attributes[attr]) === 'object') {\n          traverse(attributes[attr], encountered, !allowDeepUnsaved, allowDeepUnsaved);\n        }\n      }\n    }\n\n    return;\n  }\n\n  if (obj instanceof _ParseFile.default) {\n    if (!obj.url() && encountered.files.indexOf(obj) < 0) {\n      encountered.files.push(obj);\n    }\n\n    return;\n  }\n\n  if (obj instanceof _ParseRelation.default) {\n    return;\n  }\n\n  if (Array.isArray(obj)) {\n    obj.forEach(function (el) {\n      if ((0, _typeof2.default)(el) === 'object') {\n        traverse(el, encountered, shouldThrow, allowDeepUnsaved);\n      }\n    });\n  }\n\n  for (var k in obj) {\n    if ((0, _typeof2.default)(obj[k]) === 'object') {\n      traverse(obj[k], encountered, shouldThrow, allowDeepUnsaved);\n    }\n  }\n}","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n  return ([bth[buf[i++]], bth[buf[i++]], \n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]],\n\tbth[buf[i++]], bth[buf[i++]],\n\tbth[buf[i++]], bth[buf[i++]]]).join('');\n}\n\nmodule.exports = bytesToUuid;\n","// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\n\n// getRandomValues needs to be invoked in a context where \"this\" is a Crypto\n// implementation. Also, find the complete implementation of crypto on IE11.\nvar getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||\n                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));\n\nif (getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\n  module.exports = function whatwgRNG() {\n    getRandomValues(rnds8);\n    return rnds8;\n  };\n} else {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var rnds = new Array(16);\n\n  module.exports = function mathRNG() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}\n","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n"],"sourceRoot":""}