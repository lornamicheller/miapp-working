import { Observable } from 'rxjs';
import * as moment_ from 'moment';
import { CommonModule } from '@angular/common';
import { __awaiter } from 'tslib';
import { Injectable, NgModule, Directive, ElementRef, Renderer, Input, HostListener, defineInjectable, forwardRef, Component, ViewChild } from '@angular/core';
import { NavParams, ModalController, IonicModule } from '@ionic/angular';
import { NG_VALUE_ACCESSOR, NgModel, NgControl, FormsModule } from '@angular/forms';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IonicTimepickerService {
    constructor() { }
}
IonicTimepickerService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
IonicTimepickerService.ctorParameters = () => [];
/** @nocollapse */ IonicTimepickerService.ngInjectableDef = defineInjectable({ factory: function IonicTimepickerService_Factory() { return new IonicTimepickerService(); }, token: IonicTimepickerService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// const memo = memo_.Resolver;
/** @type {?} */
const moment = moment_;
class IonicTimepickerModalComponent {
    /**
     * @param {?} navParams
     * @param {?} modalCtrl
     */
    constructor(navParams, modalCtrl) {
        this.navParams = navParams;
        this.modalCtrl = modalCtrl;
        this.hoursArray = [];
        this.minutesArray = [];
        this.secondsArray = [];
        this.meridianArray = [];
        this.slideOptsHours = {
            centeredSlides: true,
            slidesPerView: 5,
            initialSlide: 0,
            direction: 'vertical',
            loop: true
        };
        this.slideOptsMinutes = {
            centeredSlides: true,
            slidesPerView: 5,
            initialSlide: 0,
            direction: 'vertical',
            loop: true
        };
        this.slideOptsSeconds = {
            centeredSlides: true,
            slidesPerView: 5,
            initialSlide: 0,
            direction: 'vertical',
            loop: true
        };
        this.slideOptsMeridian = {
            centeredSlides: true,
            slidesPerView: 5,
            initialSlide: 0,
            direction: 'vertical',
            loop: false
        };
        this.sliderHoursActiveIndex = 0;
        this.sliderMinutesActiveIndex = 0;
        this.sliderSecondsActiveIndex = 0;
        this.sliderMeridianActiveIndex = 0;
        this.mainObj = {};
        this.isReady = false;
        this.inItTimePicker().subscribe();
    }
    /**
     * @return {?}
     */
    ionViewDidEnter() {
        // this.inItTimePicker().subscribe();
        // this.inItTimePicker();
    }
    /**
     * @return {?}
     */
    inItTimePicker() {
        /** @type {?} */
        const myObservable = new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        observer => {
            if (this.navParams.get('selectedTime')) {
                console.log('Selected time =>', this.navParams.get('selectedTime'));
                this.selectedTime = this.navParams.get('selectedTime');
            }
            this.mainObj = this.initTimePickerObject(this.navParams.get('objConfig'));
            this.setHoursArray(this.mainObj.timeFormat);
            this.setMinutesArray(this.mainObj.timeFormat);
            this.setSecondsArray(this.mainObj.timeFormat);
            this.setMeridianArray(this.mainObj.timeFormat);
            // setTimeout(() => {
            this.isReady = true;
            // }, 100);
            observer.complete();
        }));
        return myObservable;
    }
    // get slider hours active index
    /**
     * @param {?} event
     * @return {?}
     */
    onChangeHoursSlide(event) {
        this.sliderHoursActiveIndex = event.target.swiper.realIndex;
    }
    // get slider minutes active index
    /**
     * @param {?} event
     * @return {?}
     */
    onChangeMinutesSlide(event) {
        this.sliderMinutesActiveIndex = event.target.swiper.realIndex;
    }
    // get slider seconds active index
    /**
     * @param {?} event
     * @return {?}
     */
    onChangeSecondsSlide(event) {
        this.sliderSecondsActiveIndex = event.target.swiper.realIndex;
    }
    // get slider seconds active index
    /**
     * @param {?} event
     * @return {?}
     */
    onChangeMeridianSlide(event) {
        this.sliderMeridianActiveIndex = event.target.swiper.realIndex;
    }
    // initialize timepicker Object
    /**
     * @param {?} config
     * @return {?}
     */
    initTimePickerObject(config) {
        if (config.inputTime && !this.selectedTime) {
            this.selectedTime = config.inputTime;
        }
        /** @type {?} */
        const objConfig = {};
        objConfig.momentLocale = config.momentLocale ? config.momentLocale : 'en-US';
        moment.locale(objConfig.momentLocale);
        objConfig.timeFormat = config.timeFormat ? config.timeFormat : 'hh:mm A';
        if (typeof (this.selectedTime) === 'string') {
            this.momentObj = this.selectedTime ?
                moment(this.selectedTime, objConfig.timeFormat) :
                moment(moment(new Date().getTime()));
        }
        else {
            this.momentObj = this.selectedTime ?
                moment(this.selectedTime) :
                moment(moment(new Date().getTime()));
        }
        objConfig.setLabel = config.setLabel ? config.setLabel : 'Set';
        objConfig.closeLabel = config.closeLabel ? config.closeLabel : 'Close';
        objConfig.titleLabel = config.titleLabel ? config.titleLabel : 'Time';
        objConfig.btnCloseSetInReverse = config.btnCloseSetInReverse ? config.btnCloseSetInReverse : false;
        objConfig.btnProperties = {};
        if (config.btnProperties) {
            /** @type {?} */
            const btnProperties = config.btnProperties;
            objConfig.btnProperties.expand = btnProperties.expand ? btnProperties.expand : 'block';
            objConfig.btnProperties.fill = btnProperties.fill ? btnProperties.fill : 'solid';
            objConfig.btnProperties.size = btnProperties.size ? btnProperties.size : 'default';
            objConfig.btnProperties.color = btnProperties.color ? btnProperties.color : '';
            objConfig.btnProperties.disabled = btnProperties.disabled ? btnProperties.disabled : false;
            objConfig.btnProperties.strong = btnProperties.strong ? btnProperties.strong : false;
        }
        else {
            objConfig.btnProperties.expand = 'block';
            objConfig.btnProperties.fill = 'solid';
            objConfig.btnProperties.size = 'default';
            objConfig.btnProperties.disabled = false;
            objConfig.btnProperties.strong = false;
        }
        return objConfig;
    }
    // close modal
    /**
     * @return {?}
     */
    closeIonicTimePickerModal() {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const modal = yield this.modalCtrl.getTop();
            modal.dismiss('');
        });
    }
    // set time in modal dismiss method
    /**
     * @return {?}
     */
    setIonicTimePickerTime() {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const modal = yield this.modalCtrl.getTop();
            this.selectedTime = this.setTimeInMomentObject();
            modal.dismiss({ time: (this.selectedTime) });
        });
    }
    // set time in moment object
    /**
     * @return {?}
     */
    setTimeInMomentObject() {
        /** @type {?} */
        const formateArray = [];
        /** @type {?} */
        const timeArray = [];
        /** @type {?} */
        const charZeroInLocale = moment().second(0).format('s');
        // console.log('charZeroInLocale : ' + charZeroInLocale);
        if (this.mainObj.timeFormat.indexOf('H') >= 0) {
            formateArray.push('H');
            /** @type {?} */
            let hourString = this.hoursArray[this.sliderHoursActiveIndex];
            // hourString = hourString.replace(/^0+/, '');
            timeArray.push(hourString);
        }
        if (this.mainObj.timeFormat.indexOf('h') >= 0) {
            formateArray.push('h');
            /** @type {?} */
            let hourString = this.hoursArray[this.sliderHoursActiveIndex];
            // hourString = hourString.replace(/^0+/, '');
            timeArray.push(hourString);
        }
        if (this.mainObj.timeFormat.indexOf('k') >= 0) {
            formateArray.push('k');
            /** @type {?} */
            let hourString = this.hoursArray[this.sliderHoursActiveIndex];
            // hourString = hourString.replace(/^0+/, '');
            timeArray.push(hourString);
        }
        if (this.mainObj.timeFormat.indexOf('m') >= 0) {
            formateArray.push('m');
            /** @type {?} */
            let minString = this.minutesArray[this.sliderMinutesActiveIndex];
            // minString = minString.replace(/^0+/, '');
            timeArray.push(minString);
        }
        if (this.mainObj.timeFormat.indexOf('s') >= 0) {
            formateArray.push('s');
            /** @type {?} */
            let secString = this.secondsArray[this.sliderSecondsActiveIndex];
            // secString = secString.replace(/^0+/, '');
            timeArray.push(secString);
        }
        if (this.mainObj.timeFormat.indexOf('a') >= 0 || this.mainObj.timeFormat.indexOf('A') >= 0) {
            formateArray.push('a');
            /** @type {?} */
            let meridianString = this.meridianArray[this.sliderMeridianActiveIndex].toLowerCase();
            timeArray.push(meridianString);
        }
        /** @type {?} */
        const formateString = formateArray.join(':');
        /** @type {?} */
        const timeString = timeArray.join(':');
        // this.momentObj = mmObj;
        // console.log('timeString: ' + timeString + '  formateString: ' + formateString);
        /** @type {?} */
        const mmObj = moment(timeString, formateString);
        return mmObj.format(this.mainObj.timeFormat);
    }
    // sets hours array
    /**
     * @param {?} timeFormat
     * @return {?}
     */
    setHoursArray(timeFormat) {
        /** @type {?} */
        const obj = moment().startOf('date');
        if (timeFormat.indexOf('HH') >= 0) {
            this.hoursArray = this.initHoursArray(obj, 23, 'HH');
            this.slideOptsHours.initialSlide = this.momentObj.locale('en').format('HH');
        }
        else if (timeFormat.indexOf('H') >= 0) {
            this.hoursArray = this.initHoursArray(obj, 23, 'H');
            this.slideOptsHours.initialSlide = this.momentObj.locale('en').format('H');
        }
        else if (timeFormat.indexOf('hh') >= 0) {
            this.hoursArray = this.initHoursArray(obj.add(1, 'hours'), 11, 'hh');
            this.slideOptsHours.initialSlide = this.momentObj.locale('en').format('hh') - 1;
        }
        else if (timeFormat.indexOf('h') >= 0) {
            this.hoursArray = this.initHoursArray(obj.add(1, 'hours'), 11, 'h');
            this.slideOptsHours.initialSlide = this.momentObj.locale('en').format('h') - 1;
        }
        else if (timeFormat.indexOf('kk') >= 0) {
            this.hoursArray = this.initHoursArray(obj.add(1, 'hours'), 23, 'kk');
            this.slideOptsHours.initialSlide = this.momentObj.locale('en').format('kk') - 1;
        }
        else if (timeFormat.indexOf('k') >= 0) {
            this.hoursArray = this.initHoursArray(obj.add(1, 'hours'), 23, 'k');
            this.slideOptsHours.initialSlide = this.momentObj.locale('en').format('k') - 1;
        }
        // console.log('hours array =>', this.hoursArray);
    }
    // Initialize hours array
    /**
     * @param {?} momentObj
     * @param {?} end
     * @param {?} format
     * @return {?}
     */
    initHoursArray(momentObj, end, format) {
        /** @type {?} */
        const hoursArray = [];
        for (let i = 0; i <= end; i++) {
            hoursArray.push(momentObj.format(format));
            momentObj.add(1, 'hours');
        }
        return hoursArray;
    }
    // sets minutes array
    /**
     * @param {?} timeFormat
     * @return {?}
     */
    setMinutesArray(timeFormat) {
        if (timeFormat.indexOf('mm') >= 0) {
            this.minutesArray = this.initMinutesArray('mm');
            this.slideOptsMinutes.initialSlide = Number(this.momentObj.format('mm'));
        }
        else if (timeFormat.indexOf('m') >= 0) {
            this.minutesArray = this.initMinutesArray('m');
            this.slideOptsMinutes.initialSlide = Number(this.momentObj.format('m'));
        }
        // console.log('minutes array =>', this.minutesArray);
    }
    // initialize minutes array
    /**
     * @param {?} format
     * @return {?}
     */
    initMinutesArray(format) {
        /** @type {?} */
        const obj = moment().startOf('hour');
        /** @type {?} */
        const minutesArray = [];
        for (let i = 0; i < 60; i++) {
            minutesArray.push(obj.format(format));
            obj.add(1, 'minutes');
        }
        return minutesArray;
    }
    // sets seconds array
    /**
     * @param {?} timeFormat
     * @return {?}
     */
    setSecondsArray(timeFormat) {
        if (timeFormat.indexOf('ss') >= 0) {
            this.secondsArray = this.initSecondsArray('ss');
            this.slideOptsSeconds.initialSlide = Number(this.momentObj.format('ss'));
        }
        else if (timeFormat.indexOf('s') >= 0) {
            this.secondsArray = this.initSecondsArray('s');
            this.slideOptsSeconds.initialSlide = Number(this.momentObj.format('s'));
        }
        // console.log('seconds array =>', this.secondsArray);
    }
    // initialize seconds array
    /**
     * @param {?} format
     * @return {?}
     */
    initSecondsArray(format) {
        /** @type {?} */
        const obj = moment().startOf('minute');
        /** @type {?} */
        const secondsArray = [];
        for (let i = 0; i < 60; i++) {
            secondsArray.push(obj.format(format));
            obj.add(1, 'seconds');
        }
        return secondsArray;
    }
    // set meridian array
    /**
     * @param {?} timeFormat
     * @return {?}
     */
    setMeridianArray(timeFormat) {
        if (timeFormat.indexOf('a') >= 0 || timeFormat.indexOf('A') >= 0) {
            /** @type {?} */
            const format = timeFormat.indexOf('a') >= 0 ? 'a' : 'A';
            /** @type {?} */
            const obj = moment().startOf('date');
            this.meridianArray.push(obj.format(format));
            this.meridianArray.push(obj.add(12, 'hours').format(format));
        }
        // console.log('meridian array =>', this.meridianArray);
        if (timeFormat.indexOf('a') >= 0) {
            this.slideOptsMeridian.initialSlide = this.momentObj.format('a') === 'am' ? 0 : 1;
        }
        else if (timeFormat.indexOf('A') >= 0) {
            this.slideOptsMeridian.initialSlide = this.momentObj.format('A') === 'AM' ? 0 : 1;
        }
    }
}
IonicTimepickerModalComponent.decorators = [
    { type: Component, args: [{
                selector: 'li-ionic-timepicker-modal',
                template: "<ion-header>\n  <ion-toolbar>\n    <ion-title>\n      {{mainObj?.titleLabel}}\n    </ion-title>\n  </ion-toolbar>\n</ion-header>\n\n\n\n<ion-content scrollX=\"false\" scrollY=\"false\" >\n  <!-- <div class=\"loader\" *ngIf=\"!isReady\"></div> -->\n\n  <div class=\"tp-active\" [ngClass]=\"{'isReady': isReady}\"></div>\n\n  <ion-grid class=\"tp-slide-container\" [ngClass]=\"{'isReady': isReady}\">\n    <ion-row>\n      <ion-col>\n        <ion-slides #sliderHours pager=\"false\" [options]=\"slideOptsHours\" (ionSlideWillChange)=\"onChangeHoursSlide($event)\">\n          <ion-slide *ngFor=\"let hour of hoursArray; let i = index;\" class=\"tp-default-slide\">\n            {{ hour }}\n          </ion-slide>\n        </ion-slides>\n      </ion-col>\n\n      <ion-col size=\"1\" class=\"tp-colon\" *ngIf=\"minutesArray?.length > 0\">\n        <ion-label>:</ion-label>\n      </ion-col>\n      <ion-col *ngIf=\"minutesArray?.length > 0\">\n        <ion-slides #sliderMinutes pager=\"false\" [options]=\"slideOptsMinutes\" (ionSlideWillChange)=\"onChangeMinutesSlide($event)\">\n          <ion-slide *ngFor=\"let minute of minutesArray; let i = index;\" class=\"tp-default-slide\">\n            {{ minute }}\n          </ion-slide>\n        </ion-slides>\n      </ion-col>\n\n      <ion-col size=\"1\" class=\"tp-colon\" *ngIf=\"secondsArray?.length > 0\">\n        <ion-label>:</ion-label>\n      </ion-col>\n      <ion-col *ngIf=\"secondsArray?.length > 0\">\n        <ion-slides #sliderSeconds pager=\"false\" [options]=\"slideOptsSeconds\" (ionSlideWillChange)=\"onChangeSecondsSlide($event)\">\n          <ion-slide *ngFor=\"let second of secondsArray; let i = index ;\" class=\"tp-default-slide\">\n            {{ second }}\n          </ion-slide>\n        </ion-slides>\n      </ion-col>\n\n      <ion-col size=\"1\" class=\"tp-colon\" *ngIf=\"meridianArray?.length > 0\">\n        <ion-label>:</ion-label>\n      </ion-col>\n      <ion-col *ngIf=\"meridianArray?.length > 0\">\n        <ion-slides #sliderMeridian pager=\"false\" [options]=\"slideOptsMeridian\" (ionSlideWillChange)=\"onChangeMeridianSlide($event)\">\n          <ion-slide *ngFor=\"let meridian of meridianArray; let i = index ;\" class=\"tp-default-slide\">\n            {{ meridian }}\n          </ion-slide>\n        </ion-slides>\n      </ion-col>\n    </ion-row>\n  </ion-grid>\n\n</ion-content>\n\n<ion-footer [ngClass]=\"{'isReady': isReady}\">\n  <ion-toolbar>\n    <ion-grid no-padding>\n      <ion-row no-padding [ngClass]=\"mainObj?.btnCloseSetInReverse ? 'dp-btn-set-close-in-reverse' : ''\">\n        <ion-col size=\"6\" no-padding>\n          <ion-button class=\"ion-button\" expand=\"{{mainObj?.btnProperties?.expand}}\" fill=\"{{mainObj?.btnProperties?.fill}}\"\n            size=\"{{mainObj?.btnProperties?.size}}\" color=\"{{mainObj?.btnProperties?.color}}\" disabled=\"{{mainObj?.btnProperties?.disabled}}\"\n            strong=\"{{mainObj?.btnProperties?.strong}}\" (click)=\"closeIonicTimePickerModal()\">\n            {{mainObj?.closeLabel}}\n          </ion-button>\n        </ion-col>\n        <ion-col size=\"6\" no-padding>\n          <ion-button class=\"ion-button\" expand=\"{{mainObj?.btnProperties?.expand}}\" fill=\"{{mainObj?.btnProperties?.fill}}\"\n            size=\"{{mainObj?.btnProperties?.size}}\" color=\"{{mainObj?.btnProperties?.color}}\" disabled=\"{{mainObj?.btnProperties?.disabled}}\"\n            strong=\"{{mainObj?.btnProperties?.strong}}\" (click)=\"setIonicTimePickerTime()\">\n            {{mainObj?.setLabel}}\n          </ion-button>\n        </ion-col>\n      </ion-row>\n    </ion-grid>\n  </ion-toolbar>\n</ion-footer>",
                styles: [":host ion-header{height:48px}:host ion-header ion-toolbar{--background:var(--ion-color-primary);height:100%;align-items:center;display:flex;color:var(--ion-color-primary-contrast)}:host ion-header ion-toolbar ion-title{font-size:20px;font-weight:700;text-align:center}@media (min-width:768px){:host ion-header ion-toolbar ion-title{font-size:22px}}:host ion-footer{height:44px}:host ion-footer ion-toolbar{--min-height:100%;--border-width:0;--padding-top:0px;--padding-bottom:0px;--padding-start:0px;--padding-end:0px}:host ion-footer ion-toolbar .dp-btn-set-close-in-reverse{flex-direction:row-reverse}:host ion-footer ion-toolbar ion-button{--border-radius:0;height:44px;margin:0}:host ion-footer ion-toolbar ion-button:focus{outline:0}:host ion-footer ion-toolbar ion-button.activated{--background-activated:var(--ion-color-primary-tint);--color-activated:white}:host .swiper-slide-active{color:var(--ion-color-primary)!important;font-size:20px!important}:host .tp-default-slide{color:#adadad;font-size:16px}:host .tp-slide-container{padding:5px!important;position:relative}:host .tp-slide-container ion-slides{height:165px}:host .tp-slide-container .tp-colon{font-style:bold;font-weight:700;margin-bottom:3px;display:flex;align-items:center;justify-content:center}:host .tp-active{position:absolute;top:76px;left:5px;width:300px;height:33px;background-color:#d3d3d3}:host .tp-active,:host .tp-slide-container,:host ion-footer{opacity:0}:host .isReady{opacity:1;transition:opacity .4s ease-in}:host .loader{border:5px solid #f3f3f3;border-radius:50%;border-top:5px solid var(--ion-color-primary);width:50px;height:50px;-webkit-animation:2s linear infinite spin;animation:2s linear infinite spin;position:absolute;top:50%;left:50%;margin:-25px 0 0 -25px}@-webkit-keyframes spin{0%{-webkit-transform:rotate(0)}100%{-webkit-transform:rotate(360deg)}}@keyframes spin{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}"]
            }] }
];
/** @nocollapse */
IonicTimepickerModalComponent.ctorParameters = () => [
    { type: NavParams },
    { type: ModalController }
];
IonicTimepickerModalComponent.propDecorators = {
    sliderHours: [{ type: ViewChild, args: ['sliderHours',] }],
    sliderMinutes: [{ type: ViewChild, args: ['sliderMinutes',] }],
    sliderSeconds: [{ type: ViewChild, args: ['sliderSeconds',] }],
    sliderMeridian: [{ type: ViewChild, args: ['sliderMeridian',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const noop = (/**
 * @return {?}
 */
() => {
});
/** @type {?} */
const CUSTOM_INPUT_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef((/**
     * @return {?}
     */
    () => IonicTimepickerComponent)),
    multi: true,
};
class IonicTimepickerComponent {
    /**
     * @param {?} modalCtrl
     * @param {?} el
     * @param {?} renderer
     */
    constructor(modalCtrl, el, renderer) {
        this.modalCtrl = modalCtrl;
        this.el = el;
        this.renderer = renderer;
        this.innerValue = '';
        // Placeholders for the callbacks which are later provided
        // by the Control Value Accessor
        this.onTouchedCallback = noop;
        this.onChangeCallback = noop;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.inputTimeConfig.clearButton !== false) {
            this.closeIcon = document.createElement('ion-icon');
            this.closeIcon.name = 'close-circle';
            this.closeIcon.className = 'clearButton';
            this.closeIcon.style.position = 'absolute';
            this.closeIcon.style.right = '8px';
            this.closeIcon.style.bottom = '0px';
            this.closeIcon.style.fontSize = '18px';
            this.closeIcon.style.zIndex = '5';
            this.closeIcon.style.color = '#A9A9A9';
            if (!this.value) {
                this.closeIcon.style.visibility = 'hidden';
            }
            if (this.el.nativeElement.parentNode.nodeName === 'ION-ITEM') {
                this.closeIcon.style.bottom = '30%';
            }
            this.el.nativeElement.setAttribute('style', 'position: relative; width: 100%;');
            this.el.nativeElement.appendChild(this.closeIcon);
            this.renderer.listen(this.closeIcon, 'click', (/**
             * @param {?} event
             * @return {?}
             */
            (event) => {
                // console.log('button clicks');
                this.selectedTime = '';
                this.value = '';
            }));
        }
    }
    // calls when input value has been changed.
    /**
     * @param {?} value
     * @return {?}
     */
    onChangeValue(value) {
        // console.log('onChangeValue =>' , value);
        if (this.inputTimeConfig.clearButton || this.inputTimeConfig.clearButton === undefined) {
            if (!value) {
                this.closeIcon.style.visibility = 'hidden';
            }
            else {
                this.closeIcon.style.visibility = 'visible';
            }
        }
    }
    // open time picker
    /**
     * @param {?} value
     * @return {?}
     */
    openTimePicker(value) {
        return __awaiter(this, void 0, void 0, function* () {
            // console.log('open time picker modal calls');
            if (value) {
                this.selectedTime = value;
            }
            /** @type {?} */
            const myTimePickerModal = yield this.modalCtrl.create({
                component: IonicTimepickerModalComponent,
                cssClass: 'li-ionic-timepicker',
                componentProps: { 'objConfig': this.inputTimeConfig, 'selectedTime': this.selectedTime }
            });
            yield myTimePickerModal.present();
            myTimePickerModal.onDidDismiss()
                .then((/**
             * @param {?} data
             * @return {?}
             */
            (data) => {
                // console.log(data);
                if (data.data && data.data.time) {
                    this.selectedTime = data.data.time;
                    this.value = data.data.time;
                }
            }));
        });
    }
    // get accessor
    /**
     * @return {?}
     */
    get value() {
        return this.innerValue;
    }
    // set accessor including call the onchange callback
    /**
     * @param {?} v
     * @return {?}
     */
    set value(v) {
        if (v !== this.innerValue) {
            this.innerValue = v;
            this.onChangeCallback(v);
        }
        this.onChangeValue(v);
    }
    // Set touched on blur
    /**
     * @return {?}
     */
    onBlur() {
        this.onTouchedCallback();
    }
    // From ControlValueAccessor interface
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value !== this.innerValue) {
            this.innerValue = value;
        }
        this.onChangeValue(value);
    }
    // From ControlValueAccessor interface
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    // From ControlValueAccessor interface
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        throw new Error('Method not implemented.');
    }
}
IonicTimepickerComponent.decorators = [
    { type: Component, args: [{
                selector: 'li-ionic-timepicker',
                template: "<input type=\"text\" (focus)=\"$event.preventDefault()\" (click)=\"openTimePicker(value)\" readonly [(ngModel)]=\"value\" start />",
                providers: [CUSTOM_INPUT_CONTROL_VALUE_ACCESSOR],
                styles: ["input{font-size:16px;border:0;border-bottom:1px solid #ccc;width:100%;padding:8px}@media (min-width:768px){input{font-size:18px}}input.has-focus,input:focus{outline:0;box-shadow:unset}"]
            }] }
];
/** @nocollapse */
IonicTimepickerComponent.ctorParameters = () => [
    { type: ModalController },
    { type: ElementRef },
    { type: Renderer }
];
IonicTimepickerComponent.propDecorators = {
    inputTimeConfig: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LiIonicTimepickerDirective {
    /**
     * @param {?} modalCtrl
     * @param {?} ngModel
     * @param {?} control
     * @param {?} el
     * @param {?} renderer
     */
    constructor(modalCtrl, ngModel, control, el, renderer) {
        this.modalCtrl = modalCtrl;
        this.ngModel = ngModel;
        this.control = control;
        this.el = el;
        this.renderer = renderer;
        this.isModalOpen = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // console.log('this.inp', this.inputTimeConfig.clearButton);
        if (this.inputTimeConfig.clearButton !== false) {
            this.closeIcon = document.createElement('ion-icon');
            this.closeIcon.name = 'close-circle';
            this.closeIcon.className = 'clearButton';
            this.closeIcon.style.position = 'absolute';
            this.closeIcon.style.right = '8px';
            this.closeIcon.style.bottom = '30%';
            this.closeIcon.style.fontSize = '18px';
            this.closeIcon.style.zIndex = '5';
            this.closeIcon.style.color = '#A9A9A9';
            if (!this.ngModel.value || !this.control.control.value) {
                this.closeIcon.style.visibility = 'hidden';
            }
            if (this.el.nativeElement.parentNode.nodeName === 'ION-ITEM') {
                this.closeIcon.style.bottom = '12px';
            }
            this.el.nativeElement.parentNode.appendChild(this.closeIcon);
            this.renderer.listen(this.closeIcon, 'click', (/**
             * @param {?} event
             * @return {?}
             */
            (event) => {
                // console.log('button clicks');
                this.selectedTime = '';
                this.control.control.setValue('');
                this.ngModel.update.emit('');
            }));
        }
        /** @type {?} */
        const self = this;
        this.ngModel.valueChanges.subscribe((/**
         * @param {?} value
         * @return {?}
         */
        (value) => {
            // console.log('ngModel value =>', value);
            self.selectedTime = value;
            if (self.inputTimeConfig.clearButton !== false) {
                if (!value) {
                    self.closeIcon.style.visibility = 'hidden';
                }
                else {
                    self.closeIcon.style.visibility = 'visible';
                }
            }
        }));
        this.control.control.valueChanges.subscribe((/**
         * @param {?} value
         * @return {?}
         */
        (value) => {
            // console.log('formcontrol value =>', value);
            self.selectedTime = value;
            if (self.inputTimeConfig.clearButton !== false) {
                if (!value) {
                    self.closeIcon.style.visibility = 'hidden';
                }
                else {
                    self.closeIcon.style.visibility = 'visible';
                }
            }
        }));
        if (this.control.control.value) {
            this.selectedTime = this.control.control.value;
        }
        if (this.ngModel.value) {
            this.selectedTime = this.ngModel.value;
        }
    }
    // @HostListener('click')
    // onClick() {
    //   // console.log('on click of component =>', this.inputTimeConfig);
    //   if (!this.isModalOpen) {
    //     this.isModalOpen = true;
    //     this.openTimePicker();
    //   }
    // }
    /**
     * @return {?}
     */
    onFocus() {
        // console.log('on focus of component =>', this.inputTimeConfig);
        if (!this.isModalOpen) {
            this.isModalOpen = true;
            this.openTimePicker();
        }
    }
    // open time picker
    /**
     * @return {?}
     */
    openTimePicker() {
        return __awaiter(this, void 0, void 0, function* () {
            // console.log('open time picker modal calls');
            /** @type {?} */
            const myTimePickerModal = yield this.modalCtrl.create({
                component: IonicTimepickerModalComponent,
                cssClass: 'li-ionic-timepicker',
                componentProps: { 'objConfig': this.inputTimeConfig, 'selectedTime': this.selectedTime }
            });
            yield myTimePickerModal.present();
            myTimePickerModal.onDidDismiss()
                .then((/**
             * @param {?} data
             * @return {?}
             */
            (data) => {
                this.isModalOpen = false;
                // console.log(data);
                if (data.data && data.data.time) {
                    this.selectedTime = data.data.time;
                    this.control.control.setValue(this.selectedTime);
                    this.ngModel.update.emit(this.selectedTime);
                }
            }));
        });
    }
}
LiIonicTimepickerDirective.decorators = [
    { type: Directive, args: [{
                selector: '[liIonicTimepicker]',
                exportAs: 'liIonicTimepicker',
                providers: [NgModel]
            },] }
];
/** @nocollapse */
LiIonicTimepickerDirective.ctorParameters = () => [
    { type: ModalController },
    { type: NgModel },
    { type: NgControl },
    { type: ElementRef },
    { type: Renderer }
];
LiIonicTimepickerDirective.propDecorators = {
    inputTimeConfig: [{ type: Input, args: ['liIonicTimepicker',] }],
    onFocus: [{ type: HostListener, args: ['ionFocus',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IonicTimepickerModule {
}
IonicTimepickerModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    IonicModule
                ],
                entryComponents: [
                    // IonicTimepickerComponent,
                    IonicTimepickerModalComponent
                ],
                declarations: [
                    IonicTimepickerComponent,
                    IonicTimepickerModalComponent,
                    LiIonicTimepickerDirective
                ],
                exports: [
                    FormsModule,
                    CommonModule,
                    IonicTimepickerComponent,
                    LiIonicTimepickerDirective,
                    IonicTimepickerModalComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { IonicTimepickerService, CUSTOM_INPUT_CONTROL_VALUE_ACCESSOR, IonicTimepickerComponent, IonicTimepickerModule, IonicTimepickerModalComponent, LiIonicTimepickerDirective as ɵa };

//# sourceMappingURL=logisticinfotech-ionic-timepicker.js.map